import { r as __toESM, t as __commonJS } from "./chunk-DUEDWNxO.js";
import { t as require_react } from "./react-C9OIcBSU.js";
import { t as require_react_dom } from "./react-dom-Db1AkXVs.js";
import { t as require_jsx_runtime } from "./jsx-runtime-BU8pKtZd.js";
import { D as replaceEqualDeep, E as last, S as isModuleNotFoundError, T as isPromise, _ as invariant, a as cleanPath, b as findLast, c as joinPaths, d as parsePathname, f as removeTrailingSlash, g as trimPathRight, h as trimPathLeft, i as SEGMENT_TYPE_PATHNAME, m as trimPath, n as SEGMENT_TYPE_OPTIONAL_PARAM, o as exactPathTest, p as resolvePath, r as SEGMENT_TYPE_PARAM, s as interpolatePath, t as rootRouteId, u as matchPathname, v as createControlledPromise, x as functionalUpdate, y as deepEqual } from "./root-Cjj8VExB.js";

//#region node_modules/@tanstack/store/dist/esm/scheduler.js
var __storeToDerived = /* @__PURE__ */ new WeakMap();
var __derivedToStore = /* @__PURE__ */ new WeakMap();
var __depsThatHaveWrittenThisTick = { current: [] };
var __isFlushing = false;
var __batchDepth = 0;
var __pendingUpdates = /* @__PURE__ */ new Set();
var __initialBatchValues = /* @__PURE__ */ new Map();
function __flush_internals(relatedVals) {
	const sorted = Array.from(relatedVals).sort((a, b) => {
		if (a instanceof Derived && a.options.deps.includes(b)) return 1;
		if (b instanceof Derived && b.options.deps.includes(a)) return -1;
		return 0;
	});
	for (const derived of sorted) {
		if (__depsThatHaveWrittenThisTick.current.includes(derived)) continue;
		__depsThatHaveWrittenThisTick.current.push(derived);
		derived.recompute();
		const stores = __derivedToStore.get(derived);
		if (stores) for (const store of stores) {
			const relatedLinkedDerivedVals = __storeToDerived.get(store);
			if (!relatedLinkedDerivedVals) continue;
			__flush_internals(relatedLinkedDerivedVals);
		}
	}
}
function __notifyListeners(store) {
	const value = {
		prevVal: store.prevState,
		currentVal: store.state
	};
	for (const listener of store.listeners) listener(value);
}
function __notifyDerivedListeners(derived) {
	const value = {
		prevVal: derived.prevState,
		currentVal: derived.state
	};
	for (const listener of derived.listeners) listener(value);
}
function __flush(store) {
	if (__batchDepth > 0 && !__initialBatchValues.has(store)) __initialBatchValues.set(store, store.prevState);
	__pendingUpdates.add(store);
	if (__batchDepth > 0) return;
	if (__isFlushing) return;
	try {
		__isFlushing = true;
		while (__pendingUpdates.size > 0) {
			const stores = Array.from(__pendingUpdates);
			__pendingUpdates.clear();
			for (const store2 of stores) {
				store2.prevState = __initialBatchValues.get(store2) ?? store2.prevState;
				__notifyListeners(store2);
			}
			for (const store2 of stores) {
				const derivedVals = __storeToDerived.get(store2);
				if (!derivedVals) continue;
				__depsThatHaveWrittenThisTick.current.push(store2);
				__flush_internals(derivedVals);
			}
			for (const store2 of stores) {
				const derivedVals = __storeToDerived.get(store2);
				if (!derivedVals) continue;
				for (const derived of derivedVals) __notifyDerivedListeners(derived);
			}
		}
	} finally {
		__isFlushing = false;
		__depsThatHaveWrittenThisTick.current = [];
		__initialBatchValues.clear();
	}
}
function batch(fn) {
	__batchDepth++;
	try {
		fn();
	} finally {
		__batchDepth--;
		if (__batchDepth === 0) {
			const pendingUpdateToFlush = __pendingUpdates.values().next().value;
			if (pendingUpdateToFlush) __flush(pendingUpdateToFlush);
		}
	}
}

//#endregion
//#region node_modules/@tanstack/store/dist/esm/types.js
function isUpdaterFunction(updater) {
	return typeof updater === "function";
}

//#endregion
//#region node_modules/@tanstack/store/dist/esm/store.js
var Store = class {
	constructor(initialState, options) {
		this.listeners = /* @__PURE__ */ new Set();
		this.subscribe = (listener) => {
			var _a, _b;
			this.listeners.add(listener);
			const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
			return () => {
				this.listeners.delete(listener);
				unsub?.();
			};
		};
		this.prevState = initialState;
		this.state = initialState;
		this.options = options;
	}
	setState(updater) {
		var _a, _b, _c;
		this.prevState = this.state;
		if ((_a = this.options) == null ? void 0 : _a.updateFn) this.state = this.options.updateFn(this.prevState)(updater);
		else if (isUpdaterFunction(updater)) this.state = updater(this.prevState);
		else this.state = updater;
		(_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null || _c.call(_b);
		__flush(this);
	}
};

//#endregion
//#region node_modules/@tanstack/store/dist/esm/derived.js
var Derived = class Derived {
	constructor(options) {
		this.listeners = /* @__PURE__ */ new Set();
		this._subscriptions = [];
		this.lastSeenDepValues = [];
		this.getDepVals = () => {
			const l = this.options.deps.length;
			const prevDepVals = new Array(l);
			const currDepVals = new Array(l);
			for (let i = 0; i < l; i++) {
				const dep = this.options.deps[i];
				prevDepVals[i] = dep.prevState;
				currDepVals[i] = dep.state;
			}
			this.lastSeenDepValues = currDepVals;
			return {
				prevDepVals,
				currDepVals,
				prevVal: this.prevState ?? void 0
			};
		};
		this.recompute = () => {
			var _a, _b;
			this.prevState = this.state;
			const depVals = this.getDepVals();
			this.state = this.options.fn(depVals);
			(_b = (_a = this.options).onUpdate) == null || _b.call(_a);
		};
		this.checkIfRecalculationNeededDeeply = () => {
			for (const dep of this.options.deps) if (dep instanceof Derived) dep.checkIfRecalculationNeededDeeply();
			let shouldRecompute = false;
			const lastSeenDepValues = this.lastSeenDepValues;
			const { currDepVals } = this.getDepVals();
			for (let i = 0; i < currDepVals.length; i++) if (currDepVals[i] !== lastSeenDepValues[i]) {
				shouldRecompute = true;
				break;
			}
			if (shouldRecompute) this.recompute();
		};
		this.mount = () => {
			this.registerOnGraph();
			this.checkIfRecalculationNeededDeeply();
			return () => {
				this.unregisterFromGraph();
				for (const cleanup of this._subscriptions) cleanup();
			};
		};
		this.subscribe = (listener) => {
			var _a, _b;
			this.listeners.add(listener);
			const unsub = (_b = (_a = this.options).onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
			return () => {
				this.listeners.delete(listener);
				unsub?.();
			};
		};
		this.options = options;
		this.state = options.fn({
			prevDepVals: void 0,
			prevVal: void 0,
			currDepVals: this.getDepVals().currDepVals
		});
	}
	registerOnGraph(deps = this.options.deps) {
		for (const dep of deps) if (dep instanceof Derived) {
			dep.registerOnGraph();
			this.registerOnGraph(dep.options.deps);
		} else if (dep instanceof Store) {
			let relatedLinkedDerivedVals = __storeToDerived.get(dep);
			if (!relatedLinkedDerivedVals) {
				relatedLinkedDerivedVals = /* @__PURE__ */ new Set();
				__storeToDerived.set(dep, relatedLinkedDerivedVals);
			}
			relatedLinkedDerivedVals.add(this);
			let relatedStores = __derivedToStore.get(this);
			if (!relatedStores) {
				relatedStores = /* @__PURE__ */ new Set();
				__derivedToStore.set(this, relatedStores);
			}
			relatedStores.add(dep);
		}
	}
	unregisterFromGraph(deps = this.options.deps) {
		for (const dep of deps) if (dep instanceof Derived) this.unregisterFromGraph(dep.options.deps);
		else if (dep instanceof Store) {
			const relatedLinkedDerivedVals = __storeToDerived.get(dep);
			if (relatedLinkedDerivedVals) relatedLinkedDerivedVals.delete(this);
			const relatedStores = __derivedToStore.get(this);
			if (relatedStores) relatedStores.delete(dep);
		}
	}
};

//#endregion
//#region node_modules/@tanstack/history/dist/esm/index.js
var stateIndexKey = "__TSR_index";
var popStateEvent = "popstate";
var beforeUnloadEvent = "beforeunload";
function createHistory(opts) {
	let location = opts.getLocation();
	const subscribers = /* @__PURE__ */ new Set();
	const notify = (action) => {
		location = opts.getLocation();
		subscribers.forEach((subscriber) => subscriber({
			location,
			action
		}));
	};
	const handleIndexChange = (action) => {
		if (opts.notifyOnIndexChange ?? true) notify(action);
		else location = opts.getLocation();
	};
	const tryNavigation = async ({ task, navigateOpts,...actionInfo }) => {
		if (navigateOpts?.ignoreBlocker ?? false) {
			task();
			return;
		}
		const blockers = opts.getBlockers?.() ?? [];
		const isPushOrReplace = actionInfo.type === "PUSH" || actionInfo.type === "REPLACE";
		if (typeof document !== "undefined" && blockers.length && isPushOrReplace) for (const blocker of blockers) {
			const nextLocation = parseHref(actionInfo.path, actionInfo.state);
			if (await blocker.blockerFn({
				currentLocation: location,
				nextLocation,
				action: actionInfo.type
			})) {
				opts.onBlocked?.();
				return;
			}
		}
		task();
	};
	return {
		get location() {
			return location;
		},
		get length() {
			return opts.getLength();
		},
		subscribers,
		subscribe: (cb) => {
			subscribers.add(cb);
			return () => {
				subscribers.delete(cb);
			};
		},
		push: (path, state, navigateOpts) => {
			const currentIndex = location.state[stateIndexKey];
			state = assignKeyAndIndex(currentIndex + 1, state);
			tryNavigation({
				task: () => {
					opts.pushState(path, state);
					notify({ type: "PUSH" });
				},
				navigateOpts,
				type: "PUSH",
				path,
				state
			});
		},
		replace: (path, state, navigateOpts) => {
			const currentIndex = location.state[stateIndexKey];
			state = assignKeyAndIndex(currentIndex, state);
			tryNavigation({
				task: () => {
					opts.replaceState(path, state);
					notify({ type: "REPLACE" });
				},
				navigateOpts,
				type: "REPLACE",
				path,
				state
			});
		},
		go: (index, navigateOpts) => {
			tryNavigation({
				task: () => {
					opts.go(index);
					handleIndexChange({
						type: "GO",
						index
					});
				},
				navigateOpts,
				type: "GO"
			});
		},
		back: (navigateOpts) => {
			tryNavigation({
				task: () => {
					opts.back(navigateOpts?.ignoreBlocker ?? false);
					handleIndexChange({ type: "BACK" });
				},
				navigateOpts,
				type: "BACK"
			});
		},
		forward: (navigateOpts) => {
			tryNavigation({
				task: () => {
					opts.forward(navigateOpts?.ignoreBlocker ?? false);
					handleIndexChange({ type: "FORWARD" });
				},
				navigateOpts,
				type: "FORWARD"
			});
		},
		canGoBack: () => location.state[stateIndexKey] !== 0,
		createHref: (str) => opts.createHref(str),
		block: (blocker) => {
			if (!opts.setBlockers) return () => {};
			const blockers = opts.getBlockers?.() ?? [];
			opts.setBlockers([...blockers, blocker]);
			return () => {
				const blockers2 = opts.getBlockers?.() ?? [];
				opts.setBlockers?.(blockers2.filter((b) => b !== blocker));
			};
		},
		flush: () => opts.flush?.(),
		destroy: () => opts.destroy?.(),
		notify
	};
}
function assignKeyAndIndex(index, state) {
	if (!state) state = {};
	const key = createRandomKey();
	return {
		...state,
		key,
		__TSR_key: key,
		[stateIndexKey]: index
	};
}
function createBrowserHistory(opts) {
	const win = opts?.window ?? (typeof document !== "undefined" ? window : void 0);
	const originalPushState = win.history.pushState;
	const originalReplaceState = win.history.replaceState;
	let blockers = [];
	const _getBlockers = () => blockers;
	const _setBlockers = (newBlockers) => blockers = newBlockers;
	const createHref = opts?.createHref ?? ((path) => path);
	const parseLocation = opts?.parseLocation ?? (() => parseHref(`${win.location.pathname}${win.location.search}${win.location.hash}`, win.history.state));
	if (!win.history.state?.__TSR_key && !win.history.state?.key) {
		const addedKey = createRandomKey();
		win.history.replaceState({
			[stateIndexKey]: 0,
			key: addedKey,
			__TSR_key: addedKey
		}, "");
	}
	let currentLocation = parseLocation();
	let rollbackLocation;
	let nextPopIsGo = false;
	let ignoreNextPop = false;
	let skipBlockerNextPop = false;
	let ignoreNextBeforeUnload = false;
	const getLocation = () => currentLocation;
	let next;
	let scheduled;
	const flush = () => {
		if (!next) return;
		history._ignoreSubscribers = true;
		(next.isPush ? win.history.pushState : win.history.replaceState)(next.state, "", next.href);
		history._ignoreSubscribers = false;
		next = void 0;
		scheduled = void 0;
		rollbackLocation = void 0;
	};
	const queueHistoryAction = (type, destHref, state) => {
		const href = createHref(destHref);
		if (!scheduled) rollbackLocation = currentLocation;
		currentLocation = parseHref(destHref, state);
		next = {
			href,
			state,
			isPush: next?.isPush || type === "push"
		};
		if (!scheduled) scheduled = Promise.resolve().then(() => flush());
	};
	const onPushPop = (type) => {
		currentLocation = parseLocation();
		history.notify({ type });
	};
	const onPushPopEvent = async () => {
		if (ignoreNextPop) {
			ignoreNextPop = false;
			return;
		}
		const nextLocation = parseLocation();
		const delta = nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey];
		const isForward = delta === 1;
		const isBack = delta === -1;
		const isGo = !isForward && !isBack || nextPopIsGo;
		nextPopIsGo = false;
		const action = isGo ? "GO" : isBack ? "BACK" : "FORWARD";
		const notify = isGo ? {
			type: "GO",
			index: delta
		} : { type: isBack ? "BACK" : "FORWARD" };
		if (skipBlockerNextPop) skipBlockerNextPop = false;
		else {
			const blockers2 = _getBlockers();
			if (typeof document !== "undefined" && blockers2.length) {
				for (const blocker of blockers2) if (await blocker.blockerFn({
					currentLocation,
					nextLocation,
					action
				})) {
					ignoreNextPop = true;
					win.history.go(1);
					history.notify(notify);
					return;
				}
			}
		}
		currentLocation = parseLocation();
		history.notify(notify);
	};
	const onBeforeUnload = (e) => {
		if (ignoreNextBeforeUnload) {
			ignoreNextBeforeUnload = false;
			return;
		}
		let shouldBlock = false;
		const blockers2 = _getBlockers();
		if (typeof document !== "undefined" && blockers2.length) for (const blocker of blockers2) {
			const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? true;
			if (shouldHaveBeforeUnload === true) {
				shouldBlock = true;
				break;
			}
			if (typeof shouldHaveBeforeUnload === "function" && shouldHaveBeforeUnload() === true) {
				shouldBlock = true;
				break;
			}
		}
		if (shouldBlock) {
			e.preventDefault();
			return e.returnValue = "";
		}
	};
	const history = createHistory({
		getLocation,
		getLength: () => win.history.length,
		pushState: (href, state) => queueHistoryAction("push", href, state),
		replaceState: (href, state) => queueHistoryAction("replace", href, state),
		back: (ignoreBlocker) => {
			if (ignoreBlocker) skipBlockerNextPop = true;
			ignoreNextBeforeUnload = true;
			return win.history.back();
		},
		forward: (ignoreBlocker) => {
			if (ignoreBlocker) skipBlockerNextPop = true;
			ignoreNextBeforeUnload = true;
			win.history.forward();
		},
		go: (n) => {
			nextPopIsGo = true;
			win.history.go(n);
		},
		createHref: (href) => createHref(href),
		flush,
		destroy: () => {
			win.history.pushState = originalPushState;
			win.history.replaceState = originalReplaceState;
			win.removeEventListener(beforeUnloadEvent, onBeforeUnload, { capture: true });
			win.removeEventListener(popStateEvent, onPushPopEvent);
		},
		onBlocked: () => {
			if (rollbackLocation && currentLocation !== rollbackLocation) currentLocation = rollbackLocation;
		},
		getBlockers: _getBlockers,
		setBlockers: _setBlockers,
		notifyOnIndexChange: false
	});
	win.addEventListener(beforeUnloadEvent, onBeforeUnload, { capture: true });
	win.addEventListener(popStateEvent, onPushPopEvent);
	win.history.pushState = function(...args) {
		const res = originalPushState.apply(win.history, args);
		if (!history._ignoreSubscribers) onPushPop("PUSH");
		return res;
	};
	win.history.replaceState = function(...args) {
		const res = originalReplaceState.apply(win.history, args);
		if (!history._ignoreSubscribers) onPushPop("REPLACE");
		return res;
	};
	return history;
}
function createHashHistory(opts) {
	const win = opts?.window ?? (typeof document !== "undefined" ? window : void 0);
	return createBrowserHistory({
		window: win,
		parseLocation: () => {
			const hashSplit = win.location.hash.split("#").slice(1);
			const pathPart = hashSplit[0] ?? "/";
			const searchPart = win.location.search;
			const hashEntries = hashSplit.slice(1);
			return parseHref(`${pathPart}${searchPart}${hashEntries.length === 0 ? "" : `#${hashEntries.join("#")}`}`, win.history.state);
		},
		createHref: (href) => `${win.location.pathname}${win.location.search}#${href}`
	});
}
function createMemoryHistory(opts = { initialEntries: ["/"] }) {
	const entries = opts.initialEntries;
	let index = opts.initialIndex ? Math.min(Math.max(opts.initialIndex, 0), entries.length - 1) : entries.length - 1;
	const states = entries.map((_entry, index2) => assignKeyAndIndex(index2, void 0));
	const getLocation = () => parseHref(entries[index], states[index]);
	return createHistory({
		getLocation,
		getLength: () => entries.length,
		pushState: (path, state) => {
			if (index < entries.length - 1) {
				entries.splice(index + 1);
				states.splice(index + 1);
			}
			states.push(state);
			entries.push(path);
			index = Math.max(entries.length - 1, 0);
		},
		replaceState: (path, state) => {
			states[index] = state;
			entries[index] = path;
		},
		back: () => {
			index = Math.max(index - 1, 0);
		},
		forward: () => {
			index = Math.min(index + 1, entries.length - 1);
		},
		go: (n) => {
			index = Math.min(Math.max(index + n, 0), entries.length - 1);
		},
		createHref: (path) => path
	});
}
function parseHref(href, state) {
	const hashIndex = href.indexOf("#");
	const searchIndex = href.indexOf("?");
	const addedKey = createRandomKey();
	return {
		href,
		pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),
		hash: hashIndex > -1 ? href.substring(hashIndex) : "",
		search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
		state: state || {
			[stateIndexKey]: 0,
			key: addedKey,
			__TSR_key: addedKey
		}
	};
}
function createRandomKey() {
	return (Math.random() + 1).toString(36).substring(7);
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/process-route-tree.js
var SLASH_SCORE = .75;
var STATIC_SEGMENT_SCORE = 1;
var REQUIRED_PARAM_BASE_SCORE = .5;
var OPTIONAL_PARAM_BASE_SCORE = .4;
var WILDCARD_PARAM_BASE_SCORE = .25;
var STATIC_AFTER_DYNAMIC_BONUS_SCORE = .2;
var BOTH_PRESENCE_BASE_SCORE = .05;
var PREFIX_PRESENCE_BASE_SCORE = .02;
var SUFFIX_PRESENCE_BASE_SCORE = .01;
var PREFIX_LENGTH_SCORE_MULTIPLIER = 2e-4;
var SUFFIX_LENGTH_SCORE_MULTIPLIER = 1e-4;
function handleParam(segment, baseScore) {
	if (segment.prefixSegment && segment.suffixSegment) return baseScore + BOTH_PRESENCE_BASE_SCORE + PREFIX_LENGTH_SCORE_MULTIPLIER * segment.prefixSegment.length + SUFFIX_LENGTH_SCORE_MULTIPLIER * segment.suffixSegment.length;
	if (segment.prefixSegment) return baseScore + PREFIX_PRESENCE_BASE_SCORE + PREFIX_LENGTH_SCORE_MULTIPLIER * segment.prefixSegment.length;
	if (segment.suffixSegment) return baseScore + SUFFIX_PRESENCE_BASE_SCORE + SUFFIX_LENGTH_SCORE_MULTIPLIER * segment.suffixSegment.length;
	return baseScore;
}
function sortRoutes(routes) {
	const scoredRoutes = [];
	routes.forEach((d, i) => {
		if (d.isRoot || !d.path) return;
		const trimmed = trimPathLeft(d.fullPath);
		let parsed = parsePathname(trimmed);
		let skip = 0;
		while (parsed.length > skip + 1 && parsed[skip]?.value === "/") skip++;
		if (skip > 0) parsed = parsed.slice(skip);
		let optionalParamCount = 0;
		let hasStaticAfter = false;
		const scores = parsed.map((segment, index) => {
			if (segment.value === "/") return SLASH_SCORE;
			if (segment.type === SEGMENT_TYPE_PATHNAME) return STATIC_SEGMENT_SCORE;
			let baseScore = void 0;
			if (segment.type === SEGMENT_TYPE_PARAM) baseScore = REQUIRED_PARAM_BASE_SCORE;
			else if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
				baseScore = OPTIONAL_PARAM_BASE_SCORE;
				optionalParamCount++;
			} else baseScore = WILDCARD_PARAM_BASE_SCORE;
			for (let i2 = index + 1; i2 < parsed.length; i2++) {
				const nextSegment = parsed[i2];
				if (nextSegment.type === SEGMENT_TYPE_PATHNAME && nextSegment.value !== "/") {
					hasStaticAfter = true;
					return handleParam(segment, baseScore + STATIC_AFTER_DYNAMIC_BONUS_SCORE);
				}
			}
			return handleParam(segment, baseScore);
		});
		scoredRoutes.push({
			child: d,
			trimmed,
			parsed,
			index: i,
			scores,
			optionalParamCount,
			hasStaticAfter
		});
	});
	return scoredRoutes.sort((a, b) => {
		const minLength = Math.min(a.scores.length, b.scores.length);
		for (let i = 0; i < minLength; i++) if (a.scores[i] !== b.scores[i]) return b.scores[i] - a.scores[i];
		if (a.scores.length !== b.scores.length) {
			if (a.optionalParamCount !== b.optionalParamCount) {
				if (a.hasStaticAfter === b.hasStaticAfter) return a.optionalParamCount - b.optionalParamCount;
				else if (a.hasStaticAfter && !b.hasStaticAfter) return -1;
				else if (!a.hasStaticAfter && b.hasStaticAfter) return 1;
			}
			return b.scores.length - a.scores.length;
		}
		for (let i = 0; i < minLength; i++) if (a.parsed[i].value !== b.parsed[i].value) return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
		return a.index - b.index;
	}).map((d, i) => {
		d.child.rank = i;
		return d.child;
	});
}
function processRouteTree({ routeTree, initRoute }) {
	const routesById = {};
	const routesByPath = {};
	const recurseRoutes = (childRoutes) => {
		childRoutes.forEach((childRoute, i) => {
			initRoute?.(childRoute, i);
			const existingRoute = routesById[childRoute.id];
			invariant(!existingRoute, `Duplicate routes found with id: ${String(childRoute.id)}`);
			routesById[childRoute.id] = childRoute;
			if (!childRoute.isRoot && childRoute.path) {
				const trimmedFullPath = trimPathRight(childRoute.fullPath);
				if (!routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) routesByPath[trimmedFullPath] = childRoute;
			}
			const children = childRoute.children;
			if (children?.length) recurseRoutes(children);
		});
	};
	recurseRoutes([routeTree]);
	return {
		routesById,
		routesByPath,
		flatRoutes: sortRoutes(Object.values(routesById))
	};
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/not-found.js
function notFound(options = {}) {
	options.isNotFound = true;
	if (options.throw) throw options;
	return options;
}
function isNotFound(obj) {
	return !!obj?.isNotFound;
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/scroll-restoration.js
function getSafeSessionStorage() {
	try {
		if (typeof window !== "undefined" && typeof window.sessionStorage === "object") return window.sessionStorage;
	} catch {}
}
var storageKey = "tsr-scroll-restoration-v1_3";
var throttle = (fn, wait) => {
	let timeout;
	return (...args) => {
		if (!timeout) timeout = setTimeout(() => {
			fn(...args);
			timeout = null;
		}, wait);
	};
};
function createScrollRestorationCache() {
	const safeSessionStorage = getSafeSessionStorage();
	if (!safeSessionStorage) return null;
	const persistedState = safeSessionStorage.getItem(storageKey);
	let state = persistedState ? JSON.parse(persistedState) : {};
	return {
		state,
		set: (updater) => (state = functionalUpdate(updater, state) || state, safeSessionStorage.setItem(storageKey, JSON.stringify(state)))
	};
}
var scrollRestorationCache = createScrollRestorationCache();
var defaultGetScrollRestorationKey = (location) => {
	return location.state.__TSR_key || location.href;
};
function getCssSelector(el) {
	const path = [];
	let parent;
	while (parent = el.parentNode) {
		path.push(`${el.tagName}:nth-child(${Array.prototype.indexOf.call(parent.children, el) + 1})`);
		el = parent;
	}
	return `${path.reverse().join(" > ")}`.toLowerCase();
}
var ignoreScroll = false;
function restoreScroll({ storageKey: storageKey2, key, behavior, shouldScrollRestoration, scrollToTopSelectors, location }) {
	let byKey;
	try {
		byKey = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
	} catch (error) {
		console.error(error);
		return;
	}
	const resolvedKey = key || window.history.state?.__TSR_key;
	const elementEntries = byKey[resolvedKey];
	ignoreScroll = true;
	scroll: {
		if (shouldScrollRestoration && elementEntries && Object.keys(elementEntries).length > 0) {
			for (const elementSelector in elementEntries) {
				const entry = elementEntries[elementSelector];
				if (elementSelector === "window") window.scrollTo({
					top: entry.scrollY,
					left: entry.scrollX,
					behavior
				});
				else if (elementSelector) {
					const element = document.querySelector(elementSelector);
					if (element) {
						element.scrollLeft = entry.scrollX;
						element.scrollTop = entry.scrollY;
					}
				}
			}
			break scroll;
		}
		const hash = (location ?? window.location).hash.split("#", 2)[1];
		if (hash) {
			const hashScrollIntoViewOptions = window.history.state?.__hashScrollIntoViewOptions ?? true;
			if (hashScrollIntoViewOptions) {
				const el = document.getElementById(hash);
				if (el) el.scrollIntoView(hashScrollIntoViewOptions);
			}
			break scroll;
		}
		const scrollOptions = {
			top: 0,
			left: 0,
			behavior
		};
		window.scrollTo(scrollOptions);
		if (scrollToTopSelectors) for (const selector of scrollToTopSelectors) {
			if (selector === "window") continue;
			const element = typeof selector === "function" ? selector() : document.querySelector(selector);
			if (element) element.scrollTo(scrollOptions);
		}
	}
	ignoreScroll = false;
}
function setupScrollRestoration(router, force) {
	if (!scrollRestorationCache && !router.isServer) return;
	if (force ?? router.options.scrollRestoration ?? false) router.isScrollRestoring = true;
	if (router.isServer || router.isScrollRestorationSetup || !scrollRestorationCache) return;
	router.isScrollRestorationSetup = true;
	ignoreScroll = false;
	const getKey = router.options.getScrollRestorationKey || defaultGetScrollRestorationKey;
	window.history.scrollRestoration = "manual";
	const onScroll = (event) => {
		if (ignoreScroll || !router.isScrollRestoring) return;
		let elementSelector = "";
		if (event.target === document || event.target === window) elementSelector = "window";
		else {
			const attrId = event.target.getAttribute("data-scroll-restoration-id");
			if (attrId) elementSelector = `[data-scroll-restoration-id="${attrId}"]`;
			else elementSelector = getCssSelector(event.target);
		}
		const restoreKey = getKey(router.state.location);
		scrollRestorationCache.set((state) => {
			const keyEntry = state[restoreKey] ||= {};
			const elementEntry = keyEntry[elementSelector] ||= {};
			if (elementSelector === "window") {
				elementEntry.scrollX = window.scrollX || 0;
				elementEntry.scrollY = window.scrollY || 0;
			} else if (elementSelector) {
				const element = document.querySelector(elementSelector);
				if (element) {
					elementEntry.scrollX = element.scrollLeft || 0;
					elementEntry.scrollY = element.scrollTop || 0;
				}
			}
			return state;
		});
	};
	if (typeof document !== "undefined") document.addEventListener("scroll", throttle(onScroll, 100), true);
	router.subscribe("onRendered", (event) => {
		const cacheKey = getKey(event.toLocation);
		if (!router.resetNextScroll) {
			router.resetNextScroll = true;
			return;
		}
		if (typeof router.options.scrollRestoration === "function") {
			if (!router.options.scrollRestoration({ location: router.latestLocation })) return;
		}
		restoreScroll({
			storageKey,
			key: cacheKey,
			behavior: router.options.scrollRestorationBehavior,
			shouldScrollRestoration: router.isScrollRestoring,
			scrollToTopSelectors: router.options.scrollToTopSelectors,
			location: router.history.location
		});
		if (router.isScrollRestoring) scrollRestorationCache.set((state) => {
			state[cacheKey] ||= {};
			return state;
		});
	});
}
function handleHashScroll(router) {
	if (typeof document !== "undefined" && document.querySelector) {
		const hashScrollIntoViewOptions = router.state.location.state.__hashScrollIntoViewOptions ?? true;
		if (hashScrollIntoViewOptions && router.state.location.hash !== "") {
			const el = document.getElementById(router.state.location.hash);
			if (el) el.scrollIntoView(hashScrollIntoViewOptions);
		}
	}
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/qss.js
function encode(obj, stringify = String) {
	const result = new URLSearchParams();
	for (const key in obj) {
		const val = obj[key];
		if (val !== void 0) result.set(key, stringify(val));
	}
	return result.toString();
}
function toValue(str) {
	if (!str) return "";
	if (str === "false") return false;
	if (str === "true") return true;
	return +str * 0 === 0 && +str + "" === str ? +str : str;
}
function decode(str) {
	const searchParams = new URLSearchParams(str);
	const result = {};
	for (const [key, value] of searchParams.entries()) {
		const previousValue = result[key];
		if (previousValue == null) result[key] = toValue(value);
		else if (Array.isArray(previousValue)) previousValue.push(toValue(value));
		else result[key] = [previousValue, toValue(value)];
	}
	return result;
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/searchParams.js
var defaultParseSearch = parseSearchWith(JSON.parse);
var defaultStringifySearch = stringifySearchWith(JSON.stringify, JSON.parse);
function parseSearchWith(parser) {
	return (searchStr) => {
		if (searchStr[0] === "?") searchStr = searchStr.substring(1);
		const query = decode(searchStr);
		for (const key in query) {
			const value = query[key];
			if (typeof value === "string") try {
				query[key] = parser(value);
			} catch (_err) {}
		}
		return query;
	};
}
function stringifySearchWith(stringify, parser) {
	const hasParser = typeof parser === "function";
	function stringifyValue(val) {
		if (typeof val === "object" && val !== null) try {
			return stringify(val);
		} catch (_err) {}
		else if (hasParser && typeof val === "string") try {
			parser(val);
			return stringify(val);
		} catch (_err) {}
		return val;
	}
	return (search) => {
		const searchStr = encode(search, stringifyValue);
		return searchStr ? `?${searchStr}` : "";
	};
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/redirect.js
function redirect(opts) {
	opts.statusCode = opts.statusCode || opts.code || 307;
	if (!opts.reloadDocument && typeof opts.href === "string") try {
		new URL(opts.href);
		opts.reloadDocument = true;
	} catch {}
	const headers = new Headers(opts.headers);
	if (opts.href && headers.get("Location") === null) headers.set("Location", opts.href);
	const response = new Response(null, {
		status: opts.statusCode,
		headers
	});
	response.options = opts;
	if (opts.throw) throw response;
	return response;
}
function isRedirect(obj) {
	return obj instanceof Response && !!obj.options;
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/lru-cache.js
function createLRUCache(max) {
	const cache = /* @__PURE__ */ new Map();
	let oldest;
	let newest;
	const touch = (entry) => {
		if (!entry.next) return;
		if (!entry.prev) {
			entry.next.prev = void 0;
			oldest = entry.next;
			entry.next = void 0;
			if (newest) {
				entry.prev = newest;
				newest.next = entry;
			}
		} else {
			entry.prev.next = entry.next;
			entry.next.prev = entry.prev;
			entry.next = void 0;
			if (newest) {
				newest.next = entry;
				entry.prev = newest;
			}
		}
		newest = entry;
	};
	return {
		get(key) {
			const entry = cache.get(key);
			if (!entry) return void 0;
			touch(entry);
			return entry.value;
		},
		set(key, value) {
			if (cache.size >= max && oldest) {
				const toDelete = oldest;
				cache.delete(toDelete.key);
				if (toDelete.next) {
					oldest = toDelete.next;
					toDelete.next.prev = void 0;
				}
				if (toDelete === newest) newest = void 0;
			}
			const existing = cache.get(key);
			if (existing) {
				existing.value = value;
				touch(existing);
			} else {
				const entry = {
					key,
					value,
					prev: newest
				};
				if (newest) newest.next = entry;
				newest = entry;
				if (!oldest) oldest = entry;
				cache.set(key, entry);
			}
		}
	};
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/load-matches.js
var triggerOnReady = (inner) => {
	if (!inner.rendered) {
		inner.rendered = true;
		return inner.onReady?.();
	}
};
var resolvePreload = (inner, matchId) => {
	return !!(inner.preload && !inner.router.state.matches.some((d) => d.id === matchId));
};
var _handleNotFound = (inner, err) => {
	const routeCursor = inner.router.routesById[err.routeId ?? ""] ?? inner.router.routeTree;
	if (!routeCursor.options.notFoundComponent && inner.router.options?.defaultNotFoundComponent) routeCursor.options.notFoundComponent = inner.router.options.defaultNotFoundComponent;
	invariant(routeCursor.options.notFoundComponent, "No notFoundComponent found. Please set a notFoundComponent on your route or provide a defaultNotFoundComponent to the router.");
	const matchForRoute = inner.matches.find((m) => m.routeId === routeCursor.id);
	invariant(matchForRoute, "Could not find match for route: " + routeCursor.id);
	inner.updateMatch(matchForRoute.id, (prev) => ({
		...prev,
		status: "notFound",
		error: err,
		isFetching: false
	}));
	if (err.routerCode === "BEFORE_LOAD" && routeCursor.parentRoute) {
		err.routeId = routeCursor.parentRoute.id;
		_handleNotFound(inner, err);
	}
};
var handleRedirectAndNotFound = (inner, match, err) => {
	if (!isRedirect(err) && !isNotFound(err)) return;
	if (isRedirect(err) && err.redirectHandled && !err.options.reloadDocument) throw err;
	if (match) {
		match._nonReactive.beforeLoadPromise?.resolve();
		match._nonReactive.loaderPromise?.resolve();
		match._nonReactive.beforeLoadPromise = void 0;
		match._nonReactive.loaderPromise = void 0;
		const status = isRedirect(err) ? "redirected" : "notFound";
		inner.updateMatch(match.id, (prev) => ({
			...prev,
			status,
			isFetching: false,
			error: err
		}));
		if (isNotFound(err) && !err.routeId) err.routeId = match.routeId;
		match._nonReactive.loadPromise?.resolve();
	}
	if (isRedirect(err)) {
		inner.rendered = true;
		err.options._fromLocation = inner.location;
		err.redirectHandled = true;
		err = inner.router.resolveRedirect(err);
		throw err;
	} else {
		_handleNotFound(inner, err);
		throw err;
	}
};
var shouldSkipLoader = (inner, matchId) => {
	const match = inner.router.getMatch(matchId);
	if (!inner.router.isServer && match._nonReactive.dehydrated) return true;
	if (inner.router.isServer && match.ssr === false) return true;
	return false;
};
var handleSerialError = (inner, index, err, routerCode) => {
	const { id: matchId, routeId } = inner.matches[index];
	const route = inner.router.looseRoutesById[routeId];
	if (err instanceof Promise) throw err;
	err.routerCode = routerCode;
	inner.firstBadMatchIndex ??= index;
	handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err);
	try {
		route.options.onError?.(err);
	} catch (errorHandlerErr) {
		err = errorHandlerErr;
		handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err);
	}
	inner.updateMatch(matchId, (prev) => {
		prev._nonReactive.beforeLoadPromise?.resolve();
		prev._nonReactive.beforeLoadPromise = void 0;
		prev._nonReactive.loadPromise?.resolve();
		return {
			...prev,
			error: err,
			status: "error",
			isFetching: false,
			updatedAt: Date.now(),
			abortController: new AbortController()
		};
	});
};
var isBeforeLoadSsr = (inner, matchId, index, route) => {
	const existingMatch = inner.router.getMatch(matchId);
	const parentMatchId = inner.matches[index - 1]?.id;
	const parentMatch = parentMatchId ? inner.router.getMatch(parentMatchId) : void 0;
	if (inner.router.isShell()) {
		existingMatch.ssr = matchId === rootRouteId;
		return;
	}
	if (parentMatch?.ssr === false) {
		existingMatch.ssr = false;
		return;
	}
	const parentOverride = (tempSsr2) => {
		if (tempSsr2 === true && parentMatch?.ssr === "data-only") return "data-only";
		return tempSsr2;
	};
	const defaultSsr = inner.router.options.defaultSsr ?? true;
	if (route.options.ssr === void 0) {
		existingMatch.ssr = parentOverride(defaultSsr);
		return;
	}
	if (typeof route.options.ssr !== "function") {
		existingMatch.ssr = parentOverride(route.options.ssr);
		return;
	}
	const { search, params } = existingMatch;
	const ssrFnContext = {
		search: makeMaybe(search, existingMatch.searchError),
		params: makeMaybe(params, existingMatch.paramsError),
		location: inner.location,
		matches: inner.matches.map((match) => ({
			index: match.index,
			pathname: match.pathname,
			fullPath: match.fullPath,
			staticData: match.staticData,
			id: match.id,
			routeId: match.routeId,
			search: makeMaybe(match.search, match.searchError),
			params: makeMaybe(match.params, match.paramsError),
			ssr: match.ssr
		}))
	};
	const tempSsr = route.options.ssr(ssrFnContext);
	if (isPromise(tempSsr)) return tempSsr.then((ssr) => {
		existingMatch.ssr = parentOverride(ssr ?? defaultSsr);
	});
	existingMatch.ssr = parentOverride(tempSsr ?? defaultSsr);
};
var setupPendingTimeout = (inner, matchId, route, match) => {
	if (match._nonReactive.pendingTimeout !== void 0) return;
	const pendingMs = route.options.pendingMs ?? inner.router.options.defaultPendingMs;
	if (!!(inner.onReady && !inner.router.isServer && !resolvePreload(inner, matchId) && (route.options.loader || route.options.beforeLoad || routeNeedsPreload(route)) && typeof pendingMs === "number" && pendingMs !== Infinity && (route.options.pendingComponent ?? inner.router.options?.defaultPendingComponent))) {
		const pendingTimeout = setTimeout(() => {
			triggerOnReady(inner);
		}, pendingMs);
		match._nonReactive.pendingTimeout = pendingTimeout;
	}
};
var preBeforeLoadSetup = (inner, matchId, route) => {
	const existingMatch = inner.router.getMatch(matchId);
	if (!existingMatch._nonReactive.beforeLoadPromise && !existingMatch._nonReactive.loaderPromise) return;
	setupPendingTimeout(inner, matchId, route, existingMatch);
	const then = () => {
		const match = inner.router.getMatch(matchId);
		if (match.preload && (match.status === "redirected" || match.status === "notFound")) handleRedirectAndNotFound(inner, match, match.error);
	};
	return existingMatch._nonReactive.beforeLoadPromise ? existingMatch._nonReactive.beforeLoadPromise.then(then) : then();
};
var executeBeforeLoad = (inner, matchId, index, route) => {
	const match = inner.router.getMatch(matchId);
	const prevLoadPromise = match._nonReactive.loadPromise;
	match._nonReactive.loadPromise = createControlledPromise(() => {
		prevLoadPromise?.resolve();
	});
	const { paramsError, searchError } = match;
	if (paramsError) handleSerialError(inner, index, paramsError, "PARSE_PARAMS");
	if (searchError) handleSerialError(inner, index, searchError, "VALIDATE_SEARCH");
	setupPendingTimeout(inner, matchId, route, match);
	const abortController = new AbortController();
	const parentMatchId = inner.matches[index - 1]?.id;
	const context = {
		...(parentMatchId ? inner.router.getMatch(parentMatchId) : void 0)?.context ?? inner.router.options.context ?? void 0,
		...match.__routeContext
	};
	let isPending = false;
	const pending = () => {
		if (isPending) return;
		isPending = true;
		inner.updateMatch(matchId, (prev) => ({
			...prev,
			isFetching: "beforeLoad",
			fetchCount: prev.fetchCount + 1,
			abortController,
			context
		}));
	};
	const resolve = () => {
		match._nonReactive.beforeLoadPromise?.resolve();
		match._nonReactive.beforeLoadPromise = void 0;
		inner.updateMatch(matchId, (prev) => ({
			...prev,
			isFetching: false
		}));
	};
	if (!route.options.beforeLoad) {
		batch(() => {
			pending();
			resolve();
		});
		return;
	}
	match._nonReactive.beforeLoadPromise = createControlledPromise();
	const { search, params, cause } = match;
	const preload = resolvePreload(inner, matchId);
	const beforeLoadFnContext = {
		search,
		abortController,
		params,
		preload,
		context,
		location: inner.location,
		navigate: (opts) => inner.router.navigate({
			...opts,
			_fromLocation: inner.location
		}),
		buildLocation: inner.router.buildLocation,
		cause: preload ? "preload" : cause,
		matches: inner.matches,
		...inner.router.options.additionalContext
	};
	const updateContext = (beforeLoadContext2) => {
		if (beforeLoadContext2 === void 0) {
			batch(() => {
				pending();
				resolve();
			});
			return;
		}
		if (isRedirect(beforeLoadContext2) || isNotFound(beforeLoadContext2)) {
			pending();
			handleSerialError(inner, index, beforeLoadContext2, "BEFORE_LOAD");
		}
		batch(() => {
			pending();
			inner.updateMatch(matchId, (prev) => ({
				...prev,
				__beforeLoadContext: beforeLoadContext2,
				context: {
					...prev.context,
					...beforeLoadContext2
				}
			}));
			resolve();
		});
	};
	let beforeLoadContext;
	try {
		beforeLoadContext = route.options.beforeLoad(beforeLoadFnContext);
		if (isPromise(beforeLoadContext)) {
			pending();
			return beforeLoadContext.catch((err) => {
				handleSerialError(inner, index, err, "BEFORE_LOAD");
			}).then(updateContext);
		}
	} catch (err) {
		pending();
		handleSerialError(inner, index, err, "BEFORE_LOAD");
	}
	updateContext(beforeLoadContext);
};
var handleBeforeLoad = (inner, index) => {
	const { id: matchId, routeId } = inner.matches[index];
	const route = inner.router.looseRoutesById[routeId];
	const serverSsr = () => {
		if (inner.router.isServer) {
			const maybePromise = isBeforeLoadSsr(inner, matchId, index, route);
			if (isPromise(maybePromise)) return maybePromise.then(queueExecution);
		}
		return queueExecution();
	};
	const execute = () => executeBeforeLoad(inner, matchId, index, route);
	const queueExecution = () => {
		if (shouldSkipLoader(inner, matchId)) return;
		const result = preBeforeLoadSetup(inner, matchId, route);
		return isPromise(result) ? result.then(execute) : execute();
	};
	return serverSsr();
};
var executeHead = (inner, matchId, route) => {
	const match = inner.router.getMatch(matchId);
	if (!match) return;
	if (!route.options.head && !route.options.scripts && !route.options.headers) return;
	const assetContext = {
		matches: inner.matches,
		match,
		params: match.params,
		loaderData: match.loaderData
	};
	return Promise.all([
		route.options.head?.(assetContext),
		route.options.scripts?.(assetContext),
		route.options.headers?.(assetContext)
	]).then(([headFnContent, scripts, headers]) => {
		return {
			meta: headFnContent?.meta,
			links: headFnContent?.links,
			headScripts: headFnContent?.scripts,
			headers,
			scripts,
			styles: headFnContent?.styles
		};
	});
};
var getLoaderContext = (inner, matchId, index, route) => {
	const parentMatchPromise = inner.matchPromises[index - 1];
	const { params, loaderDeps, abortController, context, cause } = inner.router.getMatch(matchId);
	const preload = resolvePreload(inner, matchId);
	return {
		params,
		deps: loaderDeps,
		preload: !!preload,
		parentMatchPromise,
		abortController,
		context,
		location: inner.location,
		navigate: (opts) => inner.router.navigate({
			...opts,
			_fromLocation: inner.location
		}),
		cause: preload ? "preload" : cause,
		route,
		...inner.router.options.additionalContext
	};
};
var runLoader = async (inner, matchId, index, route) => {
	try {
		const match = inner.router.getMatch(matchId);
		try {
			if (!inner.router.isServer || match.ssr === true) loadRouteChunk(route);
			const loaderResult = route.options.loader?.(getLoaderContext(inner, matchId, index, route));
			const loaderResultIsPromise = route.options.loader && isPromise(loaderResult);
			if (!!(loaderResultIsPromise || route._lazyPromise || route._componentsPromise || route.options.head || route.options.scripts || route.options.headers || match._nonReactive.minPendingPromise)) inner.updateMatch(matchId, (prev) => ({
				...prev,
				isFetching: "loader"
			}));
			if (route.options.loader) {
				const loaderData = loaderResultIsPromise ? await loaderResult : loaderResult;
				handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), loaderData);
				if (loaderData !== void 0) inner.updateMatch(matchId, (prev) => ({
					...prev,
					loaderData
				}));
			}
			if (route._lazyPromise) await route._lazyPromise;
			const headResult = executeHead(inner, matchId, route);
			const head = headResult ? await headResult : void 0;
			const pendingPromise = match._nonReactive.minPendingPromise;
			if (pendingPromise) await pendingPromise;
			if (route._componentsPromise) await route._componentsPromise;
			inner.updateMatch(matchId, (prev) => ({
				...prev,
				error: void 0,
				status: "success",
				isFetching: false,
				updatedAt: Date.now(),
				...head
			}));
		} catch (e) {
			let error = e;
			const pendingPromise = match._nonReactive.minPendingPromise;
			if (pendingPromise) await pendingPromise;
			if (isNotFound(e)) await route.options.notFoundComponent?.preload?.();
			handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), e);
			try {
				route.options.onError?.(e);
			} catch (onErrorError) {
				error = onErrorError;
				handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), onErrorError);
			}
			const headResult = executeHead(inner, matchId, route);
			const head = headResult ? await headResult : void 0;
			inner.updateMatch(matchId, (prev) => ({
				...prev,
				error,
				status: "error",
				isFetching: false,
				...head
			}));
		}
	} catch (err) {
		const match = inner.router.getMatch(matchId);
		if (match) {
			const headResult = executeHead(inner, matchId, route);
			if (headResult) {
				const head = await headResult;
				inner.updateMatch(matchId, (prev) => ({
					...prev,
					...head
				}));
			}
			match._nonReactive.loaderPromise = void 0;
		}
		handleRedirectAndNotFound(inner, match, err);
	}
};
var loadRouteMatch = async (inner, index) => {
	const { id: matchId, routeId } = inner.matches[index];
	let loaderShouldRunAsync = false;
	let loaderIsRunningAsync = false;
	const route = inner.router.looseRoutesById[routeId];
	if (shouldSkipLoader(inner, matchId)) {
		if (inner.router.isServer) {
			const headResult = executeHead(inner, matchId, route);
			if (headResult) {
				const head = await headResult;
				inner.updateMatch(matchId, (prev) => ({
					...prev,
					...head
				}));
			}
			return inner.router.getMatch(matchId);
		}
	} else {
		const prevMatch = inner.router.getMatch(matchId);
		if (prevMatch._nonReactive.loaderPromise) {
			if (prevMatch.status === "success" && !inner.sync && !prevMatch.preload) return prevMatch;
			await prevMatch._nonReactive.loaderPromise;
			const match2 = inner.router.getMatch(matchId);
			if (match2.error) handleRedirectAndNotFound(inner, match2, match2.error);
		} else {
			const age = Date.now() - prevMatch.updatedAt;
			const preload = resolvePreload(inner, matchId);
			const staleAge = preload ? route.options.preloadStaleTime ?? inner.router.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? inner.router.options.defaultStaleTime ?? 0;
			const shouldReloadOption = route.options.shouldReload;
			const shouldReload = typeof shouldReloadOption === "function" ? shouldReloadOption(getLoaderContext(inner, matchId, index, route)) : shouldReloadOption;
			const nextPreload = !!preload && !inner.router.state.matches.some((d) => d.id === matchId);
			const match2 = inner.router.getMatch(matchId);
			match2._nonReactive.loaderPromise = createControlledPromise();
			if (nextPreload !== match2.preload) inner.updateMatch(matchId, (prev) => ({
				...prev,
				preload: nextPreload
			}));
			const { status, invalid } = match2;
			loaderShouldRunAsync = status === "success" && (invalid || (shouldReload ?? age > staleAge));
			if (preload && route.options.preload === false);
			else if (loaderShouldRunAsync && !inner.sync) {
				loaderIsRunningAsync = true;
				(async () => {
					try {
						await runLoader(inner, matchId, index, route);
						const match3 = inner.router.getMatch(matchId);
						match3._nonReactive.loaderPromise?.resolve();
						match3._nonReactive.loadPromise?.resolve();
						match3._nonReactive.loaderPromise = void 0;
					} catch (err) {
						if (isRedirect(err)) await inner.router.navigate(err.options);
					}
				})();
			} else if (status !== "success" || loaderShouldRunAsync && inner.sync) await runLoader(inner, matchId, index, route);
			else {
				const headResult = executeHead(inner, matchId, route);
				if (headResult) {
					const head = await headResult;
					inner.updateMatch(matchId, (prev) => ({
						...prev,
						...head
					}));
				}
			}
		}
	}
	const match = inner.router.getMatch(matchId);
	if (!loaderIsRunningAsync) {
		match._nonReactive.loaderPromise?.resolve();
		match._nonReactive.loadPromise?.resolve();
	}
	clearTimeout(match._nonReactive.pendingTimeout);
	match._nonReactive.pendingTimeout = void 0;
	if (!loaderIsRunningAsync) match._nonReactive.loaderPromise = void 0;
	match._nonReactive.dehydrated = void 0;
	const nextIsFetching = loaderIsRunningAsync ? match.isFetching : false;
	if (nextIsFetching !== match.isFetching || match.invalid !== false) {
		inner.updateMatch(matchId, (prev) => ({
			...prev,
			isFetching: nextIsFetching,
			invalid: false
		}));
		return inner.router.getMatch(matchId);
	} else return match;
};
async function loadMatches(arg) {
	const inner = Object.assign(arg, { matchPromises: [] });
	if (!inner.router.isServer && inner.router.state.matches.some((d) => d._forcePending)) triggerOnReady(inner);
	try {
		for (let i = 0; i < inner.matches.length; i++) {
			const beforeLoad = handleBeforeLoad(inner, i);
			if (isPromise(beforeLoad)) await beforeLoad;
		}
		const max = inner.firstBadMatchIndex ?? inner.matches.length;
		for (let i = 0; i < max; i++) inner.matchPromises.push(loadRouteMatch(inner, i));
		await Promise.all(inner.matchPromises);
		const readyPromise = triggerOnReady(inner);
		if (isPromise(readyPromise)) await readyPromise;
	} catch (err) {
		if (isNotFound(err) && !inner.preload) {
			const readyPromise = triggerOnReady(inner);
			if (isPromise(readyPromise)) await readyPromise;
			throw err;
		}
		if (isRedirect(err)) throw err;
	}
	return inner.matches;
}
async function loadRouteChunk(route) {
	if (!route._lazyLoaded && route._lazyPromise === void 0) if (route.lazyFn) route._lazyPromise = route.lazyFn().then((lazyRoute) => {
		const { id: _id,...options } = lazyRoute.options;
		Object.assign(route.options, options);
		route._lazyLoaded = true;
		route._lazyPromise = void 0;
	});
	else route._lazyLoaded = true;
	if (!route._componentsLoaded && route._componentsPromise === void 0) {
		const loadComponents = () => {
			const preloads = [];
			for (const type of componentTypes) {
				const preload = route.options[type]?.preload;
				if (preload) preloads.push(preload());
			}
			if (preloads.length) return Promise.all(preloads).then(() => {
				route._componentsLoaded = true;
				route._componentsPromise = void 0;
			});
			route._componentsLoaded = true;
			route._componentsPromise = void 0;
		};
		route._componentsPromise = route._lazyPromise ? route._lazyPromise.then(loadComponents) : loadComponents();
	}
	return route._componentsPromise;
}
function makeMaybe(value, error) {
	if (error) return {
		status: "error",
		error
	};
	return {
		status: "success",
		value
	};
}
function routeNeedsPreload(route) {
	for (const componentType of componentTypes) if (route.options[componentType]?.preload) return true;
	return false;
}
var componentTypes = [
	"component",
	"errorComponent",
	"pendingComponent",
	"notFoundComponent"
];

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/rewrite.js
function composeRewrites(rewrites) {
	return {
		input: ({ url }) => {
			for (const rewrite of rewrites) url = executeRewriteInput(rewrite, url);
			return url;
		},
		output: ({ url }) => {
			for (let i = rewrites.length - 1; i >= 0; i--) url = executeRewriteOutput(rewrites[i], url);
			return url;
		}
	};
}
function rewriteBasepath(opts) {
	const trimmedBasepath = trimPath(opts.basepath);
	const normalizedBasepath = `/${trimmedBasepath}`;
	const normalizedBasepathWithSlash = `${normalizedBasepath}/`;
	const checkBasepath = opts.caseSensitive ? normalizedBasepath : normalizedBasepath.toLowerCase();
	const checkBasepathWithSlash = opts.caseSensitive ? normalizedBasepathWithSlash : normalizedBasepathWithSlash.toLowerCase();
	return {
		input: ({ url }) => {
			const pathname = opts.caseSensitive ? url.pathname : url.pathname.toLowerCase();
			if (pathname === checkBasepath) url.pathname = "/";
			else if (pathname.startsWith(checkBasepathWithSlash)) url.pathname = url.pathname.slice(normalizedBasepath.length);
			return url;
		},
		output: ({ url }) => {
			url.pathname = joinPaths([
				"/",
				trimmedBasepath,
				url.pathname
			]);
			return url;
		}
	};
}
function executeRewriteInput(rewrite, url) {
	const res = rewrite?.input?.({ url });
	if (res) {
		if (typeof res === "string") return new URL(res);
		else if (res instanceof URL) return res;
	}
	return url;
}
function executeRewriteOutput(rewrite, url) {
	const res = rewrite?.output?.({ url });
	if (res) {
		if (typeof res === "string") return new URL(res);
		else if (res instanceof URL) return res;
	}
	return url;
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/router.js
function defaultSerializeError(err) {
	if (err instanceof Error) {
		const obj = {
			name: err.name,
			message: err.message
		};
		obj.stack = err.stack;
		return obj;
	}
	return { data: err };
}
function getLocationChangeInfo(routerState) {
	const fromLocation = routerState.resolvedLocation;
	const toLocation = routerState.location;
	return {
		fromLocation,
		toLocation,
		pathChanged: fromLocation?.pathname !== toLocation.pathname,
		hrefChanged: fromLocation?.href !== toLocation.href,
		hashChanged: fromLocation?.hash !== toLocation.hash
	};
}
var RouterCore = class {
	/**
	* @deprecated Use the `createRouter` function instead
	*/
	constructor(options) {
		this.tempLocationKey = `${Math.round(Math.random() * 1e7)}`;
		this.resetNextScroll = true;
		this.shouldViewTransition = void 0;
		this.isViewTransitionTypesSupported = void 0;
		this.subscribers = /* @__PURE__ */ new Set();
		this.isScrollRestoring = false;
		this.isScrollRestorationSetup = false;
		this.startTransition = (fn) => fn();
		this.update = (newOptions) => {
			if (newOptions.notFoundRoute) console.warn("The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.");
			const prevOptions = this.options;
			const prevBasepath = this.basepath ?? prevOptions?.basepath ?? "/";
			const basepathWasUnset = this.basepath === void 0;
			const prevRewriteOption = prevOptions?.rewrite;
			this.options = {
				...prevOptions,
				...newOptions
			};
			this.isServer = this.options.isServer ?? typeof document === "undefined";
			this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters ? new Map(this.options.pathParamsAllowedCharacters.map((char) => [encodeURIComponent(char), char])) : void 0;
			if (!this.history || this.options.history && this.options.history !== this.history) if (!this.options.history) {
				if (!this.isServer) this.history = createBrowserHistory();
			} else this.history = this.options.history;
			this.origin = this.options.origin;
			if (!this.origin) if (!this.isServer && window?.origin && window.origin !== "null") this.origin = window.origin;
			else this.origin = "http://localhost";
			if (this.history) this.updateLatestLocation();
			if (this.options.routeTree !== this.routeTree) {
				this.routeTree = this.options.routeTree;
				this.buildRouteTree();
			}
			if (!this.__store && this.latestLocation) {
				this.__store = new Store(getInitialRouterState(this.latestLocation), { onUpdate: () => {
					this.__store.state = {
						...this.state,
						cachedMatches: this.state.cachedMatches.filter((d) => !["redirected"].includes(d.status))
					};
				} });
				setupScrollRestoration(this);
			}
			let needsLocationUpdate = false;
			const nextBasepath = this.options.basepath ?? "/";
			const nextRewriteOption = this.options.rewrite;
			if (basepathWasUnset || prevBasepath !== nextBasepath || prevRewriteOption !== nextRewriteOption) {
				this.basepath = nextBasepath;
				const rewrites = [];
				if (trimPath(nextBasepath) !== "") rewrites.push(rewriteBasepath({ basepath: nextBasepath }));
				if (nextRewriteOption) rewrites.push(nextRewriteOption);
				this.rewrite = rewrites.length === 0 ? void 0 : rewrites.length === 1 ? rewrites[0] : composeRewrites(rewrites);
				if (this.history) this.updateLatestLocation();
				needsLocationUpdate = true;
			}
			if (needsLocationUpdate && this.__store) this.__store.state = {
				...this.state,
				location: this.latestLocation
			};
			if (typeof window !== "undefined" && "CSS" in window && typeof window.CSS?.supports === "function") this.isViewTransitionTypesSupported = window.CSS.supports("selector(:active-view-transition-type(a)");
		};
		this.updateLatestLocation = () => {
			this.latestLocation = this.parseLocation(this.history.location, this.latestLocation);
		};
		this.buildRouteTree = () => {
			const { routesById, routesByPath, flatRoutes } = processRouteTree({
				routeTree: this.routeTree,
				initRoute: (route, i) => {
					route.init({ originalIndex: i });
				}
			});
			this.routesById = routesById;
			this.routesByPath = routesByPath;
			this.flatRoutes = flatRoutes;
			const notFoundRoute = this.options.notFoundRoute;
			if (notFoundRoute) {
				notFoundRoute.init({ originalIndex: 99999999999 });
				this.routesById[notFoundRoute.id] = notFoundRoute;
			}
		};
		this.subscribe = (eventType, fn) => {
			const listener = {
				eventType,
				fn
			};
			this.subscribers.add(listener);
			return () => {
				this.subscribers.delete(listener);
			};
		};
		this.emit = (routerEvent) => {
			this.subscribers.forEach((listener) => {
				if (listener.eventType === routerEvent.type) listener.fn(routerEvent);
			});
		};
		this.parseLocation = (locationToParse, previousLocation) => {
			const parse = ({ href, state }) => {
				const fullUrl = new URL(href, this.origin);
				const url = executeRewriteInput(this.rewrite, fullUrl);
				const parsedSearch = this.options.parseSearch(url.search);
				const searchStr = this.options.stringifySearch(parsedSearch);
				url.search = searchStr;
				const fullPath = url.href.replace(url.origin, "");
				const { pathname, hash } = url;
				return {
					href: fullPath,
					publicHref: href,
					url: url.href,
					pathname,
					searchStr,
					search: replaceEqualDeep(previousLocation?.search, parsedSearch),
					hash: hash.split("#").reverse()[0] ?? "",
					state: replaceEqualDeep(previousLocation?.state, state)
				};
			};
			const location = parse(locationToParse);
			const { __tempLocation, __tempKey } = location.state;
			if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
				const parsedTempLocation = parse(__tempLocation);
				parsedTempLocation.state.key = location.state.key;
				parsedTempLocation.state.__TSR_key = location.state.__TSR_key;
				delete parsedTempLocation.state.__tempLocation;
				return {
					...parsedTempLocation,
					maskedLocation: location
				};
			}
			return location;
		};
		this.resolvePathWithBase = (from, path) => {
			return resolvePath({
				base: from,
				to: cleanPath(path),
				trailingSlash: this.options.trailingSlash,
				parseCache: this.parsePathnameCache
			});
		};
		this.matchRoutes = (pathnameOrNext, locationSearchOrOpts, opts) => {
			if (typeof pathnameOrNext === "string") return this.matchRoutesInternal({
				pathname: pathnameOrNext,
				search: locationSearchOrOpts
			}, opts);
			return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts);
		};
		this.parsePathnameCache = createLRUCache(1e3);
		this.getMatchedRoutes = (pathname, routePathname) => {
			return getMatchedRoutes({
				pathname,
				routePathname,
				caseSensitive: this.options.caseSensitive,
				routesByPath: this.routesByPath,
				routesById: this.routesById,
				flatRoutes: this.flatRoutes,
				parseCache: this.parsePathnameCache
			});
		};
		this.cancelMatch = (id) => {
			const match = this.getMatch(id);
			if (!match) return;
			match.abortController.abort();
			clearTimeout(match._nonReactive.pendingTimeout);
			match._nonReactive.pendingTimeout = void 0;
		};
		this.cancelMatches = () => {
			this.state.pendingMatches?.forEach((match) => {
				this.cancelMatch(match.id);
			});
		};
		this.buildLocation = (opts) => {
			const build = (dest = {}) => {
				const currentLocation = dest._fromLocation || this.latestLocation;
				const allCurrentLocationMatches = this.matchRoutes(currentLocation, { _buildLocation: true });
				const lastMatch = last(allCurrentLocationMatches);
				if (dest.from && dest._isNavigate) {
					const allFromMatches = this.getMatchedRoutes(dest.from, void 0).matchedRoutes;
					const matchedFrom = findLast(allCurrentLocationMatches, (d) => {
						return comparePaths(d.fullPath, dest.from);
					});
					const matchedCurrent = findLast(allFromMatches, (d) => {
						return comparePaths(d.fullPath, lastMatch.fullPath);
					});
					if (!matchedFrom && !matchedCurrent) console.warn(`Could not find match for from: ${dest.from}`);
				}
				const defaultedFromPath = dest.unsafeRelative === "path" ? currentLocation.pathname : dest.from ?? lastMatch.fullPath;
				const fromPath = this.resolvePathWithBase(defaultedFromPath, ".");
				const fromSearch = lastMatch.search;
				const fromParams = { ...lastMatch.params };
				const nextTo = dest.to ? this.resolvePathWithBase(fromPath, `${dest.to}`) : this.resolvePathWithBase(fromPath, ".");
				const nextParams = dest.params === false || dest.params === null ? {} : (dest.params ?? true) === true ? fromParams : Object.assign(fromParams, functionalUpdate(dest.params, fromParams));
				const interpolatedNextTo = interpolatePath({
					path: nextTo,
					params: nextParams,
					parseCache: this.parsePathnameCache
				}).interpolatedPath;
				const destRoutes = this.matchRoutes(interpolatedNextTo, void 0, { _buildLocation: true }).map((d) => this.looseRoutesById[d.routeId]);
				if (Object.keys(nextParams).length > 0) for (const route of destRoutes) {
					const fn = route.options.params?.stringify ?? route.options.stringifyParams;
					if (fn) Object.assign(nextParams, fn(nextParams));
				}
				const nextPathname = interpolatePath({
					path: nextTo,
					params: nextParams,
					leaveWildcards: false,
					leaveParams: opts.leaveParams,
					decodeCharMap: this.pathParamsDecodeCharMap,
					parseCache: this.parsePathnameCache
				}).interpolatedPath;
				let nextSearch = fromSearch;
				if (opts._includeValidateSearch && this.options.search?.strict) {
					const validatedSearch = {};
					destRoutes.forEach((route) => {
						if (route.options.validateSearch) try {
							Object.assign(validatedSearch, validateSearch(route.options.validateSearch, {
								...validatedSearch,
								...nextSearch
							}));
						} catch {}
					});
					nextSearch = validatedSearch;
				}
				nextSearch = applySearchMiddleware({
					search: nextSearch,
					dest,
					destRoutes,
					_includeValidateSearch: opts._includeValidateSearch
				});
				nextSearch = replaceEqualDeep(fromSearch, nextSearch);
				const searchStr = this.options.stringifySearch(nextSearch);
				const hash = dest.hash === true ? currentLocation.hash : dest.hash ? functionalUpdate(dest.hash, currentLocation.hash) : void 0;
				const hashStr = hash ? `#${hash}` : "";
				let nextState = dest.state === true ? currentLocation.state : dest.state ? functionalUpdate(dest.state, currentLocation.state) : {};
				nextState = replaceEqualDeep(currentLocation.state, nextState);
				const fullPath = `${nextPathname}${searchStr}${hashStr}`;
				const url = new URL(fullPath, this.origin);
				const rewrittenUrl = executeRewriteOutput(this.rewrite, url);
				return {
					publicHref: rewrittenUrl.pathname + rewrittenUrl.search + rewrittenUrl.hash,
					href: fullPath,
					url: rewrittenUrl.href,
					pathname: nextPathname,
					search: nextSearch,
					searchStr,
					state: nextState,
					hash: hash ?? "",
					unmaskOnReload: dest.unmaskOnReload
				};
			};
			const buildWithMatches = (dest = {}, maskedDest) => {
				const next = build(dest);
				let maskedNext = maskedDest ? build(maskedDest) : void 0;
				if (!maskedNext) {
					let params = {};
					const foundMask = this.options.routeMasks?.find((d) => {
						const match = matchPathname(next.pathname, {
							to: d.from,
							caseSensitive: false,
							fuzzy: false
						}, this.parsePathnameCache);
						if (match) {
							params = match;
							return true;
						}
						return false;
					});
					if (foundMask) {
						const { from: _from,...maskProps } = foundMask;
						maskedDest = {
							from: opts.from,
							...maskProps,
							params
						};
						maskedNext = build(maskedDest);
					}
				}
				if (maskedNext) next.maskedLocation = maskedNext;
				return next;
			};
			if (opts.mask) return buildWithMatches(opts, {
				from: opts.from,
				...opts.mask
			});
			return buildWithMatches(opts);
		};
		this.commitLocation = ({ viewTransition, ignoreBlocker,...next }) => {
			const isSameState = () => {
				const ignoredProps = [
					"key",
					"__TSR_key",
					"__TSR_index",
					"__hashScrollIntoViewOptions"
				];
				ignoredProps.forEach((prop) => {
					next.state[prop] = this.latestLocation.state[prop];
				});
				const isEqual = deepEqual(next.state, this.latestLocation.state);
				ignoredProps.forEach((prop) => {
					delete next.state[prop];
				});
				return isEqual;
			};
			const isSameUrl = trimPathRight(this.latestLocation.href) === trimPathRight(next.href);
			const previousCommitPromise = this.commitLocationPromise;
			this.commitLocationPromise = createControlledPromise(() => {
				previousCommitPromise?.resolve();
			});
			if (isSameUrl && isSameState()) this.load();
			else {
				let { maskedLocation, hashScrollIntoView,...nextHistory } = next;
				if (maskedLocation) {
					nextHistory = {
						...maskedLocation,
						state: {
							...maskedLocation.state,
							__tempKey: void 0,
							__tempLocation: {
								...nextHistory,
								search: nextHistory.searchStr,
								state: {
									...nextHistory.state,
									__tempKey: void 0,
									__tempLocation: void 0,
									__TSR_key: void 0,
									key: void 0
								}
							}
						}
					};
					if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) nextHistory.state.__tempKey = this.tempLocationKey;
				}
				nextHistory.state.__hashScrollIntoViewOptions = hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true;
				this.shouldViewTransition = viewTransition;
				this.history[next.replace ? "replace" : "push"](nextHistory.publicHref, nextHistory.state, { ignoreBlocker });
			}
			this.resetNextScroll = next.resetScroll ?? true;
			if (!this.history.subscribers.size) this.load();
			return this.commitLocationPromise;
		};
		this.buildAndCommitLocation = ({ replace, resetScroll, hashScrollIntoView, viewTransition, ignoreBlocker, href,...rest } = {}) => {
			if (href) {
				const currentIndex = this.history.location.state.__TSR_index;
				const parsed = parseHref(href, { __TSR_index: replace ? currentIndex : currentIndex + 1 });
				rest.to = parsed.pathname;
				rest.search = this.options.parseSearch(parsed.search);
				rest.hash = parsed.hash.slice(1);
			}
			const location = this.buildLocation({
				...rest,
				_includeValidateSearch: true
			});
			return this.commitLocation({
				...location,
				viewTransition,
				replace,
				resetScroll,
				hashScrollIntoView,
				ignoreBlocker
			});
		};
		this.navigate = ({ to, reloadDocument, href,...rest }) => {
			if (!reloadDocument && href) try {
				new URL(`${href}`);
				reloadDocument = true;
			} catch {}
			if (reloadDocument) {
				if (!href) href = this.buildLocation({
					to,
					...rest
				}).url;
				if (rest.replace) window.location.replace(href);
				else window.location.href = href;
				return Promise.resolve();
			}
			return this.buildAndCommitLocation({
				...rest,
				href,
				to,
				_isNavigate: true
			});
		};
		this.beforeLoad = () => {
			this.cancelMatches();
			this.updateLatestLocation();
			if (this.isServer) {
				const nextLocation = this.buildLocation({
					to: this.latestLocation.pathname,
					search: true,
					params: true,
					hash: true,
					state: true,
					_includeValidateSearch: true
				});
				const normalizeUrl = (url) => {
					try {
						return encodeURI(decodeURI(url));
					} catch {
						return url;
					}
				};
				if (trimPath(normalizeUrl(this.latestLocation.href)) !== trimPath(normalizeUrl(nextLocation.href))) {
					let href = nextLocation.url;
					if (this.origin && href.startsWith(this.origin)) href = href.replace(this.origin, "") || "/";
					throw redirect({ href });
				}
			}
			const pendingMatches = this.matchRoutes(this.latestLocation);
			this.__store.setState((s) => ({
				...s,
				status: "pending",
				statusCode: 200,
				isLoading: true,
				location: this.latestLocation,
				pendingMatches,
				cachedMatches: s.cachedMatches.filter((d) => !pendingMatches.some((e) => e.id === d.id))
			}));
		};
		this.load = async (opts) => {
			let redirect2;
			let notFound$1;
			let loadPromise;
			loadPromise = new Promise((resolve) => {
				this.startTransition(async () => {
					try {
						this.beforeLoad();
						const next = this.latestLocation;
						const prevLocation = this.state.resolvedLocation;
						if (!this.state.redirect) this.emit({
							type: "onBeforeNavigate",
							...getLocationChangeInfo({
								resolvedLocation: prevLocation,
								location: next
							})
						});
						this.emit({
							type: "onBeforeLoad",
							...getLocationChangeInfo({
								resolvedLocation: prevLocation,
								location: next
							})
						});
						await loadMatches({
							router: this,
							sync: opts?.sync,
							matches: this.state.pendingMatches,
							location: next,
							updateMatch: this.updateMatch,
							onReady: async () => {
								this.startViewTransition(async () => {
									let exitingMatches;
									let enteringMatches;
									let stayingMatches;
									batch(() => {
										this.__store.setState((s) => {
											const previousMatches = s.matches;
											const newMatches = s.pendingMatches || s.matches;
											exitingMatches = previousMatches.filter((match) => !newMatches.some((d) => d.id === match.id));
											enteringMatches = newMatches.filter((match) => !previousMatches.some((d) => d.id === match.id));
											stayingMatches = previousMatches.filter((match) => newMatches.some((d) => d.id === match.id));
											return {
												...s,
												isLoading: false,
												loadedAt: Date.now(),
												matches: newMatches,
												pendingMatches: void 0,
												cachedMatches: [...s.cachedMatches, ...exitingMatches.filter((d) => d.status !== "error")]
											};
										});
										this.clearExpiredCache();
									});
									[
										[exitingMatches, "onLeave"],
										[enteringMatches, "onEnter"],
										[stayingMatches, "onStay"]
									].forEach(([matches, hook]) => {
										matches.forEach((match) => {
											this.looseRoutesById[match.routeId].options[hook]?.(match);
										});
									});
								});
							}
						});
					} catch (err) {
						if (isRedirect(err)) {
							redirect2 = err;
							if (!this.isServer) this.navigate({
								...redirect2.options,
								replace: true,
								ignoreBlocker: true
							});
						} else if (isNotFound(err)) notFound$1 = err;
						this.__store.setState((s) => ({
							...s,
							statusCode: redirect2 ? redirect2.status : notFound$1 ? 404 : s.matches.some((d) => d.status === "error") ? 500 : 200,
							redirect: redirect2
						}));
					}
					if (this.latestLoadPromise === loadPromise) {
						this.commitLocationPromise?.resolve();
						this.latestLoadPromise = void 0;
						this.commitLocationPromise = void 0;
					}
					resolve();
				});
			});
			this.latestLoadPromise = loadPromise;
			await loadPromise;
			while (this.latestLoadPromise && loadPromise !== this.latestLoadPromise) await this.latestLoadPromise;
			let newStatusCode = void 0;
			if (this.hasNotFoundMatch()) newStatusCode = 404;
			else if (this.__store.state.matches.some((d) => d.status === "error")) newStatusCode = 500;
			if (newStatusCode !== void 0) this.__store.setState((s) => ({
				...s,
				statusCode: newStatusCode
			}));
		};
		this.startViewTransition = (fn) => {
			const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;
			delete this.shouldViewTransition;
			if (shouldViewTransition && typeof document !== "undefined" && "startViewTransition" in document && typeof document.startViewTransition === "function") {
				let startViewTransitionParams;
				if (typeof shouldViewTransition === "object" && this.isViewTransitionTypesSupported) {
					const next = this.latestLocation;
					const prevLocation = this.state.resolvedLocation;
					const resolvedViewTransitionTypes = typeof shouldViewTransition.types === "function" ? shouldViewTransition.types(getLocationChangeInfo({
						resolvedLocation: prevLocation,
						location: next
					})) : shouldViewTransition.types;
					if (resolvedViewTransitionTypes === false) {
						fn();
						return;
					}
					startViewTransitionParams = {
						update: fn,
						types: resolvedViewTransitionTypes
					};
				} else startViewTransitionParams = fn;
				document.startViewTransition(startViewTransitionParams);
			} else fn();
		};
		this.updateMatch = (id, updater) => {
			const matchesKey = this.state.pendingMatches?.some((d) => d.id === id) ? "pendingMatches" : this.state.matches.some((d) => d.id === id) ? "matches" : this.state.cachedMatches.some((d) => d.id === id) ? "cachedMatches" : "";
			if (matchesKey) this.__store.setState((s) => ({
				...s,
				[matchesKey]: s[matchesKey]?.map((d) => d.id === id ? updater(d) : d)
			}));
		};
		this.getMatch = (matchId) => {
			const findFn = (d) => d.id === matchId;
			return this.state.cachedMatches.find(findFn) ?? this.state.pendingMatches?.find(findFn) ?? this.state.matches.find(findFn);
		};
		this.invalidate = (opts) => {
			const invalidate = (d) => {
				if (opts?.filter?.(d) ?? true) return {
					...d,
					invalid: true,
					...opts?.forcePending || d.status === "error" ? {
						status: "pending",
						error: void 0
					} : void 0
				};
				return d;
			};
			this.__store.setState((s) => ({
				...s,
				matches: s.matches.map(invalidate),
				cachedMatches: s.cachedMatches.map(invalidate),
				pendingMatches: s.pendingMatches?.map(invalidate)
			}));
			this.shouldViewTransition = false;
			return this.load({ sync: opts?.sync });
		};
		this.resolveRedirect = (redirect2) => {
			if (!redirect2.options.href) {
				const location = this.buildLocation(redirect2.options);
				let href = location.url;
				if (this.origin && href.startsWith(this.origin)) href = href.replace(this.origin, "") || "/";
				redirect2.options.href = location.href;
				redirect2.headers.set("Location", href);
			}
			if (!redirect2.headers.get("Location")) redirect2.headers.set("Location", redirect2.options.href);
			return redirect2;
		};
		this.clearCache = (opts) => {
			const filter = opts?.filter;
			if (filter !== void 0) this.__store.setState((s) => {
				return {
					...s,
					cachedMatches: s.cachedMatches.filter((m) => !filter(m))
				};
			});
			else this.__store.setState((s) => {
				return {
					...s,
					cachedMatches: []
				};
			});
		};
		this.clearExpiredCache = () => {
			const filter = (d) => {
				const route = this.looseRoutesById[d.routeId];
				if (!route.options.loader) return true;
				const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 300 * 1e3;
				if (d.status === "error") return true;
				return Date.now() - d.updatedAt >= gcTime;
			};
			this.clearCache({ filter });
		};
		this.loadRouteChunk = loadRouteChunk;
		this.preloadRoute = async (opts) => {
			const next = this.buildLocation(opts);
			let matches = this.matchRoutes(next, {
				throwOnError: true,
				preload: true,
				dest: opts
			});
			const activeMatchIds = new Set([...this.state.matches, ...this.state.pendingMatches ?? []].map((d) => d.id));
			const loadedMatchIds = /* @__PURE__ */ new Set([...activeMatchIds, ...this.state.cachedMatches.map((d) => d.id)]);
			batch(() => {
				matches.forEach((match) => {
					if (!loadedMatchIds.has(match.id)) this.__store.setState((s) => ({
						...s,
						cachedMatches: [...s.cachedMatches, match]
					}));
				});
			});
			try {
				matches = await loadMatches({
					router: this,
					matches,
					location: next,
					preload: true,
					updateMatch: (id, updater) => {
						if (activeMatchIds.has(id)) matches = matches.map((d) => d.id === id ? updater(d) : d);
						else this.updateMatch(id, updater);
					}
				});
				return matches;
			} catch (err) {
				if (isRedirect(err)) {
					if (err.options.reloadDocument) return;
					return await this.preloadRoute({
						...err.options,
						_fromLocation: next
					});
				}
				if (!isNotFound(err)) console.error(err);
				return;
			}
		};
		this.matchRoute = (location, opts) => {
			const matchLocation = {
				...location,
				to: location.to ? this.resolvePathWithBase(location.from || "", location.to) : void 0,
				params: location.params || {},
				leaveParams: true
			};
			const next = this.buildLocation(matchLocation);
			if (opts?.pending && this.state.status !== "pending") return false;
			const baseLocation = (opts?.pending === void 0 ? !this.state.isLoading : opts.pending) ? this.latestLocation : this.state.resolvedLocation || this.state.location;
			const match = matchPathname(baseLocation.pathname, {
				...opts,
				to: next.pathname
			}, this.parsePathnameCache);
			if (!match) return false;
			if (location.params) {
				if (!deepEqual(match, location.params, { partial: true })) return false;
			}
			if (match && (opts?.includeSearch ?? true)) return deepEqual(baseLocation.search, next.search, { partial: true }) ? match : false;
			return match;
		};
		this.hasNotFoundMatch = () => {
			return this.__store.state.matches.some((d) => d.status === "notFound" || d.globalNotFound);
		};
		this.update({
			defaultPreloadDelay: 50,
			defaultPendingMs: 1e3,
			defaultPendingMinMs: 500,
			context: void 0,
			...options,
			caseSensitive: options.caseSensitive ?? false,
			notFoundMode: options.notFoundMode ?? "fuzzy",
			stringifySearch: options.stringifySearch ?? defaultStringifySearch,
			parseSearch: options.parseSearch ?? defaultParseSearch
		});
		if (typeof document !== "undefined") self.__TSR_ROUTER__ = this;
	}
	isShell() {
		return !!this.options.isShell;
	}
	isPrerendering() {
		return !!this.options.isPrerendering;
	}
	get state() {
		return this.__store.state;
	}
	get looseRoutesById() {
		return this.routesById;
	}
	matchRoutesInternal(next, opts) {
		const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(next.pathname, opts?.dest?.to);
		let isGlobalNotFound = false;
		if (foundRoute ? foundRoute.path !== "/" && routeParams["**"] : trimPathRight(next.pathname)) if (this.options.notFoundRoute) matchedRoutes.push(this.options.notFoundRoute);
		else isGlobalNotFound = true;
		const globalNotFoundRouteId = (() => {
			if (!isGlobalNotFound) return;
			if (this.options.notFoundMode !== "root") for (let i = matchedRoutes.length - 1; i >= 0; i--) {
				const route = matchedRoutes[i];
				if (route.children) return route.id;
			}
			return rootRouteId;
		})();
		const matches = [];
		const getParentContext = (parentMatch) => {
			return !parentMatch?.id ? this.options.context ?? void 0 : parentMatch.context ?? this.options.context ?? void 0;
		};
		matchedRoutes.forEach((route, index) => {
			const parentMatch = matches[index - 1];
			const [preMatchSearch, strictMatchSearch, searchError] = (() => {
				const parentSearch = parentMatch?.search ?? next.search;
				const parentStrictSearch = parentMatch?._strictSearch ?? void 0;
				try {
					const strictSearch = validateSearch(route.options.validateSearch, { ...parentSearch }) ?? void 0;
					return [
						{
							...parentSearch,
							...strictSearch
						},
						{
							...parentStrictSearch,
							...strictSearch
						},
						void 0
					];
				} catch (err) {
					let searchParamError = err;
					if (!(err instanceof SearchParamError)) searchParamError = new SearchParamError(err.message, { cause: err });
					if (opts?.throwOnError) throw searchParamError;
					return [
						parentSearch,
						{},
						searchParamError
					];
				}
			})();
			const loaderDeps = route.options.loaderDeps?.({ search: preMatchSearch }) ?? "";
			const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "";
			const { interpolatedPath, usedParams } = interpolatePath({
				path: route.fullPath,
				params: routeParams,
				decodeCharMap: this.pathParamsDecodeCharMap
			});
			const matchId = interpolatePath({
				path: route.id,
				params: routeParams,
				leaveWildcards: true,
				decodeCharMap: this.pathParamsDecodeCharMap,
				parseCache: this.parsePathnameCache
			}).interpolatedPath + loaderDepsHash;
			const existingMatch = this.getMatch(matchId);
			const previousMatch = this.state.matches.find((d) => d.routeId === route.id);
			const strictParams = existingMatch?._strictParams ?? usedParams;
			let paramsError = void 0;
			if (!existingMatch) {
				const strictParseParams = route.options.params?.parse ?? route.options.parseParams;
				if (strictParseParams) try {
					Object.assign(strictParams, strictParseParams(strictParams));
				} catch (err) {
					paramsError = new PathParamError(err.message, { cause: err });
					if (opts?.throwOnError) throw paramsError;
				}
			}
			Object.assign(routeParams, strictParams);
			const cause = previousMatch ? "stay" : "enter";
			let match;
			if (existingMatch) match = {
				...existingMatch,
				cause,
				params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,
				_strictParams: strictParams,
				search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : replaceEqualDeep(existingMatch.search, preMatchSearch),
				_strictSearch: strictMatchSearch
			};
			else {
				const status = route.options.loader || route.options.beforeLoad || route.lazyFn || routeNeedsPreload(route) ? "pending" : "success";
				match = {
					id: matchId,
					index,
					routeId: route.id,
					params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,
					_strictParams: strictParams,
					pathname: interpolatedPath,
					updatedAt: Date.now(),
					search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : preMatchSearch,
					_strictSearch: strictMatchSearch,
					searchError: void 0,
					status,
					isFetching: false,
					error: void 0,
					paramsError,
					__routeContext: void 0,
					_nonReactive: { loadPromise: createControlledPromise() },
					__beforeLoadContext: void 0,
					context: {},
					abortController: new AbortController(),
					fetchCount: 0,
					cause,
					loaderDeps: previousMatch ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps) : loaderDeps,
					invalid: false,
					preload: false,
					links: void 0,
					scripts: void 0,
					headScripts: void 0,
					meta: void 0,
					staticData: route.options.staticData || {},
					fullPath: route.fullPath
				};
			}
			if (!opts?.preload) match.globalNotFound = globalNotFoundRouteId === route.id;
			match.searchError = searchError;
			match.context = {
				...getParentContext(parentMatch),
				...match.__routeContext,
				...match.__beforeLoadContext
			};
			matches.push(match);
		});
		matches.forEach((match, index) => {
			const route = this.looseRoutesById[match.routeId];
			if (!this.getMatch(match.id) && opts?._buildLocation !== true) {
				const parentMatch = matches[index - 1];
				const parentContext = getParentContext(parentMatch);
				if (route.options.context) {
					const contextFnContext = {
						deps: match.loaderDeps,
						params: match.params,
						context: parentContext ?? {},
						location: next,
						navigate: (opts2) => this.navigate({
							...opts2,
							_fromLocation: next
						}),
						buildLocation: this.buildLocation,
						cause: match.cause,
						abortController: match.abortController,
						preload: !!match.preload,
						matches
					};
					match.__routeContext = route.options.context(contextFnContext) ?? void 0;
				}
				match.context = {
					...parentContext,
					...match.__routeContext,
					...match.__beforeLoadContext
				};
			}
		});
		return matches;
	}
};
var SearchParamError = class extends Error {};
var PathParamError = class extends Error {};
var normalize = (str) => str.endsWith("/") && str.length > 1 ? str.slice(0, -1) : str;
function comparePaths(a, b) {
	return normalize(a) === normalize(b);
}
function lazyFn(fn, key) {
	return async (...args) => {
		return (await fn())[key || "default"](...args);
	};
}
function getInitialRouterState(location) {
	return {
		loadedAt: 0,
		isLoading: false,
		isTransitioning: false,
		status: "idle",
		resolvedLocation: void 0,
		location,
		matches: [],
		pendingMatches: [],
		cachedMatches: [],
		statusCode: 200
	};
}
function validateSearch(validateSearch2, input) {
	if (validateSearch2 == null) return {};
	if ("~standard" in validateSearch2) {
		const result = validateSearch2["~standard"].validate(input);
		if (result instanceof Promise) throw new SearchParamError("Async validation not supported");
		if (result.issues) throw new SearchParamError(JSON.stringify(result.issues, void 0, 2), { cause: result });
		return result.value;
	}
	if ("parse" in validateSearch2) return validateSearch2.parse(input);
	if (typeof validateSearch2 === "function") return validateSearch2(input);
	return {};
}
function getMatchedRoutes({ pathname, routePathname, caseSensitive, routesByPath, routesById, flatRoutes, parseCache }) {
	let routeParams = {};
	const trimmedPath = trimPathRight(pathname);
	const getMatchedParams = (route) => {
		return matchPathname(trimmedPath, {
			to: route.fullPath,
			caseSensitive: route.options?.caseSensitive ?? caseSensitive,
			fuzzy: true
		}, parseCache);
	};
	let foundRoute = routePathname !== void 0 ? routesByPath[routePathname] : void 0;
	if (foundRoute) routeParams = getMatchedParams(foundRoute);
	else {
		let fuzzyMatch = void 0;
		for (const route of flatRoutes) {
			const matchedParams = getMatchedParams(route);
			if (matchedParams) if (route.path !== "/" && matchedParams["**"]) {
				if (!fuzzyMatch) fuzzyMatch = {
					foundRoute: route,
					routeParams: matchedParams
				};
			} else {
				foundRoute = route;
				routeParams = matchedParams;
				break;
			}
		}
		if (!foundRoute && fuzzyMatch) {
			foundRoute = fuzzyMatch.foundRoute;
			routeParams = fuzzyMatch.routeParams;
		}
	}
	let routeCursor = foundRoute || routesById[rootRouteId];
	const matchedRoutes = [routeCursor];
	while (routeCursor.parentRoute) {
		routeCursor = routeCursor.parentRoute;
		matchedRoutes.push(routeCursor);
	}
	matchedRoutes.reverse();
	return {
		matchedRoutes,
		routeParams,
		foundRoute
	};
}
function applySearchMiddleware({ search, dest, destRoutes, _includeValidateSearch }) {
	const allMiddlewares = destRoutes.reduce((acc, route) => {
		const middlewares = [];
		if ("search" in route.options) {
			if (route.options.search?.middlewares) middlewares.push(...route.options.search.middlewares);
		} else if (route.options.preSearchFilters || route.options.postSearchFilters) {
			const legacyMiddleware = ({ search: search2, next }) => {
				let nextSearch = search2;
				if ("preSearchFilters" in route.options && route.options.preSearchFilters) nextSearch = route.options.preSearchFilters.reduce((prev, next2) => next2(prev), search2);
				const result = next(nextSearch);
				if ("postSearchFilters" in route.options && route.options.postSearchFilters) return route.options.postSearchFilters.reduce((prev, next2) => next2(prev), result);
				return result;
			};
			middlewares.push(legacyMiddleware);
		}
		if (_includeValidateSearch && route.options.validateSearch) {
			const validate = ({ search: search2, next }) => {
				const result = next(search2);
				try {
					return {
						...result,
						...validateSearch(route.options.validateSearch, result) ?? void 0
					};
				} catch {
					return result;
				}
			};
			middlewares.push(validate);
		}
		return acc.concat(middlewares);
	}, []) ?? [];
	const final = ({ search: search2 }) => {
		if (!dest.search) return {};
		if (dest.search === true) return search2;
		return functionalUpdate(dest.search, search2);
	};
	allMiddlewares.push(final);
	const applyNext = (index, currentSearch) => {
		if (index >= allMiddlewares.length) return currentSearch;
		const middleware = allMiddlewares[index];
		const next = (newSearch) => {
			return applyNext(index + 1, newSearch);
		};
		return middleware({
			search: currentSearch,
			next
		});
	};
	return applyNext(0, search);
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/defer.js
var TSR_DEFERRED_PROMISE = Symbol.for("TSR_DEFERRED_PROMISE");
function defer(_promise, options) {
	const promise = _promise;
	if (promise[TSR_DEFERRED_PROMISE]) return promise;
	promise[TSR_DEFERRED_PROMISE] = { status: "pending" };
	promise.then((data) => {
		promise[TSR_DEFERRED_PROMISE].status = "success";
		promise[TSR_DEFERRED_PROMISE].data = data;
	}).catch((error) => {
		promise[TSR_DEFERRED_PROMISE].status = "error";
		promise[TSR_DEFERRED_PROMISE].error = {
			data: (options?.serializeError ?? defaultSerializeError)(error),
			__isServerError: true
		};
	});
	return promise;
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/link.js
var preloadWarning = "Error preloading route! ";

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/Matches.js
var isMatch = (match, path) => {
	const parts = path.split(".");
	let part;
	let i = 0;
	let value = match;
	while ((part = parts[i++]) != null && value != null) value = value[part];
	return value != null;
};

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/route.js
var BaseRoute = class {
	constructor(options) {
		this.init = (opts) => {
			this.originalIndex = opts.originalIndex;
			const options2 = this.options;
			const isRoot = !options2?.path && !options2?.id;
			this.parentRoute = this.options.getParentRoute?.();
			if (isRoot) this._path = rootRouteId;
			else if (!this.parentRoute) invariant(false, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);
			let path = isRoot ? rootRouteId : options2?.path;
			if (path && path !== "/") path = trimPathLeft(path);
			const customId = options2?.id || path;
			let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id, customId]);
			if (path === rootRouteId) path = "/";
			if (id !== rootRouteId) id = joinPaths(["/", id]);
			const fullPath = id === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path]);
			this._path = path;
			this._id = id;
			this._fullPath = fullPath;
			this._to = fullPath;
		};
		this.clone = (other) => {
			this._path = other._path;
			this._id = other._id;
			this._fullPath = other._fullPath;
			this._to = other._to;
			this.options.getParentRoute = other.options.getParentRoute;
			this.children = other.children;
		};
		this.addChildren = (children) => {
			return this._addFileChildren(children);
		};
		this._addFileChildren = (children) => {
			if (Array.isArray(children)) this.children = children;
			if (typeof children === "object" && children !== null) this.children = Object.values(children);
			return this;
		};
		this._addFileTypes = () => {
			return this;
		};
		this.updateLoader = (options2) => {
			Object.assign(this.options, options2);
			return this;
		};
		this.update = (options2) => {
			Object.assign(this.options, options2);
			return this;
		};
		this.lazy = (lazyFn$1) => {
			this.lazyFn = lazyFn$1;
			return this;
		};
		this.options = options || {};
		this.isRoot = !options?.getParentRoute;
		if (options?.id && options?.path) throw new Error(`Route cannot have both an 'id' and a 'path' option.`);
	}
	get to() {
		return this._to;
	}
	get id() {
		return this._id;
	}
	get path() {
		return this._path;
	}
	get fullPath() {
		return this._fullPath;
	}
};
var BaseRouteApi = class {
	constructor({ id }) {
		this.notFound = (opts) => {
			return notFound({
				routeId: this.id,
				...opts
			});
		};
		this.id = id;
	}
};
var BaseRootRoute = class extends BaseRoute {
	constructor(options) {
		super(options);
	}
};

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/config.js
var createRouterConfig = (options) => {
	return {
		serializationAdapters: options.serializationAdapters,
		defaultSsr: options.defaultSsr
	};
};

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/searchMiddleware.js
function retainSearchParams(keys) {
	return ({ search, next }) => {
		const result = next(search);
		if (keys === true) return {
			...search,
			...result
		};
		keys.forEach((key) => {
			if (!(key in result)) result[key] = search[key];
		});
		return result;
	};
}
function stripSearchParams(input) {
	return ({ search, next }) => {
		if (input === true) return {};
		const result = next(search);
		if (Array.isArray(input)) input.forEach((key) => {
			delete result[key];
		});
		else Object.entries(input).forEach(([key, value]) => {
			if (deepEqual(result[key], value)) delete result[key];
		});
		return result;
	};
}

//#endregion
//#region node_modules/seroval/dist/esm/development/index.mjs
var REFERENCES_KEY = "__SEROVAL_REFS__";
var GLOBAL_CONTEXT_REFERENCES = "$R";
var GLOBAL_CONTEXT_R = `self.${GLOBAL_CONTEXT_REFERENCES}`;
var INV_REFERENCE = /* @__PURE__ */ new Map();
if (typeof globalThis !== "undefined") Object.defineProperty(globalThis, REFERENCES_KEY, {
	value: INV_REFERENCE,
	configurable: true,
	writable: false,
	enumerable: false
});
else if (typeof window !== "undefined") Object.defineProperty(window, REFERENCES_KEY, {
	value: INV_REFERENCE,
	configurable: true,
	writable: false,
	enumerable: false
});
else if (typeof self !== "undefined") Object.defineProperty(self, REFERENCES_KEY, {
	value: INV_REFERENCE,
	configurable: true,
	writable: false,
	enumerable: false
});
else if (typeof global !== "undefined") Object.defineProperty(global, REFERENCES_KEY, {
	value: INV_REFERENCE,
	configurable: true,
	writable: false,
	enumerable: false
});
var INV_SYMBOL_REF = {
	[Symbol.asyncIterator]: 0,
	[Symbol.hasInstance]: 1,
	[Symbol.isConcatSpreadable]: 2,
	[Symbol.iterator]: 3,
	[Symbol.match]: 4,
	[Symbol.matchAll]: 5,
	[Symbol.replace]: 6,
	[Symbol.search]: 7,
	[Symbol.species]: 8,
	[Symbol.split]: 9,
	[Symbol.toPrimitive]: 10,
	[Symbol.toStringTag]: 11,
	[Symbol.unscopables]: 12
};
var CONSTANT_VAL = {
	[2]: true,
	[3]: false,
	[1]: void 0,
	[0]: null,
	[4]: -0,
	[5]: Number.POSITIVE_INFINITY,
	[6]: Number.NEGATIVE_INFINITY,
	[7]: NaN
};
var { toString: objectToString } = Object.prototype;
var REF_START_CHARS = "hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_";
var REF_START_CHARS_LEN = REF_START_CHARS.length;
var REF_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_";
var REF_CHARS_LEN = REF_CHARS.length;

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/ssr/serializer/transformer.js
function createSerializationAdapter(opts) {
	return opts;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/awaited.js
var import_jsx_runtime = /* @__PURE__ */ __toESM(require_jsx_runtime(), 1);
var import_react = /* @__PURE__ */ __toESM(require_react(), 1);
function useAwaited({ promise: _promise }) {
	const promise = defer(_promise);
	if (promise[TSR_DEFERRED_PROMISE].status === "pending") throw promise;
	if (promise[TSR_DEFERRED_PROMISE].status === "error") throw promise[TSR_DEFERRED_PROMISE].error;
	return [promise[TSR_DEFERRED_PROMISE].data, promise];
}
function Await(props) {
	const inner = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AwaitInner, { ...props });
	if (props.fallback) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Suspense, {
		fallback: props.fallback,
		children: inner
	});
	return inner;
}
function AwaitInner(props) {
	const [data] = useAwaited(props);
	return props.children(data);
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/CatchBoundary.js
function CatchBoundary(props) {
	const errorComponent = props.errorComponent ?? ErrorComponent;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CatchBoundaryImpl, {
		getResetKey: props.getResetKey,
		onCatch: props.onCatch,
		children: ({ error, reset }) => {
			if (error) return import_react.createElement(errorComponent, {
				error,
				reset
			});
			return props.children;
		}
	});
}
var CatchBoundaryImpl = class extends import_react.Component {
	constructor() {
		super(...arguments);
		this.state = { error: null };
	}
	static getDerivedStateFromProps(props) {
		return { resetKey: props.getResetKey() };
	}
	static getDerivedStateFromError(error) {
		return { error };
	}
	reset() {
		this.setState({ error: null });
	}
	componentDidUpdate(prevProps, prevState) {
		if (prevState.error && prevState.resetKey !== this.state.resetKey) this.reset();
	}
	componentDidCatch(error, errorInfo) {
		if (this.props.onCatch) this.props.onCatch(error, errorInfo);
	}
	render() {
		return this.props.children({
			error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
			reset: () => {
				this.reset();
			}
		});
	}
};
function ErrorComponent({ error }) {
	const [show, setShow] = import_react.useState(true);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
		style: {
			padding: ".5rem",
			maxWidth: "100%"
		},
		children: [
			/* @__PURE__ */ (0, import_jsx_runtime.jsxs)("div", {
				style: {
					display: "flex",
					alignItems: "center",
					gap: ".5rem"
				},
				children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)("strong", {
					style: { fontSize: "1rem" },
					children: "Something went wrong!"
				}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)("button", {
					style: {
						appearance: "none",
						fontSize: ".6em",
						border: "1px solid currentColor",
						padding: ".1rem .2rem",
						fontWeight: "bold",
						borderRadius: ".25rem"
					},
					onClick: () => setShow((d) => !d),
					children: show ? "Hide Error" : "Show Error"
				})]
			}),
			/* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { style: { height: ".25rem" } }),
			show ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("div", { children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)("pre", {
				style: {
					fontSize: ".7em",
					border: "1px solid red",
					borderRadius: ".25rem",
					padding: ".3rem",
					color: "red",
					overflow: "auto"
				},
				children: error.message ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)("code", { children: error.message }) : null
			}) }) : null
		]
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/ClientOnly.js
function ClientOnly({ children, fallback = null }) {
	return useHydrated() ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Fragment, { children }) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Fragment, { children: fallback });
}
function useHydrated() {
	return import_react.useSyncExternalStore(subscribe, () => true, () => false);
}
function subscribe() {
	return () => {};
}

//#endregion
//#region node_modules/tiny-warning/dist/tiny-warning.esm.js
var isProduction = false;
function warning(condition, message) {
	if (!isProduction) {
		if (condition) return;
		var text = "Warning: " + message;
		if (typeof console !== "undefined") console.warn(text);
		try {
			throw Error(text);
		} catch (x) {}
	}
}
var tiny_warning_esm_default = warning;

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js": ((exports) => {
	(function() {
		function is(x, y) {
			return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
		}
		function useSyncExternalStore$2(subscribe$1, getSnapshot) {
			didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
			var value = getSnapshot();
			if (!didWarnUncachedGetSnapshot) {
				var cachedValue = getSnapshot();
				objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
			}
			cachedValue = useState({ inst: {
				value,
				getSnapshot
			} });
			var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
			useLayoutEffect$1(function() {
				inst.value = value;
				inst.getSnapshot = getSnapshot;
				checkIfSnapshotChanged(inst) && forceUpdate({ inst });
			}, [
				subscribe$1,
				value,
				getSnapshot
			]);
			useEffect(function() {
				checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				return subscribe$1(function() {
					checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				});
			}, [subscribe$1]);
			useDebugValue(value);
			return value;
		}
		function checkIfSnapshotChanged(inst) {
			var latestGetSnapshot = inst.getSnapshot;
			inst = inst.value;
			try {
				var nextValue = latestGetSnapshot();
				return !objectIs(inst, nextValue);
			} catch (error) {
				return !0;
			}
		}
		function useSyncExternalStore$1(subscribe$1, getSnapshot) {
			return getSnapshot();
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect$1 = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
		exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/shim/index.js
var require_shim = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/shim/index.js": ((exports, module) => {
	module.exports = require_use_sync_external_store_shim_development();
}) });

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js": ((exports) => {
	(function() {
		function is(x, y) {
			return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef$1 = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
		exports.useSyncExternalStoreWithSelector = function(subscribe$1, getSnapshot, getServerSnapshot, selector, isEqual) {
			var instRef = useRef$1(null);
			if (null === instRef.current) {
				var inst = {
					hasValue: !1,
					value: null
				};
				instRef.current = inst;
			} else inst = instRef.current;
			instRef = useMemo(function() {
				function memoizedSelector(nextSnapshot) {
					if (!hasMemo) {
						hasMemo = !0;
						memoizedSnapshot = nextSnapshot;
						nextSnapshot = selector(nextSnapshot);
						if (void 0 !== isEqual && inst.hasValue) {
							var currentSelection = inst.value;
							if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
						}
						return memoizedSelection = nextSnapshot;
					}
					currentSelection = memoizedSelection;
					if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
					var nextSelection = selector(nextSnapshot);
					if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
					memoizedSnapshot = nextSnapshot;
					return memoizedSelection = nextSelection;
				}
				var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
				return [function() {
					return memoizedSelector(getSnapshot());
				}, null === maybeGetServerSnapshot ? void 0 : function() {
					return memoizedSelector(maybeGetServerSnapshot());
				}];
			}, [
				getSnapshot,
				getServerSnapshot,
				selector,
				isEqual
			]);
			var value = useSyncExternalStore(subscribe$1, instRef[0], instRef[1]);
			useEffect(function() {
				inst.hasValue = !0;
				inst.value = value;
			}, [value]);
			useDebugValue(value);
			return value;
		};
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/shim/with-selector.js": ((exports, module) => {
	module.exports = require_with_selector_development();
}) });

//#endregion
//#region node_modules/@tanstack/react-store/dist/esm/index.js
var import_with_selector = /* @__PURE__ */ __toESM(require_with_selector());
function useStore(store, selector = (d) => d) {
	return (0, import_with_selector.useSyncExternalStoreWithSelector)(store.subscribe, () => store.state, () => store.state, selector, shallow);
}
function shallow(objA, objB) {
	if (Object.is(objA, objB)) return true;
	if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) return false;
	if (objA instanceof Map && objB instanceof Map) {
		if (objA.size !== objB.size) return false;
		for (const [k, v] of objA) if (!objB.has(k) || !Object.is(v, objB.get(k))) return false;
		return true;
	}
	if (objA instanceof Set && objB instanceof Set) {
		if (objA.size !== objB.size) return false;
		for (const v of objA) if (!objB.has(v)) return false;
		return true;
	}
	if (objA instanceof Date && objB instanceof Date) {
		if (objA.getTime() !== objB.getTime()) return false;
		return true;
	}
	const keysA = getOwnKeys(objA);
	if (keysA.length !== getOwnKeys(objB).length) return false;
	for (let i = 0; i < keysA.length; i++) if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) return false;
	return true;
}
function getOwnKeys(obj) {
	return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj));
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/routerContext.js
var routerContext = import_react.createContext(null);
function getRouterContext() {
	if (typeof document === "undefined") return routerContext;
	if (window.__TSR_ROUTER_CONTEXT__) return window.__TSR_ROUTER_CONTEXT__;
	window.__TSR_ROUTER_CONTEXT__ = routerContext;
	return routerContext;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useRouter.js
function useRouter(opts) {
	const value = import_react.useContext(getRouterContext());
	tiny_warning_esm_default(!((opts?.warn ?? true) && !value), "useRouter must be used inside a <RouterProvider> component!");
	return value;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useRouterState.js
function useRouterState(opts) {
	const contextRouter = useRouter({ warn: opts?.router === void 0 });
	const router = opts?.router || contextRouter;
	const previousResult = (0, import_react.useRef)(void 0);
	return useStore(router.__store, (state) => {
		if (opts?.select) {
			if (opts.structuralSharing ?? router.options.defaultStructuralSharing) {
				const newSlice = replaceEqualDeep(previousResult.current, opts.select(state));
				previousResult.current = newSlice;
				return newSlice;
			}
			return opts.select(state);
		}
		return state;
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/matchContext.js
var matchContext = import_react.createContext(void 0);
var dummyMatchContext = import_react.createContext(void 0);

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useMatch.js
function useMatch(opts) {
	const nearestMatchId = import_react.useContext(opts.from ? dummyMatchContext : matchContext);
	return useRouterState({
		select: (state) => {
			const match = state.matches.find((d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId);
			invariant(!((opts.shouldThrow ?? true) && !match), `Could not find ${opts.from ? `an active match from "${opts.from}"` : "a nearest match!"}`);
			if (match === void 0) return;
			return opts.select ? opts.select(match) : match;
		},
		structuralSharing: opts.structuralSharing
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useLoaderData.js
function useLoaderData(opts) {
	return useMatch({
		from: opts.from,
		strict: opts.strict,
		structuralSharing: opts.structuralSharing,
		select: (s) => {
			return opts.select ? opts.select(s.loaderData) : s.loaderData;
		}
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useLoaderDeps.js
function useLoaderDeps(opts) {
	const { select,...rest } = opts;
	return useMatch({
		...rest,
		select: (s) => {
			return select ? select(s.loaderDeps) : s.loaderDeps;
		}
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useParams.js
function useParams(opts) {
	return useMatch({
		from: opts.from,
		shouldThrow: opts.shouldThrow,
		structuralSharing: opts.structuralSharing,
		strict: opts.strict,
		select: (match) => {
			const params = opts.strict === false ? match.params : match._strictParams;
			return opts.select ? opts.select(params) : params;
		}
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useSearch.js
function useSearch(opts) {
	return useMatch({
		from: opts.from,
		strict: opts.strict,
		shouldThrow: opts.shouldThrow,
		structuralSharing: opts.structuralSharing,
		select: (match) => {
			return opts.select ? opts.select(match.search) : match.search;
		}
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useNavigate.js
function useNavigate(_defaultOpts) {
	const router = useRouter();
	return import_react.useCallback((options) => {
		return router.navigate({
			...options,
			from: options.from ?? _defaultOpts?.from
		});
	}, [_defaultOpts?.from, router]);
}
function Navigate(props) {
	const router = useRouter();
	const navigate = useNavigate();
	const previousPropsRef = import_react.useRef(null);
	import_react.useEffect(() => {
		if (previousPropsRef.current !== props) {
			navigate(props);
			previousPropsRef.current = props;
		}
	}, [
		router,
		props,
		navigate
	]);
	return null;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/utils.js
function useStableCallback(fn) {
	const fnRef = import_react.useRef(fn);
	fnRef.current = fn;
	return import_react.useRef((...args) => fnRef.current(...args)).current;
}
var useLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function usePrevious(value) {
	const ref = import_react.useRef({
		value,
		prev: null
	});
	const current = ref.current.value;
	if (value !== current) ref.current = {
		value,
		prev: current
	};
	return ref.current.prev;
}
function useIntersectionObserver(ref, callback, intersectionObserverOptions$1 = {}, options = {}) {
	import_react.useEffect(() => {
		if (!ref.current || options.disabled || typeof IntersectionObserver !== "function") return;
		const observer = new IntersectionObserver(([entry]) => {
			callback(entry);
		}, intersectionObserverOptions$1);
		observer.observe(ref.current);
		return () => {
			observer.disconnect();
		};
	}, [
		callback,
		intersectionObserverOptions$1,
		options.disabled,
		ref
	]);
}
function useForwardedRef(ref) {
	const innerRef = import_react.useRef(null);
	import_react.useImperativeHandle(ref, () => innerRef.current, []);
	return innerRef;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/link.js
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom(), 1);
function useLinkProps(options, forwardedRef) {
	const router = useRouter();
	const [isTransitioning, setIsTransitioning] = import_react.useState(false);
	const hasRenderFetched = import_react.useRef(false);
	const innerRef = useForwardedRef(forwardedRef);
	const { activeProps, inactiveProps, activeOptions, to, preload: userPreload, preloadDelay: userPreloadDelay, hashScrollIntoView, replace, startTransition, resetScroll, viewTransition, children, target, disabled, style, className, onClick, onFocus, onMouseEnter, onMouseLeave, onTouchStart, ignoreBlocker, params: _params, search: _search, hash: _hash, state: _state, mask: _mask, reloadDocument: _reloadDocument, unsafeRelative: _unsafeRelative, from: _from, _fromLocation,...propsSafeToSpread } = options;
	const currentSearch = useRouterState({
		select: (s) => s.location.search,
		structuralSharing: true
	});
	const from = options.from;
	const _options = import_react.useMemo(() => {
		return {
			...options,
			from
		};
	}, [
		router,
		currentSearch,
		from,
		options._fromLocation,
		options.hash,
		options.to,
		options.search,
		options.params,
		options.state,
		options.mask,
		options.unsafeRelative
	]);
	const next = import_react.useMemo(() => router.buildLocation({ ..._options }), [router, _options]);
	const hrefOption = import_react.useMemo(() => {
		if (disabled) return;
		let href = next.maskedLocation ? next.maskedLocation.url : next.url;
		let external = false;
		if (router.origin) if (href.startsWith(router.origin)) href = router.history.createHref(href.replace(router.origin, "")) || "/";
		else external = true;
		return {
			href,
			external
		};
	}, [
		disabled,
		next.maskedLocation,
		next.url,
		router.origin,
		router.history
	]);
	const externalLink = import_react.useMemo(() => {
		if (hrefOption?.external) return hrefOption.href;
		try {
			new URL(to);
			return to;
		} catch {}
	}, [to, hrefOption]);
	const preload = options.reloadDocument || externalLink ? false : userPreload ?? router.options.defaultPreload;
	const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;
	const isActive = useRouterState({ select: (s) => {
		if (externalLink) return false;
		if (activeOptions?.exact) {
			if (!exactPathTest(s.location.pathname, next.pathname, router.basepath)) return false;
		} else {
			const currentPathSplit = removeTrailingSlash(s.location.pathname, router.basepath);
			const nextPathSplit = removeTrailingSlash(next.pathname, router.basepath);
			if (!(currentPathSplit.startsWith(nextPathSplit) && (currentPathSplit.length === nextPathSplit.length || currentPathSplit[nextPathSplit.length] === "/"))) return false;
		}
		if (activeOptions?.includeSearch ?? true) {
			if (!deepEqual(s.location.search, next.search, {
				partial: !activeOptions?.exact,
				ignoreUndefined: !activeOptions?.explicitUndefined
			})) return false;
		}
		if (activeOptions?.includeHash) return s.location.hash === next.hash;
		return true;
	} });
	const doPreload = import_react.useCallback(() => {
		router.preloadRoute({ ..._options }).catch((err) => {
			console.warn(err);
			console.warn(preloadWarning);
		});
	}, [router, _options]);
	useIntersectionObserver(innerRef, import_react.useCallback((entry) => {
		if (entry?.isIntersecting) doPreload();
	}, [doPreload]), intersectionObserverOptions, { disabled: !!disabled || !(preload === "viewport") });
	import_react.useEffect(() => {
		if (hasRenderFetched.current) return;
		if (!disabled && preload === "render") {
			doPreload();
			hasRenderFetched.current = true;
		}
	}, [
		disabled,
		doPreload,
		preload
	]);
	const handleClick = (e) => {
		const elementTarget = e.currentTarget.target;
		const effectiveTarget = target !== void 0 ? target : elementTarget;
		if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!effectiveTarget || effectiveTarget === "_self") && e.button === 0) {
			e.preventDefault();
			(0, import_react_dom.flushSync)(() => {
				setIsTransitioning(true);
			});
			const unsub = router.subscribe("onResolved", () => {
				unsub();
				setIsTransitioning(false);
			});
			router.navigate({
				..._options,
				replace,
				resetScroll,
				hashScrollIntoView,
				startTransition,
				viewTransition,
				ignoreBlocker
			});
		}
	};
	if (externalLink) return {
		...propsSafeToSpread,
		ref: innerRef,
		href: externalLink,
		...children && { children },
		...target && { target },
		...disabled && { disabled },
		...style && { style },
		...className && { className },
		...onClick && { onClick },
		...onFocus && { onFocus },
		...onMouseEnter && { onMouseEnter },
		...onMouseLeave && { onMouseLeave },
		...onTouchStart && { onTouchStart }
	};
	const handleFocus = (_) => {
		if (disabled) return;
		if (preload) doPreload();
	};
	const handleTouchStart = handleFocus;
	const handleEnter = (e) => {
		if (disabled || !preload) return;
		if (!preloadDelay) doPreload();
		else {
			const eventTarget = e.target;
			if (timeoutMap.has(eventTarget)) return;
			const id = setTimeout(() => {
				timeoutMap.delete(eventTarget);
				doPreload();
			}, preloadDelay);
			timeoutMap.set(eventTarget, id);
		}
	};
	const handleLeave = (e) => {
		if (disabled || !preload || !preloadDelay) return;
		const eventTarget = e.target;
		const id = timeoutMap.get(eventTarget);
		if (id) {
			clearTimeout(id);
			timeoutMap.delete(eventTarget);
		}
	};
	const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? STATIC_ACTIVE_OBJECT : STATIC_EMPTY_OBJECT;
	const resolvedInactiveProps = isActive ? STATIC_EMPTY_OBJECT : functionalUpdate(inactiveProps, {}) ?? STATIC_EMPTY_OBJECT;
	const resolvedClassName = [
		className,
		resolvedActiveProps.className,
		resolvedInactiveProps.className
	].filter(Boolean).join(" ");
	const resolvedStyle = (style || resolvedActiveProps.style || resolvedInactiveProps.style) && {
		...style,
		...resolvedActiveProps.style,
		...resolvedInactiveProps.style
	};
	return {
		...propsSafeToSpread,
		...resolvedActiveProps,
		...resolvedInactiveProps,
		href: hrefOption?.href,
		ref: innerRef,
		onClick: composeHandlers([onClick, handleClick]),
		onFocus: composeHandlers([onFocus, handleFocus]),
		onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
		onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
		onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
		disabled: !!disabled,
		target,
		...resolvedStyle && { style: resolvedStyle },
		...resolvedClassName && { className: resolvedClassName },
		...disabled && STATIC_DISABLED_PROPS,
		...isActive && STATIC_ACTIVE_PROPS,
		...isTransitioning && STATIC_TRANSITIONING_PROPS
	};
}
var STATIC_EMPTY_OBJECT = {};
var STATIC_ACTIVE_OBJECT = { className: "active" };
var STATIC_DISABLED_PROPS = {
	role: "link",
	"aria-disabled": true
};
var STATIC_ACTIVE_PROPS = {
	"data-status": "active",
	"aria-current": "page"
};
var STATIC_TRANSITIONING_PROPS = { "data-transitioning": "transitioning" };
var timeoutMap = /* @__PURE__ */ new WeakMap();
var intersectionObserverOptions = { rootMargin: "100px" };
var composeHandlers = (handlers) => (e) => {
	for (const handler of handlers) {
		if (!handler) continue;
		if (e.defaultPrevented) return;
		handler(e);
	}
};
function createLink(Comp) {
	return import_react.forwardRef(function CreatedLink(props, ref) {
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Link, {
			...props,
			_asChild: Comp,
			ref
		});
	});
}
var Link = import_react.forwardRef((props, ref) => {
	const { _asChild,...rest } = props;
	const { type: _type, ref: innerRef,...linkProps } = useLinkProps(rest, ref);
	const children = typeof rest.children === "function" ? rest.children({ isActive: linkProps["data-status"] === "active" }) : rest.children;
	if (_asChild === void 0) delete linkProps.disabled;
	return import_react.createElement(_asChild ? _asChild : "a", {
		...linkProps,
		ref: innerRef
	}, children);
});
function isCtrlEvent(e) {
	return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
var linkOptions = (options) => {
	return options;
};

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/route.js
function getRouteApi(id) {
	return new RouteApi({ id });
}
var RouteApi = class extends BaseRouteApi {
	/**
	* @deprecated Use the `getRouteApi` function instead.
	*/
	constructor({ id }) {
		super({ id });
		this.useMatch = (opts) => {
			return useMatch({
				select: opts?.select,
				from: this.id,
				structuralSharing: opts?.structuralSharing
			});
		};
		this.useRouteContext = (opts) => {
			return useMatch({
				from: this.id,
				select: (d) => opts?.select ? opts.select(d.context) : d.context
			});
		};
		this.useSearch = (opts) => {
			return useSearch({
				select: opts?.select,
				structuralSharing: opts?.structuralSharing,
				from: this.id
			});
		};
		this.useParams = (opts) => {
			return useParams({
				select: opts?.select,
				structuralSharing: opts?.structuralSharing,
				from: this.id
			});
		};
		this.useLoaderDeps = (opts) => {
			return useLoaderDeps({
				...opts,
				from: this.id,
				strict: false
			});
		};
		this.useLoaderData = (opts) => {
			return useLoaderData({
				...opts,
				from: this.id,
				strict: false
			});
		};
		this.useNavigate = () => {
			return useNavigate({ from: useRouter().routesById[this.id].fullPath });
		};
		this.notFound = (opts) => {
			return notFound({
				routeId: this.id,
				...opts
			});
		};
		this.Link = import_react.forwardRef((props, ref) => {
			const fullPath = useRouter().routesById[this.id].fullPath;
			return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Link, {
				ref,
				from: fullPath,
				...props
			});
		});
	}
};
var Route = class extends BaseRoute {
	/**
	* @deprecated Use the `createRoute` function instead.
	*/
	constructor(options) {
		super(options);
		this.useMatch = (opts) => {
			return useMatch({
				select: opts?.select,
				from: this.id,
				structuralSharing: opts?.structuralSharing
			});
		};
		this.useRouteContext = (opts) => {
			return useMatch({
				...opts,
				from: this.id,
				select: (d) => opts?.select ? opts.select(d.context) : d.context
			});
		};
		this.useSearch = (opts) => {
			return useSearch({
				select: opts?.select,
				structuralSharing: opts?.structuralSharing,
				from: this.id
			});
		};
		this.useParams = (opts) => {
			return useParams({
				select: opts?.select,
				structuralSharing: opts?.structuralSharing,
				from: this.id
			});
		};
		this.useLoaderDeps = (opts) => {
			return useLoaderDeps({
				...opts,
				from: this.id
			});
		};
		this.useLoaderData = (opts) => {
			return useLoaderData({
				...opts,
				from: this.id
			});
		};
		this.useNavigate = () => {
			return useNavigate({ from: this.fullPath });
		};
		this.Link = import_react.forwardRef((props, ref) => {
			return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Link, {
				ref,
				from: this.fullPath,
				...props
			});
		});
		this.$$typeof = Symbol.for("react.memo");
	}
};
function createRoute(options) {
	return new Route(options);
}
function createRootRouteWithContext() {
	return (options) => {
		return createRootRoute(options);
	};
}
var rootRouteWithContext = createRootRouteWithContext;
var RootRoute = class extends BaseRootRoute {
	/**
	* @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
	*/
	constructor(options) {
		super(options);
		this.useMatch = (opts) => {
			return useMatch({
				select: opts?.select,
				from: this.id,
				structuralSharing: opts?.structuralSharing
			});
		};
		this.useRouteContext = (opts) => {
			return useMatch({
				...opts,
				from: this.id,
				select: (d) => opts?.select ? opts.select(d.context) : d.context
			});
		};
		this.useSearch = (opts) => {
			return useSearch({
				select: opts?.select,
				structuralSharing: opts?.structuralSharing,
				from: this.id
			});
		};
		this.useParams = (opts) => {
			return useParams({
				select: opts?.select,
				structuralSharing: opts?.structuralSharing,
				from: this.id
			});
		};
		this.useLoaderDeps = (opts) => {
			return useLoaderDeps({
				...opts,
				from: this.id
			});
		};
		this.useLoaderData = (opts) => {
			return useLoaderData({
				...opts,
				from: this.id
			});
		};
		this.useNavigate = () => {
			return useNavigate({ from: this.fullPath });
		};
		this.Link = import_react.forwardRef((props, ref) => {
			return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Link, {
				ref,
				from: this.fullPath,
				...props
			});
		});
		this.$$typeof = Symbol.for("react.memo");
	}
};
function createRootRoute(options) {
	return new RootRoute(options);
}
function createRouteMask(opts) {
	return opts;
}
var NotFoundRoute = class extends Route {
	constructor(options) {
		super({
			...options,
			id: "404"
		});
	}
};

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/fileRoute.js
function createFileRoute(path) {
	if (typeof path === "object") return new FileRoute(path, { silent: true }).createRoute(path);
	return new FileRoute(path, { silent: true }).createRoute;
}
var FileRoute = class {
	constructor(path, _opts) {
		this.path = path;
		this.createRoute = (options) => {
			tiny_warning_esm_default(this.silent, "FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead.");
			const route = createRoute(options);
			route.isRoot = false;
			return route;
		};
		this.silent = _opts?.silent;
	}
};
function FileRouteLoader(_path) {
	tiny_warning_esm_default(false, `FileRouteLoader is deprecated and will be removed in the next major version. Please place the loader function in the the main route file, inside the \`createFileRoute('/path/to/file')(options)\` options`);
	return (loaderFn) => loaderFn;
}
var LazyRoute = class {
	constructor(opts) {
		this.useMatch = (opts2) => {
			return useMatch({
				select: opts2?.select,
				from: this.options.id,
				structuralSharing: opts2?.structuralSharing
			});
		};
		this.useRouteContext = (opts2) => {
			return useMatch({
				from: this.options.id,
				select: (d) => opts2?.select ? opts2.select(d.context) : d.context
			});
		};
		this.useSearch = (opts2) => {
			return useSearch({
				select: opts2?.select,
				structuralSharing: opts2?.structuralSharing,
				from: this.options.id
			});
		};
		this.useParams = (opts2) => {
			return useParams({
				select: opts2?.select,
				structuralSharing: opts2?.structuralSharing,
				from: this.options.id
			});
		};
		this.useLoaderDeps = (opts2) => {
			return useLoaderDeps({
				...opts2,
				from: this.options.id
			});
		};
		this.useLoaderData = (opts2) => {
			return useLoaderData({
				...opts2,
				from: this.options.id
			});
		};
		this.useNavigate = () => {
			return useNavigate({ from: useRouter().routesById[this.options.id].fullPath });
		};
		this.options = opts;
		this.$$typeof = Symbol.for("react.memo");
	}
};
function createLazyRoute(id) {
	return (opts) => {
		return new LazyRoute({
			id,
			...opts
		});
	};
}
function createLazyFileRoute(id) {
	if (typeof id === "object") return new LazyRoute(id);
	return (opts) => new LazyRoute({
		id,
		...opts
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/lazyRouteComponent.js
function lazyRouteComponent(importer, exportName) {
	let loadPromise;
	let comp;
	let error;
	let reload;
	const load = () => {
		if (!loadPromise) loadPromise = importer().then((res) => {
			loadPromise = void 0;
			comp = res[exportName ?? "default"];
		}).catch((err) => {
			error = err;
			if (isModuleNotFoundError(error)) {
				if (error instanceof Error && typeof window !== "undefined" && typeof sessionStorage !== "undefined") {
					const storageKey$1 = `tanstack_router_reload:${error.message}`;
					if (!sessionStorage.getItem(storageKey$1)) {
						sessionStorage.setItem(storageKey$1, "1");
						reload = true;
					}
				}
			}
		});
		return loadPromise;
	};
	const lazyComp = function Lazy(props) {
		if (reload) {
			window.location.reload();
			throw new Promise(() => {});
		}
		if (error) throw error;
		if (!comp) throw load();
		return import_react.createElement(comp, props);
	};
	lazyComp.preload = load;
	return lazyComp;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/Transitioner.js
function Transitioner() {
	const router = useRouter();
	const mountLoadForRouter = import_react.useRef({
		router,
		mounted: false
	});
	const [isTransitioning, setIsTransitioning] = import_react.useState(false);
	const { hasPendingMatches, isLoading } = useRouterState({
		select: (s) => ({
			isLoading: s.isLoading,
			hasPendingMatches: s.matches.some((d) => d.status === "pending")
		}),
		structuralSharing: true
	});
	const previousIsLoading = usePrevious(isLoading);
	const isAnyPending = isLoading || isTransitioning || hasPendingMatches;
	const previousIsAnyPending = usePrevious(isAnyPending);
	const isPagePending = isLoading || hasPendingMatches;
	const previousIsPagePending = usePrevious(isPagePending);
	router.startTransition = (fn) => {
		setIsTransitioning(true);
		import_react.startTransition(() => {
			fn();
			setIsTransitioning(false);
		});
	};
	import_react.useEffect(() => {
		const unsub = router.history.subscribe(router.load);
		const nextLocation = router.buildLocation({
			to: router.latestLocation.pathname,
			search: true,
			params: true,
			hash: true,
			state: true,
			_includeValidateSearch: true
		});
		if (trimPathRight(router.latestLocation.href) !== trimPathRight(nextLocation.href)) router.commitLocation({
			...nextLocation,
			replace: true
		});
		return () => {
			unsub();
		};
	}, [router, router.history]);
	useLayoutEffect(() => {
		if (typeof window !== "undefined" && router.ssr || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted) return;
		mountLoadForRouter.current = {
			router,
			mounted: true
		};
		const tryLoad = async () => {
			try {
				await router.load();
			} catch (err) {
				console.error(err);
			}
		};
		tryLoad();
	}, [router]);
	useLayoutEffect(() => {
		if (previousIsLoading && !isLoading) router.emit({
			type: "onLoad",
			...getLocationChangeInfo(router.state)
		});
	}, [
		previousIsLoading,
		router,
		isLoading
	]);
	useLayoutEffect(() => {
		if (previousIsPagePending && !isPagePending) router.emit({
			type: "onBeforeRouteMount",
			...getLocationChangeInfo(router.state)
		});
	}, [
		isPagePending,
		previousIsPagePending,
		router
	]);
	useLayoutEffect(() => {
		if (previousIsAnyPending && !isAnyPending) {
			router.emit({
				type: "onResolved",
				...getLocationChangeInfo(router.state)
			});
			router.__store.setState((s) => ({
				...s,
				status: "idle",
				resolvedLocation: s.location
			}));
			handleHashScroll(router);
		}
	}, [
		isAnyPending,
		previousIsAnyPending,
		router
	]);
	return null;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/not-found.js
function CatchNotFound(props) {
	const resetKey = useRouterState({ select: (s) => `not-found-${s.location.pathname}-${s.status}` });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CatchBoundary, {
		getResetKey: () => resetKey,
		onCatch: (error, errorInfo) => {
			if (isNotFound(error)) props.onCatch?.(error, errorInfo);
			else throw error;
		},
		errorComponent: ({ error }) => {
			if (isNotFound(error)) return props.fallback?.(error);
			else throw error;
		},
		children: props.children
	});
}
function DefaultGlobalNotFound() {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("p", { children: "Not Found" });
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/SafeFragment.js
function SafeFragment(props) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: props.children });
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/renderRouteNotFound.js
function renderRouteNotFound(router, route, data) {
	if (!route.options.notFoundComponent) {
		if (router.options.defaultNotFoundComponent) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(router.options.defaultNotFoundComponent, { data });
		tiny_warning_esm_default(route.options.notFoundComponent, `A notFoundError was encountered on the route with ID "${route.id}", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<div>Not Found<div>)`);
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DefaultGlobalNotFound, {});
	}
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(route.options.notFoundComponent, { data });
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/ScriptOnce.js
function ScriptOnce({ children }) {
	const router = useRouter();
	if (!router.isServer) return null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("script", {
		nonce: router.options.ssr?.nonce,
		className: "$tsr",
		dangerouslySetInnerHTML: { __html: [children].filter(Boolean).join("\n") + ";$_TSR.c()" }
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/scroll-restoration.js
function ScrollRestoration$1() {
	const router = useRouter();
	if (!router.isScrollRestoring || !router.isServer) return null;
	if (typeof router.options.scrollRestoration === "function") {
		if (!router.options.scrollRestoration({ location: router.latestLocation })) return null;
	}
	const userKey = (router.options.getScrollRestorationKey || defaultGetScrollRestorationKey)(router.latestLocation);
	const resolvedKey = userKey !== defaultGetScrollRestorationKey(router.latestLocation) ? userKey : void 0;
	const restoreScrollOptions = {
		storageKey,
		shouldScrollRestoration: true
	};
	if (resolvedKey) restoreScrollOptions.key = resolvedKey;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScriptOnce, { children: `(${restoreScroll.toString()})(${JSON.stringify(restoreScrollOptions)})` });
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/Match.js
var Match = import_react.memo(function MatchImpl({ matchId }) {
	const router = useRouter();
	const matchState = useRouterState({
		select: (s) => {
			const match = s.matches.find((d) => d.id === matchId);
			invariant(match, `Could not find match for matchId "${matchId}". Please file an issue!`);
			return {
				routeId: match.routeId,
				ssr: match.ssr,
				_displayPending: match._displayPending
			};
		},
		structuralSharing: true
	});
	const route = router.routesById[matchState.routeId];
	const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent;
	const pendingElement = PendingComponent ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PendingComponent, {}) : null;
	const routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent;
	const routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch;
	const routeNotFoundComponent = route.isRoot ? route.options.notFoundComponent ?? router.options.notFoundRoute?.options.component : route.options.notFoundComponent;
	const resolvedNoSsr = matchState.ssr === false || matchState.ssr === "data-only";
	const ResolvedSuspenseBoundary = (!route.isRoot || route.options.wrapInSuspense || resolvedNoSsr) && (route.options.wrapInSuspense ?? PendingComponent ?? (route.options.errorComponent?.preload || resolvedNoSsr)) ? import_react.Suspense : SafeFragment;
	const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;
	const ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment;
	const resetKey = useRouterState({ select: (s) => s.loadedAt });
	const parentRouteId = useRouterState({ select: (s) => {
		const index = s.matches.findIndex((d) => d.id === matchId);
		return s.matches[index - 1]?.routeId;
	} });
	return /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(route.isRoot ? route.options.shellComponent ?? SafeFragment : SafeFragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(matchContext.Provider, {
		value: matchId,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResolvedSuspenseBoundary, {
			fallback: pendingElement,
			children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResolvedCatchBoundary, {
				getResetKey: () => resetKey,
				errorComponent: routeErrorComponent || ErrorComponent,
				onCatch: (error, errorInfo) => {
					if (isNotFound(error)) throw error;
					tiny_warning_esm_default(false, `Error in route match: ${matchId}`);
					routeOnCatch?.(error, errorInfo);
				},
				children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ResolvedNotFoundBoundary, {
					fallback: (error) => {
						if (!routeNotFoundComponent || error.routeId && error.routeId !== matchState.routeId || !error.routeId && !route.isRoot) throw error;
						return import_react.createElement(routeNotFoundComponent, error);
					},
					children: resolvedNoSsr || matchState._displayPending ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ClientOnly, {
						fallback: pendingElement,
						children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MatchInner, { matchId })
					}) : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MatchInner, { matchId })
				})
			})
		})
	}), parentRouteId === rootRouteId && router.options.scrollRestoration ? /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [/* @__PURE__ */ (0, import_jsx_runtime.jsx)(OnRendered, {}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(ScrollRestoration$1, {})] }) : null] });
});
function OnRendered() {
	const router = useRouter();
	const prevLocationRef = import_react.useRef(void 0);
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("script", {
		suppressHydrationWarning: true,
		ref: (el) => {
			if (el && (prevLocationRef.current === void 0 || prevLocationRef.current.href !== router.latestLocation.href)) {
				router.emit({
					type: "onRendered",
					...getLocationChangeInfo(router.state)
				});
				prevLocationRef.current = router.latestLocation;
			}
		}
	}, router.latestLocation.state.__TSR_key);
}
var MatchInner = import_react.memo(function MatchInnerImpl({ matchId }) {
	const router = useRouter();
	const { match, key, routeId } = useRouterState({
		select: (s) => {
			const match2 = s.matches.find((d) => d.id === matchId);
			const routeId2 = match2.routeId;
			const remountDeps = (router.routesById[routeId2].options.remountDeps ?? router.options.defaultRemountDeps)?.({
				routeId: routeId2,
				loaderDeps: match2.loaderDeps,
				params: match2._strictParams,
				search: match2._strictSearch
			});
			return {
				key: remountDeps ? JSON.stringify(remountDeps) : void 0,
				routeId: routeId2,
				match: {
					id: match2.id,
					status: match2.status,
					error: match2.error,
					_forcePending: match2._forcePending,
					_displayPending: match2._displayPending
				}
			};
		},
		structuralSharing: true
	});
	const route = router.routesById[routeId];
	const out = import_react.useMemo(() => {
		const Comp = route.options.component ?? router.options.defaultComponent;
		if (Comp) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Comp, {}, key);
		return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Outlet, {});
	}, [
		key,
		route.options.component,
		router.options.defaultComponent
	]);
	if (match._displayPending) throw router.getMatch(match.id)?._nonReactive.displayPendingPromise;
	if (match._forcePending) throw router.getMatch(match.id)?._nonReactive.minPendingPromise;
	if (match.status === "pending") {
		const pendingMinMs = route.options.pendingMinMs ?? router.options.defaultPendingMinMs;
		if (pendingMinMs) {
			const routerMatch = router.getMatch(match.id);
			if (routerMatch && !routerMatch._nonReactive.minPendingPromise) {
				if (!router.isServer) {
					const minPendingPromise = createControlledPromise();
					routerMatch._nonReactive.minPendingPromise = minPendingPromise;
					setTimeout(() => {
						minPendingPromise.resolve();
						routerMatch._nonReactive.minPendingPromise = void 0;
					}, pendingMinMs);
				}
			}
		}
		throw router.getMatch(match.id)?._nonReactive.loadPromise;
	}
	if (match.status === "notFound") {
		invariant(isNotFound(match.error), "Expected a notFound error");
		return renderRouteNotFound(router, route, match.error);
	}
	if (match.status === "redirected") {
		invariant(isRedirect(match.error), "Expected a redirect error");
		throw router.getMatch(match.id)?._nonReactive.loadPromise;
	}
	if (match.status === "error") {
		if (router.isServer) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)((route.options.errorComponent ?? router.options.defaultErrorComponent) || ErrorComponent, {
			error: match.error,
			reset: void 0,
			info: { componentStack: "" }
		});
		throw match.error;
	}
	return out;
});
var Outlet = import_react.memo(function OutletImpl() {
	const router = useRouter();
	const matchId = import_react.useContext(matchContext);
	const routeId = useRouterState({ select: (s) => s.matches.find((d) => d.id === matchId)?.routeId });
	const route = router.routesById[routeId];
	const parentGlobalNotFound = useRouterState({ select: (s) => {
		const parentMatch = s.matches.find((d) => d.id === matchId);
		invariant(parentMatch, `Could not find parent match for matchId "${matchId}"`);
		return parentMatch.globalNotFound;
	} });
	const childMatchId = useRouterState({ select: (s) => {
		const matches = s.matches;
		return matches[matches.findIndex((d) => d.id === matchId) + 1]?.id;
	} });
	const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(router.options.defaultPendingComponent, {}) : null;
	if (parentGlobalNotFound) return renderRouteNotFound(router, route, void 0);
	if (!childMatchId) return null;
	const nextMatch = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Match, { matchId: childMatchId });
	if (matchId === rootRouteId) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_react.Suspense, {
		fallback: pendingElement,
		children: nextMatch
	});
	return nextMatch;
});

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/Matches.js
function Matches() {
	const router = useRouter();
	const PendingComponent = router.routesById[rootRouteId].options.pendingComponent ?? router.options.defaultPendingComponent;
	const pendingElement = PendingComponent ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(PendingComponent, {}) : null;
	const inner = /* @__PURE__ */ (0, import_jsx_runtime.jsxs)(router.isServer || typeof document !== "undefined" && router.ssr ? SafeFragment : import_react.Suspense, {
		fallback: pendingElement,
		children: [!router.isServer && /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Transitioner, {}), /* @__PURE__ */ (0, import_jsx_runtime.jsx)(MatchesInner, {})]
	});
	return router.options.InnerWrap ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(router.options.InnerWrap, { children: inner }) : inner;
}
function MatchesInner() {
	const router = useRouter();
	const matchId = useRouterState({ select: (s) => {
		return s.matches[0]?.id;
	} });
	const resetKey = useRouterState({ select: (s) => s.loadedAt });
	const matchComponent = matchId ? /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Match, { matchId }) : null;
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(matchContext.Provider, {
		value: matchId,
		children: router.options.disableGlobalCatchBoundary ? matchComponent : /* @__PURE__ */ (0, import_jsx_runtime.jsx)(CatchBoundary, {
			getResetKey: () => resetKey,
			errorComponent: ErrorComponent,
			onCatch: (error) => {
				tiny_warning_esm_default(false, `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`);
				tiny_warning_esm_default(false, error.message || error.toString());
			},
			children: matchComponent
		})
	});
}
function useMatchRoute() {
	const router = useRouter();
	useRouterState({
		select: (s) => [
			s.location.href,
			s.resolvedLocation?.href,
			s.status
		],
		structuralSharing: true
	});
	return import_react.useCallback((opts) => {
		const { pending, caseSensitive, fuzzy, includeSearch,...rest } = opts;
		return router.matchRoute(rest, {
			pending,
			caseSensitive,
			fuzzy,
			includeSearch
		});
	}, [router]);
}
function MatchRoute(props) {
	const params = useMatchRoute()(props);
	if (typeof props.children === "function") return props.children(params);
	return params ? props.children : null;
}
function useMatches(opts) {
	return useRouterState({
		select: (state) => {
			const matches = state.matches;
			return opts?.select ? opts.select(matches) : matches;
		},
		structuralSharing: opts?.structuralSharing
	});
}
function useParentMatches(opts) {
	const contextMatchId = import_react.useContext(matchContext);
	return useMatches({
		select: (matches) => {
			matches = matches.slice(0, matches.findIndex((d) => d.id === contextMatchId));
			return opts?.select ? opts.select(matches) : matches;
		},
		structuralSharing: opts?.structuralSharing
	});
}
function useChildMatches(opts) {
	const contextMatchId = import_react.useContext(matchContext);
	return useMatches({
		select: (matches) => {
			matches = matches.slice(matches.findIndex((d) => d.id === contextMatchId) + 1);
			return opts?.select ? opts.select(matches) : matches;
		},
		structuralSharing: opts?.structuralSharing
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/router.js
var createRouter = (options) => {
	return new Router(options);
};
var Router = class extends RouterCore {
	constructor(options) {
		super(options);
	}
};
if (typeof globalThis !== "undefined") {
	globalThis.createFileRoute = createFileRoute;
	globalThis.createLazyFileRoute = createLazyFileRoute;
} else if (typeof window !== "undefined") {
	window.createFileRoute = createFileRoute;
	window.createLazyFileRoute = createLazyFileRoute;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/RouterProvider.js
function RouterContextProvider({ router, children,...rest }) {
	if (Object.keys(rest).length > 0) router.update({
		...router.options,
		...rest,
		context: {
			...router.options.context,
			...rest.context
		}
	});
	const provider = /* @__PURE__ */ (0, import_jsx_runtime.jsx)(getRouterContext().Provider, {
		value: router,
		children
	});
	if (router.options.Wrap) return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(router.options.Wrap, { children: provider });
	return provider;
}
function RouterProvider({ router,...rest }) {
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(RouterContextProvider, {
		router,
		...rest,
		children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Matches, {})
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/ScrollRestoration.js
function useScrollRestoration() {
	setupScrollRestoration(useRouter(), true);
}
function ScrollRestoration(_props) {
	useScrollRestoration();
	console.warn("The ScrollRestoration component is deprecated. Use createRouter's `scrollRestoration` option instead.");
	return null;
}
function useElementScrollRestoration(options) {
	useScrollRestoration();
	const router = useRouter();
	const getKey = options.getKey || defaultGetScrollRestorationKey;
	let elementSelector = "";
	if (options.id) elementSelector = `[data-scroll-restoration-id="${options.id}"]`;
	else {
		const element = options.getElement?.();
		if (!element) return;
		elementSelector = element instanceof Window ? "window" : getCssSelector(element);
	}
	const restoreKey = getKey(router.latestLocation);
	return (scrollRestorationCache?.state[restoreKey])?.[elementSelector];
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useBlocker.js
function _resolveBlockerOpts(opts, condition) {
	if (opts === void 0) return {
		shouldBlockFn: () => true,
		withResolver: false
	};
	if ("shouldBlockFn" in opts) return opts;
	if (typeof opts === "function") {
		const shouldBlock2 = Boolean(condition ?? true);
		const _customBlockerFn2 = async () => {
			if (shouldBlock2) return await opts();
			return false;
		};
		return {
			shouldBlockFn: _customBlockerFn2,
			enableBeforeUnload: shouldBlock2,
			withResolver: false
		};
	}
	const shouldBlock = Boolean(opts.condition ?? true);
	const fn = opts.blockerFn;
	const _customBlockerFn = async () => {
		if (shouldBlock && fn !== void 0) return await fn();
		return shouldBlock;
	};
	return {
		shouldBlockFn: _customBlockerFn,
		enableBeforeUnload: shouldBlock,
		withResolver: fn === void 0
	};
}
function useBlocker(opts, condition) {
	const { shouldBlockFn, enableBeforeUnload = true, disabled = false, withResolver = false } = _resolveBlockerOpts(opts, condition);
	const router = useRouter();
	const { history } = router;
	const [resolver, setResolver] = import_react.useState({
		status: "idle",
		current: void 0,
		next: void 0,
		action: void 0,
		proceed: void 0,
		reset: void 0
	});
	import_react.useEffect(() => {
		const blockerFnComposed = async (blockerFnArgs) => {
			function getLocation(location) {
				const parsedLocation = router.parseLocation(location);
				const matchedRoutes = router.getMatchedRoutes(parsedLocation.pathname, void 0);
				if (matchedRoutes.foundRoute === void 0) throw new Error(`No route found for location ${location.href}`);
				return {
					routeId: matchedRoutes.foundRoute.id,
					fullPath: matchedRoutes.foundRoute.fullPath,
					pathname: parsedLocation.pathname,
					params: matchedRoutes.routeParams,
					search: parsedLocation.search
				};
			}
			const current = getLocation(blockerFnArgs.currentLocation);
			const next = getLocation(blockerFnArgs.nextLocation);
			const shouldBlock = await shouldBlockFn({
				action: blockerFnArgs.action,
				current,
				next
			});
			if (!withResolver) return shouldBlock;
			if (!shouldBlock) return false;
			const canNavigateAsync = await new Promise((resolve) => {
				setResolver({
					status: "blocked",
					current,
					next,
					action: blockerFnArgs.action,
					proceed: () => resolve(false),
					reset: () => resolve(true)
				});
			});
			setResolver({
				status: "idle",
				current: void 0,
				next: void 0,
				action: void 0,
				proceed: void 0,
				reset: void 0
			});
			return canNavigateAsync;
		};
		return disabled ? void 0 : history.block({
			blockerFn: blockerFnComposed,
			enableBeforeUnload
		});
	}, [
		shouldBlockFn,
		enableBeforeUnload,
		disabled,
		withResolver,
		history,
		router
	]);
	return resolver;
}
var _resolvePromptBlockerArgs = (props) => {
	if ("shouldBlockFn" in props) return { ...props };
	const shouldBlock = Boolean(props.condition ?? true);
	const fn = props.blockerFn;
	const _customBlockerFn = async () => {
		if (shouldBlock && fn !== void 0) return await fn();
		return shouldBlock;
	};
	return {
		shouldBlockFn: _customBlockerFn,
		enableBeforeUnload: shouldBlock,
		withResolver: fn === void 0
	};
};
function Block(opts) {
	const { children,...rest } = opts;
	const resolver = useBlocker(_resolvePromptBlockerArgs(rest));
	return children ? typeof children === "function" ? children(resolver) : children : null;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useRouteContext.js
function useRouteContext(opts) {
	return useMatch({
		...opts,
		select: (match) => opts.select ? opts.select(match.context) : match.context
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useLocation.js
function useLocation(opts) {
	return useRouterState({ select: (state) => opts?.select ? opts.select(state.location) : state.location });
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/useCanGoBack.js
function useCanGoBack() {
	return useRouterState({ select: (s) => s.location.state.__TSR_index !== 0 });
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/Asset.js
function Asset({ tag, attrs, children, nonce }) {
	switch (tag) {
		case "title": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("title", {
			...attrs,
			suppressHydrationWarning: true,
			children
		});
		case "meta": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("meta", {
			...attrs,
			suppressHydrationWarning: true
		});
		case "link": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("link", {
			...attrs,
			nonce,
			suppressHydrationWarning: true
		});
		case "style": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("style", {
			...attrs,
			dangerouslySetInnerHTML: { __html: children },
			nonce
		});
		case "script": return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(Script, {
			attrs,
			children
		});
		default: return null;
	}
}
function Script({ attrs, children }) {
	const router = useRouter();
	import_react.useEffect(() => {
		if (attrs?.src) {
			const normSrc = (() => {
				try {
					const base = document.baseURI || window.location.href;
					return new URL(attrs.src, base).href;
				} catch {
					return attrs.src;
				}
			})();
			if (Array.from(document.querySelectorAll("script[src]")).find((el) => el.src === normSrc)) return;
			const script = document.createElement("script");
			for (const [key, value] of Object.entries(attrs)) if (key !== "suppressHydrationWarning" && value !== void 0 && value !== false) script.setAttribute(key, typeof value === "boolean" ? "" : String(value));
			document.head.appendChild(script);
			return () => {
				if (script.parentNode) script.parentNode.removeChild(script);
			};
		}
		if (typeof children === "string") {
			const typeAttr = typeof attrs?.type === "string" ? attrs.type : "text/javascript";
			const nonceAttr = typeof attrs?.nonce === "string" ? attrs.nonce : void 0;
			if (Array.from(document.querySelectorAll("script:not([src])")).find((el) => {
				if (!(el instanceof HTMLScriptElement)) return false;
				const sType = el.getAttribute("type") ?? "text/javascript";
				const sNonce = el.getAttribute("nonce") ?? void 0;
				return el.textContent === children && sType === typeAttr && sNonce === nonceAttr;
			})) return;
			const script = document.createElement("script");
			script.textContent = children;
			if (attrs) {
				for (const [key, value] of Object.entries(attrs)) if (key !== "suppressHydrationWarning" && value !== void 0 && value !== false) script.setAttribute(key, typeof value === "boolean" ? "" : String(value));
			}
			document.head.appendChild(script);
			return () => {
				if (script.parentNode) script.parentNode.removeChild(script);
			};
		}
	}, [attrs, children]);
	if (!router.isServer) return null;
	if (attrs?.src && typeof attrs.src === "string") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("script", {
		...attrs,
		suppressHydrationWarning: true
	});
	if (typeof children === "string") return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("script", {
		...attrs,
		dangerouslySetInnerHTML: { __html: children },
		suppressHydrationWarning: true
	});
	return null;
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/HeadContent.js
var useTags = () => {
	const router = useRouter();
	const nonce = router.options.ssr?.nonce;
	const routeMeta = useRouterState({ select: (state) => {
		return state.matches.map((match) => match.meta).filter(Boolean);
	} });
	const meta = import_react.useMemo(() => {
		const resultMeta = [];
		const metaByAttribute = {};
		let title;
		for (let i = routeMeta.length - 1; i >= 0; i--) {
			const metas = routeMeta[i];
			for (let j = metas.length - 1; j >= 0; j--) {
				const m = metas[j];
				if (!m) continue;
				if (m.title) {
					if (!title) title = {
						tag: "title",
						children: m.title
					};
				} else {
					const attribute = m.name ?? m.property;
					if (attribute) if (metaByAttribute[attribute]) continue;
					else metaByAttribute[attribute] = true;
					resultMeta.push({
						tag: "meta",
						attrs: {
							...m,
							nonce
						}
					});
				}
			}
		}
		if (title) resultMeta.push(title);
		if (nonce) resultMeta.push({
			tag: "meta",
			attrs: {
				property: "csp-nonce",
				content: nonce
			}
		});
		resultMeta.reverse();
		return resultMeta;
	}, [routeMeta, nonce]);
	const links = useRouterState({
		select: (state) => {
			const constructed = state.matches.map((match) => match.links).filter(Boolean).flat(1).map((link) => ({
				tag: "link",
				attrs: {
					...link,
					nonce
				}
			}));
			const manifest = router.ssr?.manifest;
			const assets = state.matches.map((match) => manifest?.routes[match.routeId]?.assets ?? []).filter(Boolean).flat(1).filter((asset) => asset.tag === "link").map((asset) => ({
				tag: "link",
				attrs: {
					...asset.attrs,
					suppressHydrationWarning: true,
					nonce
				}
			}));
			return [...constructed, ...assets];
		},
		structuralSharing: true
	});
	const preloadMeta = useRouterState({
		select: (state) => {
			const preloadMeta2 = [];
			state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach((route) => router.ssr?.manifest?.routes[route.id]?.preloads?.filter(Boolean).forEach((preload) => {
				preloadMeta2.push({
					tag: "link",
					attrs: {
						rel: "modulepreload",
						href: preload,
						nonce
					}
				});
			}));
			return preloadMeta2;
		},
		structuralSharing: true
	});
	const styles = useRouterState({
		select: (state) => state.matches.map((match) => match.styles).flat(1).filter(Boolean).map(({ children,...attrs }) => ({
			tag: "style",
			attrs,
			children,
			nonce
		})),
		structuralSharing: true
	});
	const headScripts = useRouterState({
		select: (state) => state.matches.map((match) => match.headScripts).flat(1).filter(Boolean).map(({ children,...script }) => ({
			tag: "script",
			attrs: {
				...script,
				nonce
			},
			children
		})),
		structuralSharing: true
	});
	return uniqBy([
		...meta,
		...preloadMeta,
		...links,
		...styles,
		...headScripts
	], (d) => {
		return JSON.stringify(d);
	});
};
function HeadContent() {
	const tags = useTags();
	const nonce = useRouter().options.ssr?.nonce;
	return tags.map((tag) => /* @__PURE__ */ (0, import_react.createElement)(Asset, {
		...tag,
		key: `tsr-meta-${JSON.stringify(tag)}`,
		nonce
	}));
}
function uniqBy(arr, fn) {
	const seen = /* @__PURE__ */ new Set();
	return arr.filter((item) => {
		const key = fn(item);
		if (seen.has(key)) return false;
		seen.add(key);
		return true;
	});
}

//#endregion
//#region node_modules/@tanstack/react-router/dist/esm/Scripts.js
var Scripts = () => {
	const router = useRouter();
	const nonce = router.options.ssr?.nonce;
	const assetScripts = useRouterState({
		select: (state) => {
			const assetScripts2 = [];
			const manifest = router.ssr?.manifest;
			if (!manifest) return [];
			state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach((route) => manifest.routes[route.id]?.assets?.filter((d) => d.tag === "script").forEach((asset) => {
				assetScripts2.push({
					tag: "script",
					attrs: {
						...asset.attrs,
						nonce
					},
					children: asset.children
				});
			}));
			return assetScripts2;
		},
		structuralSharing: true
	});
	const { scripts } = useRouterState({
		select: (state) => ({ scripts: state.matches.map((match) => match.scripts).flat(1).filter(Boolean).map(({ children,...script }) => ({
			tag: "script",
			attrs: {
				...script,
				suppressHydrationWarning: true,
				nonce
			},
			children
		})) }),
		structuralSharing: true
	});
	return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: [...scripts, ...assetScripts].map((asset, i) => /* @__PURE__ */ (0, import_react.createElement)(Asset, {
		...asset,
		key: `tsr-scripts-${asset.tag}-${i}`
	})) });
};

//#endregion
export { useLoaderDeps as $, createFileRoute as A, stringifySearchWith as At, createRouteMask as B, ScriptOnce as C, composeRewrites as Ct, FileRoute as D, defaultParseSearch as Dt, lazyRouteComponent as E, redirect as Et, Route as F, createHistory as Ft, linkOptions as G, rootRouteWithContext as H, RouteApi as I, createMemoryHistory as It, useStableCallback as J, useLinkProps as K, createRootRoute as L, createLazyRoute as M, notFound as Mt, NotFoundRoute as N, createBrowserHistory as Nt, FileRouteLoader as O, defaultStringifySearch as Ot, RootRoute as P, createHashHistory as Pt, useParams as Q, createRootRouteWithContext as R, Outlet as S, lazyFn as St, DefaultGlobalNotFound as T, isRedirect as Tt, Link as U, getRouteApi as V, createLink as W, useNavigate as X, Navigate as Y, useSearch as Z, useChildMatches as _, defer as _t, useLocation as a, getRouterContext as at, useParentMatches as b, defaultSerializeError as bt, useBlocker as c, ErrorComponent as ct, RouterContextProvider as d, createSerializationAdapter as dt, useLoaderData as et, RouterProvider as f, retainSearchParams as ft, Matches as g, TSR_DEFERRED_PROMISE as gt, MatchRoute as h, isMatch as ht, useCanGoBack as i, useRouter as it, createLazyFileRoute as j, isNotFound as jt, LazyRoute as k, parseSearchWith as kt, ScrollRestoration as l, Await as lt, createRouter as m, createRouterConfig as mt, HeadContent as n, matchContext as nt, useRouteContext as o, ClientOnly as ot, Router as p, stripSearchParams as pt, useLayoutEffect as q, Asset as r, useRouterState as rt, Block as s, CatchBoundary as st, Scripts as t, useMatch as tt, useElementScrollRestoration as u, useAwaited as ut, useMatchRoute as v, PathParamError as vt, CatchNotFound as w, componentTypes as wt, Match as x, getInitialRouterState as xt, useMatches as y, SearchParamError as yt, createRoute as z };
//# sourceMappingURL=esm-Bje71nt3.js.map