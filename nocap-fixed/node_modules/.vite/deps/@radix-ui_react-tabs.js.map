{"version":3,"file":"@radix-ui_react-tabs.js","names":["createCollectionScope","useCollection","React","RovingFocusGroup.Root","RovingFocusGroup.Item"],"sources":["../../@radix-ui/react-collection/dist/index.mjs","../../@radix-ui/react-id/dist/index.mjs","../../@radix-ui/react-roving-focus/dist/index.mjs","../../@radix-ui/react-tabs/dist/index.mjs"],"sourcesContent":["\"use client\";\n\n// src/collection-legacy.tsx\nimport React from \"react\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createSlot } from \"@radix-ui/react-slot\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createCollection(name) {\n  const PROVIDER_NAME = name + \"CollectionProvider\";\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }\n  );\n  const CollectionProvider = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef(null);\n    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;\n    return /* @__PURE__ */ jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });\n  };\n  CollectionProvider.displayName = PROVIDER_NAME;\n  const COLLECTION_SLOT_NAME = name + \"CollectionSlot\";\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return /* @__PURE__ */ jsx(CollectionSlotImpl, { ref: composedRefs, children });\n    }\n  );\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n  const ITEM_SLOT_NAME = name + \"CollectionItemSlot\";\n  const ITEM_DATA_ATTR = \"data-radix-collection-item\";\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...itemData });\n        return () => void context.itemMap.delete(ref);\n      });\n      return /* @__PURE__ */ jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: \"\" }, ref: composedRefs, children });\n    }\n  );\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n  function useCollection(scope) {\n    const context = useCollectionContext(name + \"CollectionConsumer\", scope);\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current) - orderedNodes.indexOf(b.ref.current)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n    return getItems;\n  }\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope\n  ];\n}\n\n// src/collection.tsx\nimport React2 from \"react\";\nimport { createContextScope as createContextScope2 } from \"@radix-ui/react-context\";\nimport { useComposedRefs as useComposedRefs2 } from \"@radix-ui/react-compose-refs\";\nimport { createSlot as createSlot2 } from \"@radix-ui/react-slot\";\n\n// src/ordered-dictionary.ts\nvar __instanciated = /* @__PURE__ */ new WeakMap();\nvar OrderedDict = class _OrderedDict extends Map {\n  #keys;\n  constructor(entries) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n  set(key, value) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n  insert(index, key, value) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n    if (safeIndex === this.size || has && safeIndex === this.size - 1 || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n    const size = this.size + (has ? 0 : 1);\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n    const keys = [...this.#keys];\n    let nextValue;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i];\n        if (keys[i] === key) {\n          nextKey = keys[i + 1];\n        }\n        if (has) {\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1];\n        const currentValue = nextValue;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n  with(index, key, value) {\n    const copy = new _OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n  before(key) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return void 0;\n    }\n    return this.entryAt(index);\n  }\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key, newKey, value) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n  after(key) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return void 0;\n    }\n    return this.entryAt(index);\n  }\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key, newKey, value) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n  first() {\n    return this.entryAt(0);\n  }\n  last() {\n    return this.entryAt(-1);\n  }\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n  delete(key) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n  deleteAt(index) {\n    const key = this.keyAt(index);\n    if (key !== void 0) {\n      return this.delete(key);\n    }\n    return false;\n  }\n  at(index) {\n    const key = at(this.#keys, index);\n    if (key !== void 0) {\n      return this.get(key);\n    }\n  }\n  entryAt(index) {\n    const key = at(this.#keys, index);\n    if (key !== void 0) {\n      return [key, this.get(key)];\n    }\n  }\n  indexOf(key) {\n    return this.#keys.indexOf(key);\n  }\n  keyAt(index) {\n    return at(this.#keys, index);\n  }\n  from(key, offset) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return void 0;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n  keyFrom(key, offset) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return void 0;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n  find(predicate, thisArg) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return void 0;\n  }\n  findIndex(predicate, thisArg) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n  filter(predicate, thisArg) {\n    const entries = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new _OrderedDict(entries);\n  }\n  map(callbackfn, thisArg) {\n    const entries = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new _OrderedDict(entries);\n  }\n  reduce(...args) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0);\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n  reduceRight(...args) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1);\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index);\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n  toSorted(compareFn) {\n    const entries = [...this.entries()].sort(compareFn);\n    return new _OrderedDict(entries);\n  }\n  toReversed() {\n    const reversed = new _OrderedDict();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index);\n      const element = this.get(key);\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n  toSpliced(...args) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new _OrderedDict(entries);\n  }\n  slice(start, end) {\n    const result = new _OrderedDict();\n    let stop = this.size - 1;\n    if (start === void 0) {\n      return result;\n    }\n    if (start < 0) {\n      start = start + this.size;\n    }\n    if (end !== void 0 && end > 0) {\n      stop = end - 1;\n    }\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index);\n      const element = this.get(key);\n      result.set(key, element);\n    }\n    return result;\n  }\n  every(predicate, thisArg) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n  some(predicate, thisArg) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n};\nfunction at(array, index) {\n  if (\"at\" in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? void 0 : array[actualIndex];\n}\nfunction toSafeIndex(array, index) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\nfunction toSafeInteger(number) {\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n\n// src/collection.tsx\nimport { jsx as jsx2 } from \"react/jsx-runtime\";\nfunction createCollection2(name) {\n  const PROVIDER_NAME = name + \"CollectionProvider\";\n  const [createCollectionContext, createCollectionScope] = createContextScope2(PROVIDER_NAME);\n  const [CollectionContextProvider, useCollectionContext] = createCollectionContext(\n    PROVIDER_NAME,\n    {\n      collectionElement: null,\n      collectionRef: { current: null },\n      collectionRefObject: { current: null },\n      itemMap: new OrderedDict(),\n      setItemMap: () => void 0\n    }\n  );\n  const CollectionProvider = ({ state, ...props }) => {\n    return state ? /* @__PURE__ */ jsx2(CollectionProviderImpl, { ...props, state }) : /* @__PURE__ */ jsx2(CollectionInit, { ...props });\n  };\n  CollectionProvider.displayName = PROVIDER_NAME;\n  const CollectionInit = (props) => {\n    const state = useInitCollection();\n    return /* @__PURE__ */ jsx2(CollectionProviderImpl, { ...props, state });\n  };\n  CollectionInit.displayName = PROVIDER_NAME + \"Init\";\n  const CollectionProviderImpl = (props) => {\n    const { scope, children, state } = props;\n    const ref = React2.useRef(null);\n    const [collectionElement, setCollectionElement] = React2.useState(\n      null\n    );\n    const composeRefs = useComposedRefs2(ref, setCollectionElement);\n    const [itemMap, setItemMap] = state;\n    React2.useEffect(() => {\n      if (!collectionElement) return;\n      const observer = getChildListObserver(() => {\n      });\n      observer.observe(collectionElement, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }, [collectionElement]);\n    return /* @__PURE__ */ jsx2(\n      CollectionContextProvider,\n      {\n        scope,\n        itemMap,\n        setItemMap,\n        collectionRef: composeRefs,\n        collectionRefObject: ref,\n        collectionElement,\n        children\n      }\n    );\n  };\n  CollectionProviderImpl.displayName = PROVIDER_NAME + \"Impl\";\n  const COLLECTION_SLOT_NAME = name + \"CollectionSlot\";\n  const CollectionSlotImpl = createSlot2(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React2.forwardRef(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs2(forwardedRef, context.collectionRef);\n      return /* @__PURE__ */ jsx2(CollectionSlotImpl, { ref: composedRefs, children });\n    }\n  );\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n  const ITEM_SLOT_NAME = name + \"CollectionItemSlot\";\n  const ITEM_DATA_ATTR = \"data-radix-collection-item\";\n  const CollectionItemSlotImpl = createSlot2(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React2.forwardRef(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React2.useRef(null);\n      const [element, setElement] = React2.useState(null);\n      const composedRefs = useComposedRefs2(forwardedRef, ref, setElement);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n      const { setItemMap } = context;\n      const itemDataRef = React2.useRef(itemData);\n      if (!shallowEqual(itemDataRef.current, itemData)) {\n        itemDataRef.current = itemData;\n      }\n      const memoizedItemData = itemDataRef.current;\n      React2.useEffect(() => {\n        const itemData2 = memoizedItemData;\n        setItemMap((map) => {\n          if (!element) {\n            return map;\n          }\n          if (!map.has(element)) {\n            map.set(element, { ...itemData2, element });\n            return map.toSorted(sortByDocumentPosition);\n          }\n          return map.set(element, { ...itemData2, element }).toSorted(sortByDocumentPosition);\n        });\n        return () => {\n          setItemMap((map) => {\n            if (!element || !map.has(element)) {\n              return map;\n            }\n            map.delete(element);\n            return new OrderedDict(map);\n          });\n        };\n      }, [element, memoizedItemData, setItemMap]);\n      return /* @__PURE__ */ jsx2(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: \"\" }, ref: composedRefs, children });\n    }\n  );\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n  function useInitCollection() {\n    return React2.useState(new OrderedDict());\n  }\n  function useCollection(scope) {\n    const { itemMap } = useCollectionContext(name + \"CollectionConsumer\", scope);\n    return itemMap;\n  }\n  const functions = {\n    createCollectionScope,\n    useCollection,\n    useInitCollection\n  };\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    functions\n  ];\n}\nfunction shallowEqual(a, b) {\n  if (a === b) return true;\n  if (typeof a !== \"object\" || typeof b !== \"object\") return false;\n  if (a == null || b == null) return false;\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (a[key] !== b[key]) return false;\n  }\n  return true;\n}\nfunction isElementPreceding(a, b) {\n  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);\n}\nfunction sortByDocumentPosition(a, b) {\n  return !a[1].element || !b[1].element ? 0 : isElementPreceding(a[1].element, b[1].element) ? -1 : 1;\n}\nfunction getChildListObserver(callback) {\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === \"childList\") {\n        callback();\n        return;\n      }\n    }\n  });\n  return observer;\n}\nexport {\n  createCollection,\n  createCollection2 as unstable_createCollection\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/id/src/id.tsx\nimport * as React from \"react\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nvar useReactId = React[\" useId \".trim().toString()] || (() => void 0);\nvar count = 0;\nfunction useId(deterministicId) {\n  const [id, setId] = React.useState(useReactId());\n  useLayoutEffect(() => {\n    if (!deterministicId) setId((reactId) => reactId ?? String(count++));\n  }, [deterministicId]);\n  return deterministicId || (id ? `radix-${id}` : \"\");\n}\nexport {\n  useId\n};\n//# sourceMappingURL=index.mjs.map\n","\"use client\";\n\n// src/roving-focus-group.tsx\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useId } from \"@radix-ui/react-id\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { jsx } from \"react/jsx-runtime\";\nvar ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar EVENT_OPTIONS = { bubbles: false, cancelable: true };\nvar GROUP_NAME = \"RovingFocusGroup\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);\nvar [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\nvar [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);\nvar RovingFocusGroup = React.forwardRef(\n  (props, forwardedRef) => {\n    return /* @__PURE__ */ jsx(Collection.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx(Collection.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });\n  }\n);\nRovingFocusGroup.displayName = GROUP_NAME;\nvar RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n  return /* @__PURE__ */ jsx(\n    RovingFocusProvider,\n    {\n      scope: __scopeRovingFocusGroup,\n      orientation,\n      dir: direction,\n      loop,\n      currentTabStopId,\n      onItemFocus: React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      ),\n      onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),\n      onFocusableItemAdd: React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      ),\n      onFocusableItemRemove: React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      ),\n      children: /* @__PURE__ */ jsx(\n        Primitive.div,\n        {\n          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n          \"data-orientation\": orientation,\n          ...groupProps,\n          ref: composedRefs,\n          style: { outline: \"none\", ...props.style },\n          onMouseDown: composeEventHandlers(props.onMouseDown, () => {\n            isClickFocusRef.current = true;\n          }),\n          onFocus: composeEventHandlers(props.onFocus, (event) => {\n            const isKeyboardFocus = !isClickFocusRef.current;\n            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n              event.currentTarget.dispatchEvent(entryFocusEvent);\n              if (!entryFocusEvent.defaultPrevented) {\n                const items = getItems().filter((item) => item.focusable);\n                const activeItem = items.find((item) => item.active);\n                const currentItem = items.find((item) => item.id === currentTabStopId);\n                const candidateItems = [activeItem, currentItem, ...items].filter(\n                  Boolean\n                );\n                const candidateNodes = candidateItems.map((item) => item.ref.current);\n                focusFirst(candidateNodes, preventScrollOnEntryFocus);\n              }\n            }\n            isClickFocusRef.current = false;\n          }),\n          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))\n        }\n      )\n    }\n  );\n});\nvar ITEM_NAME = \"RovingFocusGroupItem\";\nvar RovingFocusGroupItem = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n    return /* @__PURE__ */ jsx(\n      Collection.ItemSlot,\n      {\n        scope: __scopeRovingFocusGroup,\n        id,\n        focusable,\n        active,\n        children: /* @__PURE__ */ jsx(\n          Primitive.span,\n          {\n            tabIndex: isCurrentTabStop ? 0 : -1,\n            \"data-orientation\": context.orientation,\n            ...itemProps,\n            ref: forwardedRef,\n            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {\n              if (!focusable) event.preventDefault();\n              else context.onItemFocus(id);\n            }),\n            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),\n            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {\n              if (event.key === \"Tab\" && event.shiftKey) {\n                context.onItemShiftTab();\n                return;\n              }\n              if (event.target !== event.currentTarget) return;\n              const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n              if (focusIntent !== void 0) {\n                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n                event.preventDefault();\n                const items = getItems().filter((item) => item.focusable);\n                let candidateNodes = items.map((item) => item.ref.current);\n                if (focusIntent === \"last\") candidateNodes.reverse();\n                else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n                  if (focusIntent === \"prev\") candidateNodes.reverse();\n                  const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                  candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n                }\n                setTimeout(() => focusFirst(candidateNodes));\n              }\n            }),\n            children: typeof children === \"function\" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children\n          }\n        )\n      }\n    );\n  }\n);\nRovingFocusGroupItem.displayName = ITEM_NAME;\nvar MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\nfunction getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\") return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\nfunction getFocusIntent(event, orientation, dir) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key)) return void 0;\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key)) return void 0;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\nfunction focusFirst(candidates, preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\nvar Root = RovingFocusGroup;\nvar Item = RovingFocusGroupItem;\nexport {\n  Item,\n  Root,\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  createRovingFocusGroupScope\n};\n//# sourceMappingURL=index.mjs.map\n","\"use client\";\n\n// src/tabs.tsx\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { createRovingFocusGroupScope } from \"@radix-ui/react-roving-focus\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport * as RovingFocusGroup from \"@radix-ui/react-roving-focus\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useId } from \"@radix-ui/react-id\";\nimport { jsx } from \"react/jsx-runtime\";\nvar TABS_NAME = \"Tabs\";\nvar [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [\n  createRovingFocusGroupScope\n]);\nvar useRovingFocusGroupScope = createRovingFocusGroupScope();\nvar [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);\nvar Tabs = React.forwardRef(\n  (props, forwardedRef) => {\n    const {\n      __scopeTabs,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      orientation = \"horizontal\",\n      dir,\n      activationMode = \"automatic\",\n      ...tabsProps\n    } = props;\n    const direction = useDirection(dir);\n    const [value, setValue] = useControllableState({\n      prop: valueProp,\n      onChange: onValueChange,\n      defaultProp: defaultValue ?? \"\",\n      caller: TABS_NAME\n    });\n    return /* @__PURE__ */ jsx(\n      TabsProvider,\n      {\n        scope: __scopeTabs,\n        baseId: useId(),\n        value,\n        onValueChange: setValue,\n        orientation,\n        dir: direction,\n        activationMode,\n        children: /* @__PURE__ */ jsx(\n          Primitive.div,\n          {\n            dir: direction,\n            \"data-orientation\": orientation,\n            ...tabsProps,\n            ref: forwardedRef\n          }\n        )\n      }\n    );\n  }\n);\nTabs.displayName = TABS_NAME;\nvar TAB_LIST_NAME = \"TabsList\";\nvar TabsList = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeTabs, loop = true, ...listProps } = props;\n    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n    return /* @__PURE__ */ jsx(\n      RovingFocusGroup.Root,\n      {\n        asChild: true,\n        ...rovingFocusGroupScope,\n        orientation: context.orientation,\n        dir: context.dir,\n        loop,\n        children: /* @__PURE__ */ jsx(\n          Primitive.div,\n          {\n            role: \"tablist\",\n            \"aria-orientation\": context.orientation,\n            ...listProps,\n            ref: forwardedRef\n          }\n        )\n      }\n    );\n  }\n);\nTabsList.displayName = TAB_LIST_NAME;\nvar TRIGGER_NAME = \"TabsTrigger\";\nvar TabsTrigger = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;\n    const context = useTabsContext(TRIGGER_NAME, __scopeTabs);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n    const triggerId = makeTriggerId(context.baseId, value);\n    const contentId = makeContentId(context.baseId, value);\n    const isSelected = value === context.value;\n    return /* @__PURE__ */ jsx(\n      RovingFocusGroup.Item,\n      {\n        asChild: true,\n        ...rovingFocusGroupScope,\n        focusable: !disabled,\n        active: isSelected,\n        children: /* @__PURE__ */ jsx(\n          Primitive.button,\n          {\n            type: \"button\",\n            role: \"tab\",\n            \"aria-selected\": isSelected,\n            \"aria-controls\": contentId,\n            \"data-state\": isSelected ? \"active\" : \"inactive\",\n            \"data-disabled\": disabled ? \"\" : void 0,\n            disabled,\n            id: triggerId,\n            ...triggerProps,\n            ref: forwardedRef,\n            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {\n              if (!disabled && event.button === 0 && event.ctrlKey === false) {\n                context.onValueChange(value);\n              } else {\n                event.preventDefault();\n              }\n            }),\n            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {\n              if ([\" \", \"Enter\"].includes(event.key)) context.onValueChange(value);\n            }),\n            onFocus: composeEventHandlers(props.onFocus, () => {\n              const isAutomaticActivation = context.activationMode !== \"manual\";\n              if (!isSelected && !disabled && isAutomaticActivation) {\n                context.onValueChange(value);\n              }\n            })\n          }\n        )\n      }\n    );\n  }\n);\nTabsTrigger.displayName = TRIGGER_NAME;\nvar CONTENT_NAME = \"TabsContent\";\nvar TabsContent = React.forwardRef(\n  (props, forwardedRef) => {\n    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;\n    const context = useTabsContext(CONTENT_NAME, __scopeTabs);\n    const triggerId = makeTriggerId(context.baseId, value);\n    const contentId = makeContentId(context.baseId, value);\n    const isSelected = value === context.value;\n    const isMountAnimationPreventedRef = React.useRef(isSelected);\n    React.useEffect(() => {\n      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);\n      return () => cancelAnimationFrame(rAF);\n    }, []);\n    return /* @__PURE__ */ jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsx(\n      Primitive.div,\n      {\n        \"data-state\": isSelected ? \"active\" : \"inactive\",\n        \"data-orientation\": context.orientation,\n        role: \"tabpanel\",\n        \"aria-labelledby\": triggerId,\n        hidden: !present,\n        id: contentId,\n        tabIndex: 0,\n        ...contentProps,\n        ref: forwardedRef,\n        style: {\n          ...props.style,\n          animationDuration: isMountAnimationPreventedRef.current ? \"0s\" : void 0\n        },\n        children: present && children\n      }\n    ) });\n  }\n);\nTabsContent.displayName = CONTENT_NAME;\nfunction makeTriggerId(baseId, value) {\n  return `${baseId}-trigger-${value}`;\n}\nfunction makeContentId(baseId, value) {\n  return `${baseId}-content-${value}`;\n}\nvar Root2 = Tabs;\nvar List = TabsList;\nvar Trigger = TabsTrigger;\nvar Content = TabsContent;\nexport {\n  Content,\n  List,\n  Root2 as Root,\n  Tabs,\n  TabsContent,\n  TabsList,\n  TabsTrigger,\n  Trigger,\n  createTabsScope\n};\n//# sourceMappingURL=index.mjs.map\n"],"mappings":"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"}