{"version":3,"file":"root-Cjj8VExB.js","names":["prefix"],"sources":["../../@tanstack/router-core/dist/esm/utils.js","../../tiny-invariant/dist/esm/tiny-invariant.js","../../@tanstack/router-core/dist/esm/path.js","../../@tanstack/router-core/dist/esm/root.js"],"sourcesContent":["function last(arr) {\n  return arr[arr.length - 1];\n}\nfunction isFunction(d) {\n  return typeof d === \"function\";\n}\nfunction functionalUpdate(updater, previous) {\n  if (isFunction(updater)) {\n    return updater(previous);\n  }\n  return updater;\n}\nconst hasOwn = Object.prototype.hasOwnProperty;\nfunction replaceEqualDeep(prev, _next) {\n  if (prev === _next) {\n    return prev;\n  }\n  const next = _next;\n  const array = isPlainArray(prev) && isPlainArray(next);\n  if (!array && !(isPlainObject(prev) && isPlainObject(next))) return next;\n  const prevItems = array ? prev : getEnumerableOwnKeys(prev);\n  if (!prevItems) return next;\n  const nextItems = array ? next : getEnumerableOwnKeys(next);\n  if (!nextItems) return next;\n  const prevSize = prevItems.length;\n  const nextSize = nextItems.length;\n  const copy = array ? new Array(nextSize) : {};\n  let equalItems = 0;\n  for (let i = 0; i < nextSize; i++) {\n    const key = array ? i : nextItems[i];\n    const p = prev[key];\n    const n = next[key];\n    if (p === n) {\n      copy[key] = p;\n      if (array ? i < prevSize : hasOwn.call(prev, key)) equalItems++;\n      continue;\n    }\n    if (p === null || n === null || typeof p !== \"object\" || typeof n !== \"object\") {\n      copy[key] = n;\n      continue;\n    }\n    const v = replaceEqualDeep(p, n);\n    copy[key] = v;\n    if (v === p) equalItems++;\n  }\n  return prevSize === nextSize && equalItems === prevSize ? prev : copy;\n}\nfunction getEnumerableOwnKeys(o) {\n  const keys = [];\n  const names = Object.getOwnPropertyNames(o);\n  for (const name of names) {\n    if (!Object.prototype.propertyIsEnumerable.call(o, name)) return false;\n    keys.push(name);\n  }\n  const symbols = Object.getOwnPropertySymbols(o);\n  for (const symbol of symbols) {\n    if (!Object.prototype.propertyIsEnumerable.call(o, symbol)) return false;\n    keys.push(symbol);\n  }\n  return keys;\n}\nfunction isPlainObject(o) {\n  if (!hasObjectPrototype(o)) {\n    return false;\n  }\n  const ctor = o.constructor;\n  if (typeof ctor === \"undefined\") {\n    return true;\n  }\n  const prot = ctor.prototype;\n  if (!hasObjectPrototype(prot)) {\n    return false;\n  }\n  if (!prot.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  return true;\n}\nfunction hasObjectPrototype(o) {\n  return Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction isPlainArray(value) {\n  return Array.isArray(value) && value.length === Object.keys(value).length;\n}\nfunction deepEqual(a, b, opts) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    for (let i = 0, l = a.length; i < l; i++) {\n      if (!deepEqual(a[i], b[i], opts)) return false;\n    }\n    return true;\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const ignoreUndefined = opts?.ignoreUndefined ?? true;\n    if (opts?.partial) {\n      for (const k in b) {\n        if (!ignoreUndefined || b[k] !== void 0) {\n          if (!deepEqual(a[k], b[k], opts)) return false;\n        }\n      }\n      return true;\n    }\n    let aCount = 0;\n    if (!ignoreUndefined) {\n      aCount = Object.keys(a).length;\n    } else {\n      for (const k in a) {\n        if (a[k] !== void 0) aCount++;\n      }\n    }\n    let bCount = 0;\n    for (const k in b) {\n      if (!ignoreUndefined || b[k] !== void 0) {\n        bCount++;\n        if (bCount > aCount || !deepEqual(a[k], b[k], opts)) return false;\n      }\n    }\n    return aCount === bCount;\n  }\n  return false;\n}\nfunction createControlledPromise(onResolve) {\n  let resolveLoadPromise;\n  let rejectLoadPromise;\n  const controlledPromise = new Promise((resolve, reject) => {\n    resolveLoadPromise = resolve;\n    rejectLoadPromise = reject;\n  });\n  controlledPromise.status = \"pending\";\n  controlledPromise.resolve = (value) => {\n    controlledPromise.status = \"resolved\";\n    controlledPromise.value = value;\n    resolveLoadPromise(value);\n    onResolve?.(value);\n  };\n  controlledPromise.reject = (e) => {\n    controlledPromise.status = \"rejected\";\n    rejectLoadPromise(e);\n  };\n  return controlledPromise;\n}\nfunction isModuleNotFoundError(error) {\n  if (typeof error?.message !== \"string\") return false;\n  return error.message.startsWith(\"Failed to fetch dynamically imported module\") || error.message.startsWith(\"error loading dynamically imported module\") || error.message.startsWith(\"Importing a module script failed\");\n}\nfunction isPromise(value) {\n  return Boolean(\n    value && typeof value === \"object\" && typeof value.then === \"function\"\n  );\n}\nfunction findLast(array, predicate) {\n  for (let i = array.length - 1; i >= 0; i--) {\n    const item = array[i];\n    if (predicate(item)) return item;\n  }\n  return void 0;\n}\nexport {\n  createControlledPromise,\n  deepEqual,\n  findLast,\n  functionalUpdate,\n  isModuleNotFoundError,\n  isPlainArray,\n  isPlainObject,\n  isPromise,\n  last,\n  replaceEqualDeep\n};\n//# sourceMappingURL=utils.js.map\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","import { last } from \"./utils.js\";\nconst SEGMENT_TYPE_PATHNAME = 0;\nconst SEGMENT_TYPE_PARAM = 1;\nconst SEGMENT_TYPE_WILDCARD = 2;\nconst SEGMENT_TYPE_OPTIONAL_PARAM = 3;\nfunction joinPaths(paths) {\n  return cleanPath(\n    paths.filter((val) => {\n      return val !== void 0;\n    }).join(\"/\")\n  );\n}\nfunction cleanPath(path) {\n  return path.replace(/\\/{2,}/g, \"/\");\n}\nfunction trimPathLeft(path) {\n  return path === \"/\" ? path : path.replace(/^\\/{1,}/, \"\");\n}\nfunction trimPathRight(path) {\n  return path === \"/\" ? path : path.replace(/\\/{1,}$/, \"\");\n}\nfunction trimPath(path) {\n  return trimPathRight(trimPathLeft(path));\n}\nfunction removeTrailingSlash(value, basepath) {\n  if (value?.endsWith(\"/\") && value !== \"/\" && value !== `${basepath}/`) {\n    return value.slice(0, -1);\n  }\n  return value;\n}\nfunction exactPathTest(pathName1, pathName2, basepath) {\n  return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);\n}\nfunction segmentToString(segment) {\n  const { type, value } = segment;\n  if (type === SEGMENT_TYPE_PATHNAME) {\n    return value;\n  }\n  const { prefixSegment, suffixSegment } = segment;\n  if (type === SEGMENT_TYPE_PARAM) {\n    const param = value.substring(1);\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$${param}}${suffixSegment}`;\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$${param}}`;\n    } else if (suffixSegment) {\n      return `{$${param}}${suffixSegment}`;\n    }\n  }\n  if (type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n    const param = value.substring(1);\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{-$${param}}${suffixSegment}`;\n    } else if (prefixSegment) {\n      return `${prefixSegment}{-$${param}}`;\n    } else if (suffixSegment) {\n      return `{-$${param}}${suffixSegment}`;\n    }\n    return `{-$${param}}`;\n  }\n  if (type === SEGMENT_TYPE_WILDCARD) {\n    if (prefixSegment && suffixSegment) {\n      return `${prefixSegment}{$}${suffixSegment}`;\n    } else if (prefixSegment) {\n      return `${prefixSegment}{$}`;\n    } else if (suffixSegment) {\n      return `{$}${suffixSegment}`;\n    }\n  }\n  return value;\n}\nfunction resolvePath({\n  base,\n  to,\n  trailingSlash = \"never\",\n  parseCache\n}) {\n  let baseSegments = parsePathname(base, parseCache).slice();\n  const toSegments = parsePathname(to, parseCache);\n  if (baseSegments.length > 1 && last(baseSegments)?.value === \"/\") {\n    baseSegments.pop();\n  }\n  for (let index = 0, length = toSegments.length; index < length; index++) {\n    const toSegment = toSegments[index];\n    const value = toSegment.value;\n    if (value === \"/\") {\n      if (!index) {\n        baseSegments = [toSegment];\n      } else if (index === length - 1) {\n        baseSegments.push(toSegment);\n      } else ;\n    } else if (value === \"..\") {\n      baseSegments.pop();\n    } else if (value === \".\") ;\n    else {\n      baseSegments.push(toSegment);\n    }\n  }\n  if (baseSegments.length > 1) {\n    if (last(baseSegments).value === \"/\") {\n      if (trailingSlash === \"never\") {\n        baseSegments.pop();\n      }\n    } else if (trailingSlash === \"always\") {\n      baseSegments.push({ type: SEGMENT_TYPE_PATHNAME, value: \"/\" });\n    }\n  }\n  const segmentValues = baseSegments.map(segmentToString);\n  const joined = joinPaths(segmentValues);\n  return joined;\n}\nconst parsePathname = (pathname, cache) => {\n  if (!pathname) return [];\n  const cached = cache?.get(pathname);\n  if (cached) return cached;\n  const parsed = baseParsePathname(pathname);\n  cache?.set(pathname, parsed);\n  return parsed;\n};\nconst PARAM_RE = /^\\$.{1,}$/;\nconst PARAM_W_CURLY_BRACES_RE = /^(.*?)\\{(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/;\nconst OPTIONAL_PARAM_W_CURLY_BRACES_RE = /^(.*?)\\{-(\\$[a-zA-Z_$][a-zA-Z0-9_$]*)\\}(.*)$/;\nconst WILDCARD_RE = /^\\$$/;\nconst WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\\{\\$\\}(.*)$/;\nfunction baseParsePathname(pathname) {\n  pathname = cleanPath(pathname);\n  const segments = [];\n  if (pathname.slice(0, 1) === \"/\") {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: \"/\"\n    });\n  }\n  if (!pathname) {\n    return segments;\n  }\n  const split = pathname.split(\"/\").filter(Boolean);\n  segments.push(\n    ...split.map((part) => {\n      const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE);\n      if (wildcardBracesMatch) {\n        const prefix = wildcardBracesMatch[1];\n        const suffix = wildcardBracesMatch[2];\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: \"$\",\n          prefixSegment: prefix || void 0,\n          suffixSegment: suffix || void 0\n        };\n      }\n      const optionalParamBracesMatch = part.match(\n        OPTIONAL_PARAM_W_CURLY_BRACES_RE\n      );\n      if (optionalParamBracesMatch) {\n        const prefix = optionalParamBracesMatch[1];\n        const paramName = optionalParamBracesMatch[2];\n        const suffix = optionalParamBracesMatch[3];\n        return {\n          type: SEGMENT_TYPE_OPTIONAL_PARAM,\n          value: paramName,\n          // Now just $paramName (no prefix)\n          prefixSegment: prefix || void 0,\n          suffixSegment: suffix || void 0\n        };\n      }\n      const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE);\n      if (paramBracesMatch) {\n        const prefix = paramBracesMatch[1];\n        const paramName = paramBracesMatch[2];\n        const suffix = paramBracesMatch[3];\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: \"\" + paramName,\n          prefixSegment: prefix || void 0,\n          suffixSegment: suffix || void 0\n        };\n      }\n      if (PARAM_RE.test(part)) {\n        const paramName = part.substring(1);\n        return {\n          type: SEGMENT_TYPE_PARAM,\n          value: \"$\" + paramName,\n          prefixSegment: void 0,\n          suffixSegment: void 0\n        };\n      }\n      if (WILDCARD_RE.test(part)) {\n        return {\n          type: SEGMENT_TYPE_WILDCARD,\n          value: \"$\",\n          prefixSegment: void 0,\n          suffixSegment: void 0\n        };\n      }\n      return {\n        type: SEGMENT_TYPE_PATHNAME,\n        value: part.includes(\"%25\") ? part.split(\"%25\").map((segment) => decodeURI(segment)).join(\"%25\") : decodeURI(part)\n      };\n    })\n  );\n  if (pathname.slice(-1) === \"/\") {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: SEGMENT_TYPE_PATHNAME,\n      value: \"/\"\n    });\n  }\n  return segments;\n}\nfunction interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap,\n  parseCache\n}) {\n  const interpolatedPathSegments = parsePathname(path, parseCache);\n  function encodeParam(key) {\n    const value = params[key];\n    const isValueString = typeof value === \"string\";\n    if (key === \"*\" || key === \"_splat\") {\n      return isValueString ? encodeURI(value) : value;\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value;\n    }\n  }\n  let isMissingParams = false;\n  const usedParams = {};\n  const interpolatedPath = joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === SEGMENT_TYPE_PATHNAME) {\n        return segment.value;\n      }\n      if (segment.type === SEGMENT_TYPE_WILDCARD) {\n        usedParams._splat = params._splat;\n        usedParams[\"*\"] = params._splat;\n        const segmentPrefix = segment.prefixSegment || \"\";\n        const segmentSuffix = segment.suffixSegment || \"\";\n        if (!params._splat) {\n          isMissingParams = true;\n          if (leaveWildcards) {\n            return `${segmentPrefix}${segment.value}${segmentSuffix}`;\n          }\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`;\n          }\n          return void 0;\n        }\n        const value = encodeParam(\"_splat\");\n        if (leaveWildcards) {\n          return `${segmentPrefix}${segment.value}${value ?? \"\"}${segmentSuffix}`;\n        }\n        return `${segmentPrefix}${value}${segmentSuffix}`;\n      }\n      if (segment.type === SEGMENT_TYPE_PARAM) {\n        const key = segment.value.substring(1);\n        if (!isMissingParams && !(key in params)) {\n          isMissingParams = true;\n        }\n        usedParams[key] = params[key];\n        const segmentPrefix = segment.prefixSegment || \"\";\n        const segmentSuffix = segment.suffixSegment || \"\";\n        if (leaveParams) {\n          const value = encodeParam(segment.value);\n          return `${segmentPrefix}${segment.value}${value ?? \"\"}${segmentSuffix}`;\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? \"undefined\"}${segmentSuffix}`;\n      }\n      if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        const key = segment.value.substring(1);\n        const segmentPrefix = segment.prefixSegment || \"\";\n        const segmentSuffix = segment.suffixSegment || \"\";\n        if (!(key in params) || params[key] == null) {\n          if (leaveWildcards) {\n            return `${segmentPrefix}${key}${segmentSuffix}`;\n          }\n          if (segmentPrefix || segmentSuffix) {\n            return `${segmentPrefix}${segmentSuffix}`;\n          }\n          return void 0;\n        }\n        usedParams[key] = params[key];\n        if (leaveParams) {\n          const value = encodeParam(segment.value);\n          return `${segmentPrefix}${segment.value}${value ?? \"\"}${segmentSuffix}`;\n        }\n        if (leaveWildcards) {\n          return `${segmentPrefix}${key}${encodeParam(key) ?? \"\"}${segmentSuffix}`;\n        }\n        return `${segmentPrefix}${encodeParam(key) ?? \"\"}${segmentSuffix}`;\n      }\n      return segment.value;\n    })\n  );\n  return { usedParams, interpolatedPath, isMissingParams };\n}\nfunction encodePathParam(value, decodeCharMap) {\n  let encoded = encodeURIComponent(value);\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char);\n    }\n  }\n  return encoded;\n}\nfunction matchPathname(currentPathname, matchLocation, parseCache) {\n  const pathParams = matchByPath(currentPathname, matchLocation, parseCache);\n  if (matchLocation.to && !pathParams) {\n    return;\n  }\n  return pathParams ?? {};\n}\nfunction matchByPath(from, {\n  to,\n  fuzzy,\n  caseSensitive\n}, parseCache) {\n  const stringTo = to;\n  const baseSegments = parsePathname(\n    from.startsWith(\"/\") ? from : `/${from}`,\n    parseCache\n  );\n  const routeSegments = parsePathname(\n    stringTo.startsWith(\"/\") ? stringTo : `/${stringTo}`,\n    parseCache\n  );\n  const params = {};\n  const result = isMatch(\n    baseSegments,\n    routeSegments,\n    params,\n    fuzzy,\n    caseSensitive\n  );\n  return result ? params : void 0;\n}\nfunction isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {\n  let baseIndex = 0;\n  let routeIndex = 0;\n  while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {\n    const baseSegment = baseSegments[baseIndex];\n    const routeSegment = routeSegments[routeIndex];\n    if (routeSegment) {\n      if (routeSegment.type === SEGMENT_TYPE_WILDCARD) {\n        const remainingBaseSegments = baseSegments.slice(baseIndex);\n        let _splat;\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          if (!baseSegment) return false;\n          const prefix = routeSegment.prefixSegment || \"\";\n          const suffix = routeSegment.suffixSegment || \"\";\n          const baseValue = baseSegment.value;\n          if (\"prefixSegment\" in routeSegment) {\n            if (!baseValue.startsWith(prefix)) {\n              return false;\n            }\n          }\n          if (\"suffixSegment\" in routeSegment) {\n            if (!baseSegments[baseSegments.length - 1]?.value.endsWith(suffix)) {\n              return false;\n            }\n          }\n          let rejoinedSplat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value))\n          );\n          if (prefix && rejoinedSplat.startsWith(prefix)) {\n            rejoinedSplat = rejoinedSplat.slice(prefix.length);\n          }\n          if (suffix && rejoinedSplat.endsWith(suffix)) {\n            rejoinedSplat = rejoinedSplat.slice(\n              0,\n              rejoinedSplat.length - suffix.length\n            );\n          }\n          _splat = rejoinedSplat;\n        } else {\n          _splat = decodeURI(\n            joinPaths(remainingBaseSegments.map((d) => d.value))\n          );\n        }\n        params[\"*\"] = _splat;\n        params[\"_splat\"] = _splat;\n        return true;\n      }\n      if (routeSegment.type === SEGMENT_TYPE_PATHNAME) {\n        if (routeSegment.value === \"/\" && !baseSegment?.value) {\n          routeIndex++;\n          continue;\n        }\n        if (baseSegment) {\n          if (caseSensitive) {\n            if (routeSegment.value !== baseSegment.value) {\n              return false;\n            }\n          } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {\n            return false;\n          }\n          baseIndex++;\n          routeIndex++;\n          continue;\n        } else {\n          return false;\n        }\n      }\n      if (routeSegment.type === SEGMENT_TYPE_PARAM) {\n        if (!baseSegment) {\n          return false;\n        }\n        if (baseSegment.value === \"/\") {\n          return false;\n        }\n        let _paramValue = \"\";\n        let matched = false;\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || \"\";\n          const suffix = routeSegment.suffixSegment || \"\";\n          const baseValue = baseSegment.value;\n          if (prefix && !baseValue.startsWith(prefix)) {\n            return false;\n          }\n          if (suffix && !baseValue.endsWith(suffix)) {\n            return false;\n          }\n          let paramValue = baseValue;\n          if (prefix && paramValue.startsWith(prefix)) {\n            paramValue = paramValue.slice(prefix.length);\n          }\n          if (suffix && paramValue.endsWith(suffix)) {\n            paramValue = paramValue.slice(0, paramValue.length - suffix.length);\n          }\n          _paramValue = decodeURIComponent(paramValue);\n          matched = true;\n        } else {\n          _paramValue = decodeURIComponent(baseSegment.value);\n          matched = true;\n        }\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue;\n          baseIndex++;\n        }\n        routeIndex++;\n        continue;\n      }\n      if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        if (!baseSegment) {\n          routeIndex++;\n          continue;\n        }\n        if (baseSegment.value === \"/\") {\n          routeIndex++;\n          continue;\n        }\n        let _paramValue = \"\";\n        let matched = false;\n        if (routeSegment.prefixSegment || routeSegment.suffixSegment) {\n          const prefix = routeSegment.prefixSegment || \"\";\n          const suffix = routeSegment.suffixSegment || \"\";\n          const baseValue = baseSegment.value;\n          if ((!prefix || baseValue.startsWith(prefix)) && (!suffix || baseValue.endsWith(suffix))) {\n            let paramValue = baseValue;\n            if (prefix && paramValue.startsWith(prefix)) {\n              paramValue = paramValue.slice(prefix.length);\n            }\n            if (suffix && paramValue.endsWith(suffix)) {\n              paramValue = paramValue.slice(\n                0,\n                paramValue.length - suffix.length\n              );\n            }\n            _paramValue = decodeURIComponent(paramValue);\n            matched = true;\n          }\n        } else {\n          let shouldMatchOptional = true;\n          for (let lookAhead = routeIndex + 1; lookAhead < routeSegments.length; lookAhead++) {\n            const futureRouteSegment = routeSegments[lookAhead];\n            if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME && futureRouteSegment.value === baseSegment.value) {\n              shouldMatchOptional = false;\n              break;\n            }\n            if (futureRouteSegment?.type === SEGMENT_TYPE_PARAM || futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD) {\n              if (baseSegments.length < routeSegments.length) {\n                shouldMatchOptional = false;\n              }\n              break;\n            }\n          }\n          if (shouldMatchOptional) {\n            _paramValue = decodeURIComponent(baseSegment.value);\n            matched = true;\n          }\n        }\n        if (matched) {\n          params[routeSegment.value.substring(1)] = _paramValue;\n          baseIndex++;\n        }\n        routeIndex++;\n        continue;\n      }\n    }\n    if (baseIndex < baseSegments.length && routeIndex >= routeSegments.length) {\n      params[\"**\"] = joinPaths(\n        baseSegments.slice(baseIndex).map((d) => d.value)\n      );\n      return !!fuzzy && routeSegments[routeSegments.length - 1]?.value !== \"/\";\n    }\n    if (routeIndex < routeSegments.length && baseIndex >= baseSegments.length) {\n      for (let i = routeIndex; i < routeSegments.length; i++) {\n        if (routeSegments[i]?.type !== SEGMENT_TYPE_OPTIONAL_PARAM) {\n          return false;\n        }\n      }\n      break;\n    }\n    break;\n  }\n  return true;\n}\nexport {\n  SEGMENT_TYPE_OPTIONAL_PARAM,\n  SEGMENT_TYPE_PARAM,\n  SEGMENT_TYPE_PATHNAME,\n  SEGMENT_TYPE_WILDCARD,\n  cleanPath,\n  exactPathTest,\n  interpolatePath,\n  joinPaths,\n  matchByPath,\n  matchPathname,\n  parsePathname,\n  removeTrailingSlash,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight\n};\n//# sourceMappingURL=path.js.map\n","const rootRouteId = \"__root__\";\nexport {\n  rootRouteId\n};\n//# sourceMappingURL=root.js.map\n"],"mappings":"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"}