//#region node_modules/@tanstack/router-core/dist/esm/utils.js
function last(arr) {
	return arr[arr.length - 1];
}
function isFunction(d) {
	return typeof d === "function";
}
function functionalUpdate(updater, previous) {
	if (isFunction(updater)) return updater(previous);
	return updater;
}
var hasOwn = Object.prototype.hasOwnProperty;
function replaceEqualDeep(prev, _next) {
	if (prev === _next) return prev;
	const next = _next;
	const array = isPlainArray(prev) && isPlainArray(next);
	if (!array && !(isPlainObject(prev) && isPlainObject(next))) return next;
	const prevItems = array ? prev : getEnumerableOwnKeys(prev);
	if (!prevItems) return next;
	const nextItems = array ? next : getEnumerableOwnKeys(next);
	if (!nextItems) return next;
	const prevSize = prevItems.length;
	const nextSize = nextItems.length;
	const copy = array ? new Array(nextSize) : {};
	let equalItems = 0;
	for (let i = 0; i < nextSize; i++) {
		const key = array ? i : nextItems[i];
		const p = prev[key];
		const n = next[key];
		if (p === n) {
			copy[key] = p;
			if (array ? i < prevSize : hasOwn.call(prev, key)) equalItems++;
			continue;
		}
		if (p === null || n === null || typeof p !== "object" || typeof n !== "object") {
			copy[key] = n;
			continue;
		}
		const v = replaceEqualDeep(p, n);
		copy[key] = v;
		if (v === p) equalItems++;
	}
	return prevSize === nextSize && equalItems === prevSize ? prev : copy;
}
function getEnumerableOwnKeys(o) {
	const keys = [];
	const names = Object.getOwnPropertyNames(o);
	for (const name of names) {
		if (!Object.prototype.propertyIsEnumerable.call(o, name)) return false;
		keys.push(name);
	}
	const symbols = Object.getOwnPropertySymbols(o);
	for (const symbol of symbols) {
		if (!Object.prototype.propertyIsEnumerable.call(o, symbol)) return false;
		keys.push(symbol);
	}
	return keys;
}
function isPlainObject(o) {
	if (!hasObjectPrototype(o)) return false;
	const ctor = o.constructor;
	if (typeof ctor === "undefined") return true;
	const prot = ctor.prototype;
	if (!hasObjectPrototype(prot)) return false;
	if (!prot.hasOwnProperty("isPrototypeOf")) return false;
	return true;
}
function hasObjectPrototype(o) {
	return Object.prototype.toString.call(o) === "[object Object]";
}
function isPlainArray(value) {
	return Array.isArray(value) && value.length === Object.keys(value).length;
}
function deepEqual(a, b, opts) {
	if (a === b) return true;
	if (typeof a !== typeof b) return false;
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) return false;
		for (let i = 0, l = a.length; i < l; i++) if (!deepEqual(a[i], b[i], opts)) return false;
		return true;
	}
	if (isPlainObject(a) && isPlainObject(b)) {
		const ignoreUndefined = opts?.ignoreUndefined ?? true;
		if (opts?.partial) {
			for (const k in b) if (!ignoreUndefined || b[k] !== void 0) {
				if (!deepEqual(a[k], b[k], opts)) return false;
			}
			return true;
		}
		let aCount = 0;
		if (!ignoreUndefined) aCount = Object.keys(a).length;
		else for (const k in a) if (a[k] !== void 0) aCount++;
		let bCount = 0;
		for (const k in b) if (!ignoreUndefined || b[k] !== void 0) {
			bCount++;
			if (bCount > aCount || !deepEqual(a[k], b[k], opts)) return false;
		}
		return aCount === bCount;
	}
	return false;
}
function createControlledPromise(onResolve) {
	let resolveLoadPromise;
	let rejectLoadPromise;
	const controlledPromise = new Promise((resolve, reject) => {
		resolveLoadPromise = resolve;
		rejectLoadPromise = reject;
	});
	controlledPromise.status = "pending";
	controlledPromise.resolve = (value) => {
		controlledPromise.status = "resolved";
		controlledPromise.value = value;
		resolveLoadPromise(value);
		onResolve?.(value);
	};
	controlledPromise.reject = (e) => {
		controlledPromise.status = "rejected";
		rejectLoadPromise(e);
	};
	return controlledPromise;
}
function isModuleNotFoundError(error) {
	if (typeof error?.message !== "string") return false;
	return error.message.startsWith("Failed to fetch dynamically imported module") || error.message.startsWith("error loading dynamically imported module") || error.message.startsWith("Importing a module script failed");
}
function isPromise(value) {
	return Boolean(value && typeof value === "object" && typeof value.then === "function");
}
function findLast(array, predicate) {
	for (let i = array.length - 1; i >= 0; i--) {
		const item = array[i];
		if (predicate(item)) return item;
	}
}

//#endregion
//#region node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
	if (condition) return;
	if (isProduction) throw new Error(prefix);
	var provided = typeof message === "function" ? message() : message;
	var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
	throw new Error(value);
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/path.js
var SEGMENT_TYPE_PATHNAME = 0;
var SEGMENT_TYPE_PARAM = 1;
var SEGMENT_TYPE_WILDCARD = 2;
var SEGMENT_TYPE_OPTIONAL_PARAM = 3;
function joinPaths(paths) {
	return cleanPath(paths.filter((val) => {
		return val !== void 0;
	}).join("/"));
}
function cleanPath(path) {
	return path.replace(/\/{2,}/g, "/");
}
function trimPathLeft(path) {
	return path === "/" ? path : path.replace(/^\/{1,}/, "");
}
function trimPathRight(path) {
	return path === "/" ? path : path.replace(/\/{1,}$/, "");
}
function trimPath(path) {
	return trimPathRight(trimPathLeft(path));
}
function removeTrailingSlash(value, basepath) {
	if (value?.endsWith("/") && value !== "/" && value !== `${basepath}/`) return value.slice(0, -1);
	return value;
}
function exactPathTest(pathName1, pathName2, basepath) {
	return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);
}
function segmentToString(segment) {
	const { type, value } = segment;
	if (type === SEGMENT_TYPE_PATHNAME) return value;
	const { prefixSegment, suffixSegment } = segment;
	if (type === SEGMENT_TYPE_PARAM) {
		const param = value.substring(1);
		if (prefixSegment && suffixSegment) return `${prefixSegment}{$${param}}${suffixSegment}`;
		else if (prefixSegment) return `${prefixSegment}{$${param}}`;
		else if (suffixSegment) return `{$${param}}${suffixSegment}`;
	}
	if (type === SEGMENT_TYPE_OPTIONAL_PARAM) {
		const param = value.substring(1);
		if (prefixSegment && suffixSegment) return `${prefixSegment}{-$${param}}${suffixSegment}`;
		else if (prefixSegment) return `${prefixSegment}{-$${param}}`;
		else if (suffixSegment) return `{-$${param}}${suffixSegment}`;
		return `{-$${param}}`;
	}
	if (type === SEGMENT_TYPE_WILDCARD) {
		if (prefixSegment && suffixSegment) return `${prefixSegment}{$}${suffixSegment}`;
		else if (prefixSegment) return `${prefixSegment}{$}`;
		else if (suffixSegment) return `{$}${suffixSegment}`;
	}
	return value;
}
function resolvePath({ base, to, trailingSlash = "never", parseCache }) {
	let baseSegments = parsePathname(base, parseCache).slice();
	const toSegments = parsePathname(to, parseCache);
	if (baseSegments.length > 1 && last(baseSegments)?.value === "/") baseSegments.pop();
	for (let index = 0, length = toSegments.length; index < length; index++) {
		const toSegment = toSegments[index];
		const value = toSegment.value;
		if (value === "/") {
			if (!index) baseSegments = [toSegment];
			else if (index === length - 1) baseSegments.push(toSegment);
		} else if (value === "..") baseSegments.pop();
		else if (value === ".");
		else baseSegments.push(toSegment);
	}
	if (baseSegments.length > 1) {
		if (last(baseSegments).value === "/") {
			if (trailingSlash === "never") baseSegments.pop();
		} else if (trailingSlash === "always") baseSegments.push({
			type: SEGMENT_TYPE_PATHNAME,
			value: "/"
		});
	}
	return joinPaths(baseSegments.map(segmentToString));
}
var parsePathname = (pathname, cache) => {
	if (!pathname) return [];
	const cached = cache?.get(pathname);
	if (cached) return cached;
	const parsed = baseParsePathname(pathname);
	cache?.set(pathname, parsed);
	return parsed;
};
var PARAM_RE = /^\$.{1,}$/;
var PARAM_W_CURLY_BRACES_RE = /^(.*?)\{(\$[a-zA-Z_$][a-zA-Z0-9_$]*)\}(.*)$/;
var OPTIONAL_PARAM_W_CURLY_BRACES_RE = /^(.*?)\{-(\$[a-zA-Z_$][a-zA-Z0-9_$]*)\}(.*)$/;
var WILDCARD_RE = /^\$$/;
var WILDCARD_W_CURLY_BRACES_RE = /^(.*?)\{\$\}(.*)$/;
function baseParsePathname(pathname) {
	pathname = cleanPath(pathname);
	const segments = [];
	if (pathname.slice(0, 1) === "/") {
		pathname = pathname.substring(1);
		segments.push({
			type: SEGMENT_TYPE_PATHNAME,
			value: "/"
		});
	}
	if (!pathname) return segments;
	const split = pathname.split("/").filter(Boolean);
	segments.push(...split.map((part) => {
		const wildcardBracesMatch = part.match(WILDCARD_W_CURLY_BRACES_RE);
		if (wildcardBracesMatch) {
			const prefix$1 = wildcardBracesMatch[1];
			const suffix = wildcardBracesMatch[2];
			return {
				type: SEGMENT_TYPE_WILDCARD,
				value: "$",
				prefixSegment: prefix$1 || void 0,
				suffixSegment: suffix || void 0
			};
		}
		const optionalParamBracesMatch = part.match(OPTIONAL_PARAM_W_CURLY_BRACES_RE);
		if (optionalParamBracesMatch) {
			const prefix$1 = optionalParamBracesMatch[1];
			const paramName = optionalParamBracesMatch[2];
			const suffix = optionalParamBracesMatch[3];
			return {
				type: SEGMENT_TYPE_OPTIONAL_PARAM,
				value: paramName,
				prefixSegment: prefix$1 || void 0,
				suffixSegment: suffix || void 0
			};
		}
		const paramBracesMatch = part.match(PARAM_W_CURLY_BRACES_RE);
		if (paramBracesMatch) {
			const prefix$1 = paramBracesMatch[1];
			const paramName = paramBracesMatch[2];
			const suffix = paramBracesMatch[3];
			return {
				type: SEGMENT_TYPE_PARAM,
				value: "" + paramName,
				prefixSegment: prefix$1 || void 0,
				suffixSegment: suffix || void 0
			};
		}
		if (PARAM_RE.test(part)) return {
			type: SEGMENT_TYPE_PARAM,
			value: "$" + part.substring(1),
			prefixSegment: void 0,
			suffixSegment: void 0
		};
		if (WILDCARD_RE.test(part)) return {
			type: SEGMENT_TYPE_WILDCARD,
			value: "$",
			prefixSegment: void 0,
			suffixSegment: void 0
		};
		return {
			type: SEGMENT_TYPE_PATHNAME,
			value: part.includes("%25") ? part.split("%25").map((segment) => decodeURI(segment)).join("%25") : decodeURI(part)
		};
	}));
	if (pathname.slice(-1) === "/") {
		pathname = pathname.substring(1);
		segments.push({
			type: SEGMENT_TYPE_PATHNAME,
			value: "/"
		});
	}
	return segments;
}
function interpolatePath({ path, params, leaveWildcards, leaveParams, decodeCharMap, parseCache }) {
	const interpolatedPathSegments = parsePathname(path, parseCache);
	function encodeParam(key) {
		const value = params[key];
		const isValueString = typeof value === "string";
		if (key === "*" || key === "_splat") return isValueString ? encodeURI(value) : value;
		else return isValueString ? encodePathParam(value, decodeCharMap) : value;
	}
	let isMissingParams = false;
	const usedParams = {};
	return {
		usedParams,
		interpolatedPath: joinPaths(interpolatedPathSegments.map((segment) => {
			if (segment.type === SEGMENT_TYPE_PATHNAME) return segment.value;
			if (segment.type === SEGMENT_TYPE_WILDCARD) {
				usedParams._splat = params._splat;
				usedParams["*"] = params._splat;
				const segmentPrefix = segment.prefixSegment || "";
				const segmentSuffix = segment.suffixSegment || "";
				if (!params._splat) {
					isMissingParams = true;
					if (leaveWildcards) return `${segmentPrefix}${segment.value}${segmentSuffix}`;
					if (segmentPrefix || segmentSuffix) return `${segmentPrefix}${segmentSuffix}`;
					return;
				}
				const value = encodeParam("_splat");
				if (leaveWildcards) return `${segmentPrefix}${segment.value}${value ?? ""}${segmentSuffix}`;
				return `${segmentPrefix}${value}${segmentSuffix}`;
			}
			if (segment.type === SEGMENT_TYPE_PARAM) {
				const key = segment.value.substring(1);
				if (!isMissingParams && !(key in params)) isMissingParams = true;
				usedParams[key] = params[key];
				const segmentPrefix = segment.prefixSegment || "";
				const segmentSuffix = segment.suffixSegment || "";
				if (leaveParams) {
					const value = encodeParam(segment.value);
					return `${segmentPrefix}${segment.value}${value ?? ""}${segmentSuffix}`;
				}
				return `${segmentPrefix}${encodeParam(key) ?? "undefined"}${segmentSuffix}`;
			}
			if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
				const key = segment.value.substring(1);
				const segmentPrefix = segment.prefixSegment || "";
				const segmentSuffix = segment.suffixSegment || "";
				if (!(key in params) || params[key] == null) {
					if (leaveWildcards) return `${segmentPrefix}${key}${segmentSuffix}`;
					if (segmentPrefix || segmentSuffix) return `${segmentPrefix}${segmentSuffix}`;
					return;
				}
				usedParams[key] = params[key];
				if (leaveParams) {
					const value = encodeParam(segment.value);
					return `${segmentPrefix}${segment.value}${value ?? ""}${segmentSuffix}`;
				}
				if (leaveWildcards) return `${segmentPrefix}${key}${encodeParam(key) ?? ""}${segmentSuffix}`;
				return `${segmentPrefix}${encodeParam(key) ?? ""}${segmentSuffix}`;
			}
			return segment.value;
		})),
		isMissingParams
	};
}
function encodePathParam(value, decodeCharMap) {
	let encoded = encodeURIComponent(value);
	if (decodeCharMap) for (const [encodedChar, char] of decodeCharMap) encoded = encoded.replaceAll(encodedChar, char);
	return encoded;
}
function matchPathname(currentPathname, matchLocation, parseCache) {
	const pathParams = matchByPath(currentPathname, matchLocation, parseCache);
	if (matchLocation.to && !pathParams) return;
	return pathParams ?? {};
}
function matchByPath(from, { to, fuzzy, caseSensitive }, parseCache) {
	const stringTo = to;
	const baseSegments = parsePathname(from.startsWith("/") ? from : `/${from}`, parseCache);
	const routeSegments = parsePathname(stringTo.startsWith("/") ? stringTo : `/${stringTo}`, parseCache);
	const params = {};
	return isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) ? params : void 0;
}
function isMatch(baseSegments, routeSegments, params, fuzzy, caseSensitive) {
	let baseIndex = 0;
	let routeIndex = 0;
	while (baseIndex < baseSegments.length || routeIndex < routeSegments.length) {
		const baseSegment = baseSegments[baseIndex];
		const routeSegment = routeSegments[routeIndex];
		if (routeSegment) {
			if (routeSegment.type === SEGMENT_TYPE_WILDCARD) {
				const remainingBaseSegments = baseSegments.slice(baseIndex);
				let _splat;
				if (routeSegment.prefixSegment || routeSegment.suffixSegment) {
					if (!baseSegment) return false;
					const prefix$1 = routeSegment.prefixSegment || "";
					const suffix = routeSegment.suffixSegment || "";
					const baseValue = baseSegment.value;
					if ("prefixSegment" in routeSegment) {
						if (!baseValue.startsWith(prefix$1)) return false;
					}
					if ("suffixSegment" in routeSegment) {
						if (!baseSegments[baseSegments.length - 1]?.value.endsWith(suffix)) return false;
					}
					let rejoinedSplat = decodeURI(joinPaths(remainingBaseSegments.map((d) => d.value)));
					if (prefix$1 && rejoinedSplat.startsWith(prefix$1)) rejoinedSplat = rejoinedSplat.slice(prefix$1.length);
					if (suffix && rejoinedSplat.endsWith(suffix)) rejoinedSplat = rejoinedSplat.slice(0, rejoinedSplat.length - suffix.length);
					_splat = rejoinedSplat;
				} else _splat = decodeURI(joinPaths(remainingBaseSegments.map((d) => d.value)));
				params["*"] = _splat;
				params["_splat"] = _splat;
				return true;
			}
			if (routeSegment.type === SEGMENT_TYPE_PATHNAME) {
				if (routeSegment.value === "/" && !baseSegment?.value) {
					routeIndex++;
					continue;
				}
				if (baseSegment) {
					if (caseSensitive) {
						if (routeSegment.value !== baseSegment.value) return false;
					} else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) return false;
					baseIndex++;
					routeIndex++;
					continue;
				} else return false;
			}
			if (routeSegment.type === SEGMENT_TYPE_PARAM) {
				if (!baseSegment) return false;
				if (baseSegment.value === "/") return false;
				let _paramValue = "";
				let matched = false;
				if (routeSegment.prefixSegment || routeSegment.suffixSegment) {
					const prefix$1 = routeSegment.prefixSegment || "";
					const suffix = routeSegment.suffixSegment || "";
					const baseValue = baseSegment.value;
					if (prefix$1 && !baseValue.startsWith(prefix$1)) return false;
					if (suffix && !baseValue.endsWith(suffix)) return false;
					let paramValue = baseValue;
					if (prefix$1 && paramValue.startsWith(prefix$1)) paramValue = paramValue.slice(prefix$1.length);
					if (suffix && paramValue.endsWith(suffix)) paramValue = paramValue.slice(0, paramValue.length - suffix.length);
					_paramValue = decodeURIComponent(paramValue);
					matched = true;
				} else {
					_paramValue = decodeURIComponent(baseSegment.value);
					matched = true;
				}
				if (matched) {
					params[routeSegment.value.substring(1)] = _paramValue;
					baseIndex++;
				}
				routeIndex++;
				continue;
			}
			if (routeSegment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {
				if (!baseSegment) {
					routeIndex++;
					continue;
				}
				if (baseSegment.value === "/") {
					routeIndex++;
					continue;
				}
				let _paramValue = "";
				let matched = false;
				if (routeSegment.prefixSegment || routeSegment.suffixSegment) {
					const prefix$1 = routeSegment.prefixSegment || "";
					const suffix = routeSegment.suffixSegment || "";
					const baseValue = baseSegment.value;
					if ((!prefix$1 || baseValue.startsWith(prefix$1)) && (!suffix || baseValue.endsWith(suffix))) {
						let paramValue = baseValue;
						if (prefix$1 && paramValue.startsWith(prefix$1)) paramValue = paramValue.slice(prefix$1.length);
						if (suffix && paramValue.endsWith(suffix)) paramValue = paramValue.slice(0, paramValue.length - suffix.length);
						_paramValue = decodeURIComponent(paramValue);
						matched = true;
					}
				} else {
					let shouldMatchOptional = true;
					for (let lookAhead = routeIndex + 1; lookAhead < routeSegments.length; lookAhead++) {
						const futureRouteSegment = routeSegments[lookAhead];
						if (futureRouteSegment?.type === SEGMENT_TYPE_PATHNAME && futureRouteSegment.value === baseSegment.value) {
							shouldMatchOptional = false;
							break;
						}
						if (futureRouteSegment?.type === SEGMENT_TYPE_PARAM || futureRouteSegment?.type === SEGMENT_TYPE_WILDCARD) {
							if (baseSegments.length < routeSegments.length) shouldMatchOptional = false;
							break;
						}
					}
					if (shouldMatchOptional) {
						_paramValue = decodeURIComponent(baseSegment.value);
						matched = true;
					}
				}
				if (matched) {
					params[routeSegment.value.substring(1)] = _paramValue;
					baseIndex++;
				}
				routeIndex++;
				continue;
			}
		}
		if (baseIndex < baseSegments.length && routeIndex >= routeSegments.length) {
			params["**"] = joinPaths(baseSegments.slice(baseIndex).map((d) => d.value));
			return !!fuzzy && routeSegments[routeSegments.length - 1]?.value !== "/";
		}
		if (routeIndex < routeSegments.length && baseIndex >= baseSegments.length) {
			for (let i = routeIndex; i < routeSegments.length; i++) if (routeSegments[i]?.type !== SEGMENT_TYPE_OPTIONAL_PARAM) return false;
			break;
		}
		break;
	}
	return true;
}

//#endregion
//#region node_modules/@tanstack/router-core/dist/esm/root.js
var rootRouteId = "__root__";

//#endregion
export { isPlainArray as C, replaceEqualDeep as D, last as E, isModuleNotFoundError as S, isPromise as T, invariant as _, cleanPath as a, findLast as b, joinPaths as c, parsePathname as d, removeTrailingSlash as f, trimPathRight as g, trimPathLeft as h, SEGMENT_TYPE_PATHNAME as i, matchByPath as l, trimPath as m, SEGMENT_TYPE_OPTIONAL_PARAM as n, exactPathTest as o, resolvePath as p, SEGMENT_TYPE_PARAM as r, interpolatePath as s, rootRouteId as t, matchPathname as u, createControlledPromise as v, isPlainObject as w, functionalUpdate as x, deepEqual as y };
//# sourceMappingURL=root-Cjj8VExB.js.map