{"version":3,"file":"esm-Bje71nt3.js","names":["notFound","lazyFn","subscribe","useLayoutEffect","useRef","subscribe","intersectionObserverOptions","storageKey","Fragment","ScrollRestoration","Fragment","ScrollRestoration","Fragment"],"sources":["../../@tanstack/store/dist/esm/scheduler.js","../../@tanstack/store/dist/esm/types.js","../../@tanstack/store/dist/esm/store.js","../../@tanstack/store/dist/esm/derived.js","../../@tanstack/history/dist/esm/index.js","../../@tanstack/router-core/dist/esm/process-route-tree.js","../../@tanstack/router-core/dist/esm/not-found.js","../../@tanstack/router-core/dist/esm/scroll-restoration.js","../../@tanstack/router-core/dist/esm/qss.js","../../@tanstack/router-core/dist/esm/searchParams.js","../../@tanstack/router-core/dist/esm/redirect.js","../../@tanstack/router-core/dist/esm/lru-cache.js","../../@tanstack/router-core/dist/esm/load-matches.js","../../@tanstack/router-core/dist/esm/rewrite.js","../../@tanstack/router-core/dist/esm/router.js","../../@tanstack/router-core/dist/esm/defer.js","../../@tanstack/router-core/dist/esm/link.js","../../@tanstack/router-core/dist/esm/Matches.js","../../@tanstack/router-core/dist/esm/route.js","../../@tanstack/router-core/dist/esm/config.js","../../@tanstack/router-core/dist/esm/searchMiddleware.js","../../seroval/dist/esm/development/index.mjs","../../@tanstack/router-core/dist/esm/ssr/serializer/transformer.js","../../@tanstack/react-router/dist/esm/awaited.js","../../@tanstack/react-router/dist/esm/CatchBoundary.js","../../@tanstack/react-router/dist/esm/ClientOnly.js","../../tiny-warning/dist/tiny-warning.esm.js","../../use-sync-external-store/cjs/use-sync-external-store-shim.development.js","../../use-sync-external-store/shim/index.js","../../use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js","../../use-sync-external-store/shim/with-selector.js","../../@tanstack/react-store/dist/esm/index.js","../../@tanstack/react-router/dist/esm/routerContext.js","../../@tanstack/react-router/dist/esm/useRouter.js","../../@tanstack/react-router/dist/esm/useRouterState.js","../../@tanstack/react-router/dist/esm/matchContext.js","../../@tanstack/react-router/dist/esm/useMatch.js","../../@tanstack/react-router/dist/esm/useLoaderData.js","../../@tanstack/react-router/dist/esm/useLoaderDeps.js","../../@tanstack/react-router/dist/esm/useParams.js","../../@tanstack/react-router/dist/esm/useSearch.js","../../@tanstack/react-router/dist/esm/useNavigate.js","../../@tanstack/react-router/dist/esm/utils.js","../../@tanstack/react-router/dist/esm/link.js","../../@tanstack/react-router/dist/esm/route.js","../../@tanstack/react-router/dist/esm/fileRoute.js","../../@tanstack/react-router/dist/esm/lazyRouteComponent.js","../../@tanstack/react-router/dist/esm/Transitioner.js","../../@tanstack/react-router/dist/esm/not-found.js","../../@tanstack/react-router/dist/esm/SafeFragment.js","../../@tanstack/react-router/dist/esm/renderRouteNotFound.js","../../@tanstack/react-router/dist/esm/ScriptOnce.js","../../@tanstack/react-router/dist/esm/scroll-restoration.js","../../@tanstack/react-router/dist/esm/Match.js","../../@tanstack/react-router/dist/esm/Matches.js","../../@tanstack/react-router/dist/esm/router.js","../../@tanstack/react-router/dist/esm/RouterProvider.js","../../@tanstack/react-router/dist/esm/ScrollRestoration.js","../../@tanstack/react-router/dist/esm/useBlocker.js","../../@tanstack/react-router/dist/esm/useRouteContext.js","../../@tanstack/react-router/dist/esm/useLocation.js","../../@tanstack/react-router/dist/esm/useCanGoBack.js","../../@tanstack/react-router/dist/esm/Asset.js","../../@tanstack/react-router/dist/esm/HeadContent.js","../../@tanstack/react-router/dist/esm/Scripts.js"],"sourcesContent":["import { Derived } from \"./derived.js\";\nconst __storeToDerived = /* @__PURE__ */ new WeakMap();\nconst __derivedToStore = /* @__PURE__ */ new WeakMap();\nconst __depsThatHaveWrittenThisTick = {\n  current: []\n};\nlet __isFlushing = false;\nlet __batchDepth = 0;\nconst __pendingUpdates = /* @__PURE__ */ new Set();\nconst __initialBatchValues = /* @__PURE__ */ new Map();\nfunction __flush_internals(relatedVals) {\n  const sorted = Array.from(relatedVals).sort((a, b) => {\n    if (a instanceof Derived && a.options.deps.includes(b)) return 1;\n    if (b instanceof Derived && b.options.deps.includes(a)) return -1;\n    return 0;\n  });\n  for (const derived of sorted) {\n    if (__depsThatHaveWrittenThisTick.current.includes(derived)) {\n      continue;\n    }\n    __depsThatHaveWrittenThisTick.current.push(derived);\n    derived.recompute();\n    const stores = __derivedToStore.get(derived);\n    if (stores) {\n      for (const store of stores) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(store);\n        if (!relatedLinkedDerivedVals) continue;\n        __flush_internals(relatedLinkedDerivedVals);\n      }\n    }\n  }\n}\nfunction __notifyListeners(store) {\n  const value = {\n    prevVal: store.prevState,\n    currentVal: store.state\n  };\n  for (const listener of store.listeners) {\n    listener(value);\n  }\n}\nfunction __notifyDerivedListeners(derived) {\n  const value = {\n    prevVal: derived.prevState,\n    currentVal: derived.state\n  };\n  for (const listener of derived.listeners) {\n    listener(value);\n  }\n}\nfunction __flush(store) {\n  if (__batchDepth > 0 && !__initialBatchValues.has(store)) {\n    __initialBatchValues.set(store, store.prevState);\n  }\n  __pendingUpdates.add(store);\n  if (__batchDepth > 0) return;\n  if (__isFlushing) return;\n  try {\n    __isFlushing = true;\n    while (__pendingUpdates.size > 0) {\n      const stores = Array.from(__pendingUpdates);\n      __pendingUpdates.clear();\n      for (const store2 of stores) {\n        const prevState = __initialBatchValues.get(store2) ?? store2.prevState;\n        store2.prevState = prevState;\n        __notifyListeners(store2);\n      }\n      for (const store2 of stores) {\n        const derivedVals = __storeToDerived.get(store2);\n        if (!derivedVals) continue;\n        __depsThatHaveWrittenThisTick.current.push(store2);\n        __flush_internals(derivedVals);\n      }\n      for (const store2 of stores) {\n        const derivedVals = __storeToDerived.get(store2);\n        if (!derivedVals) continue;\n        for (const derived of derivedVals) {\n          __notifyDerivedListeners(derived);\n        }\n      }\n    }\n  } finally {\n    __isFlushing = false;\n    __depsThatHaveWrittenThisTick.current = [];\n    __initialBatchValues.clear();\n  }\n}\nfunction batch(fn) {\n  __batchDepth++;\n  try {\n    fn();\n  } finally {\n    __batchDepth--;\n    if (__batchDepth === 0) {\n      const pendingUpdateToFlush = __pendingUpdates.values().next().value;\n      if (pendingUpdateToFlush) {\n        __flush(pendingUpdateToFlush);\n      }\n    }\n  }\n}\nexport {\n  __depsThatHaveWrittenThisTick,\n  __derivedToStore,\n  __flush,\n  __storeToDerived,\n  batch\n};\n//# sourceMappingURL=scheduler.js.map\n","function isUpdaterFunction(updater) {\n  return typeof updater === \"function\";\n}\nexport {\n  isUpdaterFunction\n};\n//# sourceMappingURL=types.js.map\n","import { __flush } from \"./scheduler.js\";\nimport { isUpdaterFunction } from \"./types.js\";\nclass Store {\n  constructor(initialState, options) {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.subscribe = (listener) => {\n      var _a, _b;\n      this.listeners.add(listener);\n      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);\n      return () => {\n        this.listeners.delete(listener);\n        unsub == null ? void 0 : unsub();\n      };\n    };\n    this.prevState = initialState;\n    this.state = initialState;\n    this.options = options;\n  }\n  setState(updater) {\n    var _a, _b, _c;\n    this.prevState = this.state;\n    if ((_a = this.options) == null ? void 0 : _a.updateFn) {\n      this.state = this.options.updateFn(this.prevState)(updater);\n    } else {\n      if (isUpdaterFunction(updater)) {\n        this.state = updater(this.prevState);\n      } else {\n        this.state = updater;\n      }\n    }\n    (_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null ? void 0 : _c.call(_b);\n    __flush(this);\n  }\n}\nexport {\n  Store\n};\n//# sourceMappingURL=store.js.map\n","import { Store } from \"./store.js\";\nimport { __storeToDerived, __derivedToStore } from \"./scheduler.js\";\nclass Derived {\n  constructor(options) {\n    this.listeners = /* @__PURE__ */ new Set();\n    this._subscriptions = [];\n    this.lastSeenDepValues = [];\n    this.getDepVals = () => {\n      const l = this.options.deps.length;\n      const prevDepVals = new Array(l);\n      const currDepVals = new Array(l);\n      for (let i = 0; i < l; i++) {\n        const dep = this.options.deps[i];\n        prevDepVals[i] = dep.prevState;\n        currDepVals[i] = dep.state;\n      }\n      this.lastSeenDepValues = currDepVals;\n      return {\n        prevDepVals,\n        currDepVals,\n        prevVal: this.prevState ?? void 0\n      };\n    };\n    this.recompute = () => {\n      var _a, _b;\n      this.prevState = this.state;\n      const depVals = this.getDepVals();\n      this.state = this.options.fn(depVals);\n      (_b = (_a = this.options).onUpdate) == null ? void 0 : _b.call(_a);\n    };\n    this.checkIfRecalculationNeededDeeply = () => {\n      for (const dep of this.options.deps) {\n        if (dep instanceof Derived) {\n          dep.checkIfRecalculationNeededDeeply();\n        }\n      }\n      let shouldRecompute = false;\n      const lastSeenDepValues = this.lastSeenDepValues;\n      const { currDepVals } = this.getDepVals();\n      for (let i = 0; i < currDepVals.length; i++) {\n        if (currDepVals[i] !== lastSeenDepValues[i]) {\n          shouldRecompute = true;\n          break;\n        }\n      }\n      if (shouldRecompute) {\n        this.recompute();\n      }\n    };\n    this.mount = () => {\n      this.registerOnGraph();\n      this.checkIfRecalculationNeededDeeply();\n      return () => {\n        this.unregisterFromGraph();\n        for (const cleanup of this._subscriptions) {\n          cleanup();\n        }\n      };\n    };\n    this.subscribe = (listener) => {\n      var _a, _b;\n      this.listeners.add(listener);\n      const unsub = (_b = (_a = this.options).onSubscribe) == null ? void 0 : _b.call(_a, listener, this);\n      return () => {\n        this.listeners.delete(listener);\n        unsub == null ? void 0 : unsub();\n      };\n    };\n    this.options = options;\n    this.state = options.fn({\n      prevDepVals: void 0,\n      prevVal: void 0,\n      currDepVals: this.getDepVals().currDepVals\n    });\n  }\n  registerOnGraph(deps = this.options.deps) {\n    for (const dep of deps) {\n      if (dep instanceof Derived) {\n        dep.registerOnGraph();\n        this.registerOnGraph(dep.options.deps);\n      } else if (dep instanceof Store) {\n        let relatedLinkedDerivedVals = __storeToDerived.get(dep);\n        if (!relatedLinkedDerivedVals) {\n          relatedLinkedDerivedVals = /* @__PURE__ */ new Set();\n          __storeToDerived.set(dep, relatedLinkedDerivedVals);\n        }\n        relatedLinkedDerivedVals.add(this);\n        let relatedStores = __derivedToStore.get(this);\n        if (!relatedStores) {\n          relatedStores = /* @__PURE__ */ new Set();\n          __derivedToStore.set(this, relatedStores);\n        }\n        relatedStores.add(dep);\n      }\n    }\n  }\n  unregisterFromGraph(deps = this.options.deps) {\n    for (const dep of deps) {\n      if (dep instanceof Derived) {\n        this.unregisterFromGraph(dep.options.deps);\n      } else if (dep instanceof Store) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(dep);\n        if (relatedLinkedDerivedVals) {\n          relatedLinkedDerivedVals.delete(this);\n        }\n        const relatedStores = __derivedToStore.get(this);\n        if (relatedStores) {\n          relatedStores.delete(dep);\n        }\n      }\n    }\n  }\n}\nexport {\n  Derived\n};\n//# sourceMappingURL=derived.js.map\n","const stateIndexKey = \"__TSR_index\";\nconst popStateEvent = \"popstate\";\nconst beforeUnloadEvent = \"beforeunload\";\nfunction createHistory(opts) {\n  let location = opts.getLocation();\n  const subscribers = /* @__PURE__ */ new Set();\n  const notify = (action) => {\n    location = opts.getLocation();\n    subscribers.forEach((subscriber) => subscriber({ location, action }));\n  };\n  const handleIndexChange = (action) => {\n    if (opts.notifyOnIndexChange ?? true) notify(action);\n    else location = opts.getLocation();\n  };\n  const tryNavigation = async ({\n    task,\n    navigateOpts,\n    ...actionInfo\n  }) => {\n    const ignoreBlocker = navigateOpts?.ignoreBlocker ?? false;\n    if (ignoreBlocker) {\n      task();\n      return;\n    }\n    const blockers = opts.getBlockers?.() ?? [];\n    const isPushOrReplace = actionInfo.type === \"PUSH\" || actionInfo.type === \"REPLACE\";\n    if (typeof document !== \"undefined\" && blockers.length && isPushOrReplace) {\n      for (const blocker of blockers) {\n        const nextLocation = parseHref(actionInfo.path, actionInfo.state);\n        const isBlocked = await blocker.blockerFn({\n          currentLocation: location,\n          nextLocation,\n          action: actionInfo.type\n        });\n        if (isBlocked) {\n          opts.onBlocked?.();\n          return;\n        }\n      }\n    }\n    task();\n  };\n  return {\n    get location() {\n      return location;\n    },\n    get length() {\n      return opts.getLength();\n    },\n    subscribers,\n    subscribe: (cb) => {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    push: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey];\n      state = assignKeyAndIndex(currentIndex + 1, state);\n      tryNavigation({\n        task: () => {\n          opts.pushState(path, state);\n          notify({ type: \"PUSH\" });\n        },\n        navigateOpts,\n        type: \"PUSH\",\n        path,\n        state\n      });\n    },\n    replace: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey];\n      state = assignKeyAndIndex(currentIndex, state);\n      tryNavigation({\n        task: () => {\n          opts.replaceState(path, state);\n          notify({ type: \"REPLACE\" });\n        },\n        navigateOpts,\n        type: \"REPLACE\",\n        path,\n        state\n      });\n    },\n    go: (index, navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.go(index);\n          handleIndexChange({ type: \"GO\", index });\n        },\n        navigateOpts,\n        type: \"GO\"\n      });\n    },\n    back: (navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.back(navigateOpts?.ignoreBlocker ?? false);\n          handleIndexChange({ type: \"BACK\" });\n        },\n        navigateOpts,\n        type: \"BACK\"\n      });\n    },\n    forward: (navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.forward(navigateOpts?.ignoreBlocker ?? false);\n          handleIndexChange({ type: \"FORWARD\" });\n        },\n        navigateOpts,\n        type: \"FORWARD\"\n      });\n    },\n    canGoBack: () => location.state[stateIndexKey] !== 0,\n    createHref: (str) => opts.createHref(str),\n    block: (blocker) => {\n      if (!opts.setBlockers) return () => {\n      };\n      const blockers = opts.getBlockers?.() ?? [];\n      opts.setBlockers([...blockers, blocker]);\n      return () => {\n        const blockers2 = opts.getBlockers?.() ?? [];\n        opts.setBlockers?.(blockers2.filter((b) => b !== blocker));\n      };\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify\n  };\n}\nfunction assignKeyAndIndex(index, state) {\n  if (!state) {\n    state = {};\n  }\n  const key = createRandomKey();\n  return {\n    ...state,\n    key,\n    // TODO: Remove in v2 - use __TSR_key instead\n    __TSR_key: key,\n    [stateIndexKey]: index\n  };\n}\nfunction createBrowserHistory(opts) {\n  const win = opts?.window ?? (typeof document !== \"undefined\" ? window : void 0);\n  const originalPushState = win.history.pushState;\n  const originalReplaceState = win.history.replaceState;\n  let blockers = [];\n  const _getBlockers = () => blockers;\n  const _setBlockers = (newBlockers) => blockers = newBlockers;\n  const createHref = opts?.createHref ?? ((path) => path);\n  const parseLocation = opts?.parseLocation ?? (() => parseHref(\n    `${win.location.pathname}${win.location.search}${win.location.hash}`,\n    win.history.state\n  ));\n  if (!win.history.state?.__TSR_key && !win.history.state?.key) {\n    const addedKey = createRandomKey();\n    win.history.replaceState(\n      {\n        [stateIndexKey]: 0,\n        key: addedKey,\n        // TODO: Remove in v2 - use __TSR_key instead\n        __TSR_key: addedKey\n      },\n      \"\"\n    );\n  }\n  let currentLocation = parseLocation();\n  let rollbackLocation;\n  let nextPopIsGo = false;\n  let ignoreNextPop = false;\n  let skipBlockerNextPop = false;\n  let ignoreNextBeforeUnload = false;\n  const getLocation = () => currentLocation;\n  let next;\n  let scheduled;\n  const flush = () => {\n    if (!next) {\n      return;\n    }\n    history._ignoreSubscribers = true;\n    (next.isPush ? win.history.pushState : win.history.replaceState)(\n      next.state,\n      \"\",\n      next.href\n    );\n    history._ignoreSubscribers = false;\n    next = void 0;\n    scheduled = void 0;\n    rollbackLocation = void 0;\n  };\n  const queueHistoryAction = (type, destHref, state) => {\n    const href = createHref(destHref);\n    if (!scheduled) {\n      rollbackLocation = currentLocation;\n    }\n    currentLocation = parseHref(destHref, state);\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === \"push\"\n    };\n    if (!scheduled) {\n      scheduled = Promise.resolve().then(() => flush());\n    }\n  };\n  const onPushPop = (type) => {\n    currentLocation = parseLocation();\n    history.notify({ type });\n  };\n  const onPushPopEvent = async () => {\n    if (ignoreNextPop) {\n      ignoreNextPop = false;\n      return;\n    }\n    const nextLocation = parseLocation();\n    const delta = nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey];\n    const isForward = delta === 1;\n    const isBack = delta === -1;\n    const isGo = !isForward && !isBack || nextPopIsGo;\n    nextPopIsGo = false;\n    const action = isGo ? \"GO\" : isBack ? \"BACK\" : \"FORWARD\";\n    const notify = isGo ? {\n      type: \"GO\",\n      index: delta\n    } : {\n      type: isBack ? \"BACK\" : \"FORWARD\"\n    };\n    if (skipBlockerNextPop) {\n      skipBlockerNextPop = false;\n    } else {\n      const blockers2 = _getBlockers();\n      if (typeof document !== \"undefined\" && blockers2.length) {\n        for (const blocker of blockers2) {\n          const isBlocked = await blocker.blockerFn({\n            currentLocation,\n            nextLocation,\n            action\n          });\n          if (isBlocked) {\n            ignoreNextPop = true;\n            win.history.go(1);\n            history.notify(notify);\n            return;\n          }\n        }\n      }\n    }\n    currentLocation = parseLocation();\n    history.notify(notify);\n  };\n  const onBeforeUnload = (e) => {\n    if (ignoreNextBeforeUnload) {\n      ignoreNextBeforeUnload = false;\n      return;\n    }\n    let shouldBlock = false;\n    const blockers2 = _getBlockers();\n    if (typeof document !== \"undefined\" && blockers2.length) {\n      for (const blocker of blockers2) {\n        const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? true;\n        if (shouldHaveBeforeUnload === true) {\n          shouldBlock = true;\n          break;\n        }\n        if (typeof shouldHaveBeforeUnload === \"function\" && shouldHaveBeforeUnload() === true) {\n          shouldBlock = true;\n          break;\n        }\n      }\n    }\n    if (shouldBlock) {\n      e.preventDefault();\n      return e.returnValue = \"\";\n    }\n    return;\n  };\n  const history = createHistory({\n    getLocation,\n    getLength: () => win.history.length,\n    pushState: (href, state) => queueHistoryAction(\"push\", href, state),\n    replaceState: (href, state) => queueHistoryAction(\"replace\", href, state),\n    back: (ignoreBlocker) => {\n      if (ignoreBlocker) skipBlockerNextPop = true;\n      ignoreNextBeforeUnload = true;\n      return win.history.back();\n    },\n    forward: (ignoreBlocker) => {\n      if (ignoreBlocker) skipBlockerNextPop = true;\n      ignoreNextBeforeUnload = true;\n      win.history.forward();\n    },\n    go: (n) => {\n      nextPopIsGo = true;\n      win.history.go(n);\n    },\n    createHref: (href) => createHref(href),\n    flush,\n    destroy: () => {\n      win.history.pushState = originalPushState;\n      win.history.replaceState = originalReplaceState;\n      win.removeEventListener(beforeUnloadEvent, onBeforeUnload, {\n        capture: true\n      });\n      win.removeEventListener(popStateEvent, onPushPopEvent);\n    },\n    onBlocked: () => {\n      if (rollbackLocation && currentLocation !== rollbackLocation) {\n        currentLocation = rollbackLocation;\n      }\n    },\n    getBlockers: _getBlockers,\n    setBlockers: _setBlockers,\n    notifyOnIndexChange: false\n  });\n  win.addEventListener(beforeUnloadEvent, onBeforeUnload, { capture: true });\n  win.addEventListener(popStateEvent, onPushPopEvent);\n  win.history.pushState = function(...args) {\n    const res = originalPushState.apply(win.history, args);\n    if (!history._ignoreSubscribers) onPushPop(\"PUSH\");\n    return res;\n  };\n  win.history.replaceState = function(...args) {\n    const res = originalReplaceState.apply(win.history, args);\n    if (!history._ignoreSubscribers) onPushPop(\"REPLACE\");\n    return res;\n  };\n  return history;\n}\nfunction createHashHistory(opts) {\n  const win = opts?.window ?? (typeof document !== \"undefined\" ? window : void 0);\n  return createBrowserHistory({\n    window: win,\n    parseLocation: () => {\n      const hashSplit = win.location.hash.split(\"#\").slice(1);\n      const pathPart = hashSplit[0] ?? \"/\";\n      const searchPart = win.location.search;\n      const hashEntries = hashSplit.slice(1);\n      const hashPart = hashEntries.length === 0 ? \"\" : `#${hashEntries.join(\"#\")}`;\n      const hashHref = `${pathPart}${searchPart}${hashPart}`;\n      return parseHref(hashHref, win.history.state);\n    },\n    createHref: (href) => `${win.location.pathname}${win.location.search}#${href}`\n  });\n}\nfunction createMemoryHistory(opts = {\n  initialEntries: [\"/\"]\n}) {\n  const entries = opts.initialEntries;\n  let index = opts.initialIndex ? Math.min(Math.max(opts.initialIndex, 0), entries.length - 1) : entries.length - 1;\n  const states = entries.map(\n    (_entry, index2) => assignKeyAndIndex(index2, void 0)\n  );\n  const getLocation = () => parseHref(entries[index], states[index]);\n  return createHistory({\n    getLocation,\n    getLength: () => entries.length,\n    pushState: (path, state) => {\n      if (index < entries.length - 1) {\n        entries.splice(index + 1);\n        states.splice(index + 1);\n      }\n      states.push(state);\n      entries.push(path);\n      index = Math.max(entries.length - 1, 0);\n    },\n    replaceState: (path, state) => {\n      states[index] = state;\n      entries[index] = path;\n    },\n    back: () => {\n      index = Math.max(index - 1, 0);\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1);\n    },\n    go: (n) => {\n      index = Math.min(Math.max(index + n, 0), entries.length - 1);\n    },\n    createHref: (path) => path\n  });\n}\nfunction parseHref(href, state) {\n  const hashIndex = href.indexOf(\"#\");\n  const searchIndex = href.indexOf(\"?\");\n  const addedKey = createRandomKey();\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : \"\",\n    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : \"\",\n    state: state || { [stateIndexKey]: 0, key: addedKey, __TSR_key: addedKey }\n  };\n}\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7);\n}\nexport {\n  createBrowserHistory,\n  createHashHistory,\n  createHistory,\n  createMemoryHistory,\n  parseHref\n};\n//# sourceMappingURL=index.js.map\n","import invariant from \"tiny-invariant\";\nimport { trimPathRight, trimPathLeft, parsePathname, SEGMENT_TYPE_PATHNAME, SEGMENT_TYPE_PARAM, SEGMENT_TYPE_OPTIONAL_PARAM } from \"./path.js\";\nconst SLASH_SCORE = 0.75;\nconst STATIC_SEGMENT_SCORE = 1;\nconst REQUIRED_PARAM_BASE_SCORE = 0.5;\nconst OPTIONAL_PARAM_BASE_SCORE = 0.4;\nconst WILDCARD_PARAM_BASE_SCORE = 0.25;\nconst STATIC_AFTER_DYNAMIC_BONUS_SCORE = 0.2;\nconst BOTH_PRESENCE_BASE_SCORE = 0.05;\nconst PREFIX_PRESENCE_BASE_SCORE = 0.02;\nconst SUFFIX_PRESENCE_BASE_SCORE = 0.01;\nconst PREFIX_LENGTH_SCORE_MULTIPLIER = 2e-4;\nconst SUFFIX_LENGTH_SCORE_MULTIPLIER = 1e-4;\nfunction handleParam(segment, baseScore) {\n  if (segment.prefixSegment && segment.suffixSegment) {\n    return baseScore + BOTH_PRESENCE_BASE_SCORE + PREFIX_LENGTH_SCORE_MULTIPLIER * segment.prefixSegment.length + SUFFIX_LENGTH_SCORE_MULTIPLIER * segment.suffixSegment.length;\n  }\n  if (segment.prefixSegment) {\n    return baseScore + PREFIX_PRESENCE_BASE_SCORE + PREFIX_LENGTH_SCORE_MULTIPLIER * segment.prefixSegment.length;\n  }\n  if (segment.suffixSegment) {\n    return baseScore + SUFFIX_PRESENCE_BASE_SCORE + SUFFIX_LENGTH_SCORE_MULTIPLIER * segment.suffixSegment.length;\n  }\n  return baseScore;\n}\nfunction sortRoutes(routes) {\n  const scoredRoutes = [];\n  routes.forEach((d, i) => {\n    if (d.isRoot || !d.path) {\n      return;\n    }\n    const trimmed = trimPathLeft(d.fullPath);\n    let parsed = parsePathname(trimmed);\n    let skip = 0;\n    while (parsed.length > skip + 1 && parsed[skip]?.value === \"/\") {\n      skip++;\n    }\n    if (skip > 0) parsed = parsed.slice(skip);\n    let optionalParamCount = 0;\n    let hasStaticAfter = false;\n    const scores = parsed.map((segment, index) => {\n      if (segment.value === \"/\") {\n        return SLASH_SCORE;\n      }\n      if (segment.type === SEGMENT_TYPE_PATHNAME) {\n        return STATIC_SEGMENT_SCORE;\n      }\n      let baseScore = void 0;\n      if (segment.type === SEGMENT_TYPE_PARAM) {\n        baseScore = REQUIRED_PARAM_BASE_SCORE;\n      } else if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        baseScore = OPTIONAL_PARAM_BASE_SCORE;\n        optionalParamCount++;\n      } else {\n        baseScore = WILDCARD_PARAM_BASE_SCORE;\n      }\n      for (let i2 = index + 1; i2 < parsed.length; i2++) {\n        const nextSegment = parsed[i2];\n        if (nextSegment.type === SEGMENT_TYPE_PATHNAME && nextSegment.value !== \"/\") {\n          hasStaticAfter = true;\n          return handleParam(\n            segment,\n            baseScore + STATIC_AFTER_DYNAMIC_BONUS_SCORE\n          );\n        }\n      }\n      return handleParam(segment, baseScore);\n    });\n    scoredRoutes.push({\n      child: d,\n      trimmed,\n      parsed,\n      index: i,\n      scores,\n      optionalParamCount,\n      hasStaticAfter\n    });\n  });\n  const flatRoutes = scoredRoutes.sort((a, b) => {\n    const minLength = Math.min(a.scores.length, b.scores.length);\n    for (let i = 0; i < minLength; i++) {\n      if (a.scores[i] !== b.scores[i]) {\n        return b.scores[i] - a.scores[i];\n      }\n    }\n    if (a.scores.length !== b.scores.length) {\n      if (a.optionalParamCount !== b.optionalParamCount) {\n        if (a.hasStaticAfter === b.hasStaticAfter) {\n          return a.optionalParamCount - b.optionalParamCount;\n        } else if (a.hasStaticAfter && !b.hasStaticAfter) {\n          return -1;\n        } else if (!a.hasStaticAfter && b.hasStaticAfter) {\n          return 1;\n        }\n      }\n      return b.scores.length - a.scores.length;\n    }\n    for (let i = 0; i < minLength; i++) {\n      if (a.parsed[i].value !== b.parsed[i].value) {\n        return a.parsed[i].value > b.parsed[i].value ? 1 : -1;\n      }\n    }\n    return a.index - b.index;\n  }).map((d, i) => {\n    d.child.rank = i;\n    return d.child;\n  });\n  return flatRoutes;\n}\nfunction processRouteTree({\n  routeTree,\n  initRoute\n}) {\n  const routesById = {};\n  const routesByPath = {};\n  const recurseRoutes = (childRoutes) => {\n    childRoutes.forEach((childRoute, i) => {\n      initRoute?.(childRoute, i);\n      const existingRoute = routesById[childRoute.id];\n      invariant(\n        !existingRoute,\n        `Duplicate routes found with id: ${String(childRoute.id)}`\n      );\n      routesById[childRoute.id] = childRoute;\n      if (!childRoute.isRoot && childRoute.path) {\n        const trimmedFullPath = trimPathRight(childRoute.fullPath);\n        if (!routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith(\"/\")) {\n          routesByPath[trimmedFullPath] = childRoute;\n        }\n      }\n      const children = childRoute.children;\n      if (children?.length) {\n        recurseRoutes(children);\n      }\n    });\n  };\n  recurseRoutes([routeTree]);\n  const flatRoutes = sortRoutes(Object.values(routesById));\n  return { routesById, routesByPath, flatRoutes };\n}\nexport {\n  processRouteTree\n};\n//# sourceMappingURL=process-route-tree.js.map\n","function notFound(options = {}) {\n  options.isNotFound = true;\n  if (options.throw) throw options;\n  return options;\n}\nfunction isNotFound(obj) {\n  return !!obj?.isNotFound;\n}\nexport {\n  isNotFound,\n  notFound\n};\n//# sourceMappingURL=not-found.js.map\n","import { functionalUpdate } from \"./utils.js\";\nfunction getSafeSessionStorage() {\n  try {\n    if (typeof window !== \"undefined\" && typeof window.sessionStorage === \"object\") {\n      return window.sessionStorage;\n    }\n  } catch {\n  }\n  return void 0;\n}\nconst storageKey = \"tsr-scroll-restoration-v1_3\";\nconst throttle = (fn, wait) => {\n  let timeout;\n  return (...args) => {\n    if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args);\n        timeout = null;\n      }, wait);\n    }\n  };\n};\nfunction createScrollRestorationCache() {\n  const safeSessionStorage = getSafeSessionStorage();\n  if (!safeSessionStorage) {\n    return null;\n  }\n  const persistedState = safeSessionStorage.getItem(storageKey);\n  let state = persistedState ? JSON.parse(persistedState) : {};\n  return {\n    state,\n    // This setter is simply to make sure that we set the sessionStorage right\n    // after the state is updated. It doesn't necessarily need to be a functional\n    // update.\n    set: (updater) => (state = functionalUpdate(updater, state) || state, safeSessionStorage.setItem(storageKey, JSON.stringify(state)))\n  };\n}\nconst scrollRestorationCache = createScrollRestorationCache();\nconst defaultGetScrollRestorationKey = (location) => {\n  return location.state.__TSR_key || location.href;\n};\nfunction getCssSelector(el) {\n  const path = [];\n  let parent;\n  while (parent = el.parentNode) {\n    path.push(\n      `${el.tagName}:nth-child(${Array.prototype.indexOf.call(parent.children, el) + 1})`\n    );\n    el = parent;\n  }\n  return `${path.reverse().join(\" > \")}`.toLowerCase();\n}\nlet ignoreScroll = false;\nfunction restoreScroll({\n  storageKey: storageKey2,\n  key,\n  behavior,\n  shouldScrollRestoration,\n  scrollToTopSelectors,\n  location\n}) {\n  let byKey;\n  try {\n    byKey = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n  } catch (error) {\n    console.error(error);\n    return;\n  }\n  const resolvedKey = key || window.history.state?.__TSR_key;\n  const elementEntries = byKey[resolvedKey];\n  ignoreScroll = true;\n  scroll: {\n    if (shouldScrollRestoration && elementEntries && Object.keys(elementEntries).length > 0) {\n      for (const elementSelector in elementEntries) {\n        const entry = elementEntries[elementSelector];\n        if (elementSelector === \"window\") {\n          window.scrollTo({\n            top: entry.scrollY,\n            left: entry.scrollX,\n            behavior\n          });\n        } else if (elementSelector) {\n          const element = document.querySelector(elementSelector);\n          if (element) {\n            element.scrollLeft = entry.scrollX;\n            element.scrollTop = entry.scrollY;\n          }\n        }\n      }\n      break scroll;\n    }\n    const hash = (location ?? window.location).hash.split(\"#\", 2)[1];\n    if (hash) {\n      const hashScrollIntoViewOptions = window.history.state?.__hashScrollIntoViewOptions ?? true;\n      if (hashScrollIntoViewOptions) {\n        const el = document.getElementById(hash);\n        if (el) {\n          el.scrollIntoView(hashScrollIntoViewOptions);\n        }\n      }\n      break scroll;\n    }\n    const scrollOptions = { top: 0, left: 0, behavior };\n    window.scrollTo(scrollOptions);\n    if (scrollToTopSelectors) {\n      for (const selector of scrollToTopSelectors) {\n        if (selector === \"window\") continue;\n        const element = typeof selector === \"function\" ? selector() : document.querySelector(selector);\n        if (element) element.scrollTo(scrollOptions);\n      }\n    }\n  }\n  ignoreScroll = false;\n}\nfunction setupScrollRestoration(router, force) {\n  if (!scrollRestorationCache && !router.isServer) {\n    return;\n  }\n  const shouldScrollRestoration = force ?? router.options.scrollRestoration ?? false;\n  if (shouldScrollRestoration) {\n    router.isScrollRestoring = true;\n  }\n  if (router.isServer || router.isScrollRestorationSetup || !scrollRestorationCache) {\n    return;\n  }\n  router.isScrollRestorationSetup = true;\n  ignoreScroll = false;\n  const getKey = router.options.getScrollRestorationKey || defaultGetScrollRestorationKey;\n  window.history.scrollRestoration = \"manual\";\n  const onScroll = (event) => {\n    if (ignoreScroll || !router.isScrollRestoring) {\n      return;\n    }\n    let elementSelector = \"\";\n    if (event.target === document || event.target === window) {\n      elementSelector = \"window\";\n    } else {\n      const attrId = event.target.getAttribute(\n        \"data-scroll-restoration-id\"\n      );\n      if (attrId) {\n        elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`;\n      } else {\n        elementSelector = getCssSelector(event.target);\n      }\n    }\n    const restoreKey = getKey(router.state.location);\n    scrollRestorationCache.set((state) => {\n      const keyEntry = state[restoreKey] ||= {};\n      const elementEntry = keyEntry[elementSelector] ||= {};\n      if (elementSelector === \"window\") {\n        elementEntry.scrollX = window.scrollX || 0;\n        elementEntry.scrollY = window.scrollY || 0;\n      } else if (elementSelector) {\n        const element = document.querySelector(elementSelector);\n        if (element) {\n          elementEntry.scrollX = element.scrollLeft || 0;\n          elementEntry.scrollY = element.scrollTop || 0;\n        }\n      }\n      return state;\n    });\n  };\n  if (typeof document !== \"undefined\") {\n    document.addEventListener(\"scroll\", throttle(onScroll, 100), true);\n  }\n  router.subscribe(\"onRendered\", (event) => {\n    const cacheKey = getKey(event.toLocation);\n    if (!router.resetNextScroll) {\n      router.resetNextScroll = true;\n      return;\n    }\n    if (typeof router.options.scrollRestoration === \"function\") {\n      const shouldRestore = router.options.scrollRestoration({\n        location: router.latestLocation\n      });\n      if (!shouldRestore) {\n        return;\n      }\n    }\n    restoreScroll({\n      storageKey,\n      key: cacheKey,\n      behavior: router.options.scrollRestorationBehavior,\n      shouldScrollRestoration: router.isScrollRestoring,\n      scrollToTopSelectors: router.options.scrollToTopSelectors,\n      location: router.history.location\n    });\n    if (router.isScrollRestoring) {\n      scrollRestorationCache.set((state) => {\n        state[cacheKey] ||= {};\n        return state;\n      });\n    }\n  });\n}\nfunction handleHashScroll(router) {\n  if (typeof document !== \"undefined\" && document.querySelector) {\n    const hashScrollIntoViewOptions = router.state.location.state.__hashScrollIntoViewOptions ?? true;\n    if (hashScrollIntoViewOptions && router.state.location.hash !== \"\") {\n      const el = document.getElementById(router.state.location.hash);\n      if (el) {\n        el.scrollIntoView(hashScrollIntoViewOptions);\n      }\n    }\n  }\n}\nexport {\n  defaultGetScrollRestorationKey,\n  getCssSelector,\n  handleHashScroll,\n  restoreScroll,\n  scrollRestorationCache,\n  setupScrollRestoration,\n  storageKey\n};\n//# sourceMappingURL=scroll-restoration.js.map\n","function encode(obj, stringify = String) {\n  const result = new URLSearchParams();\n  for (const key in obj) {\n    const val = obj[key];\n    if (val !== void 0) {\n      result.set(key, stringify(val));\n    }\n  }\n  return result.toString();\n}\nfunction toValue(str) {\n  if (!str) return \"\";\n  if (str === \"false\") return false;\n  if (str === \"true\") return true;\n  return +str * 0 === 0 && +str + \"\" === str ? +str : str;\n}\nfunction decode(str) {\n  const searchParams = new URLSearchParams(str);\n  const result = {};\n  for (const [key, value] of searchParams.entries()) {\n    const previousValue = result[key];\n    if (previousValue == null) {\n      result[key] = toValue(value);\n    } else if (Array.isArray(previousValue)) {\n      previousValue.push(toValue(value));\n    } else {\n      result[key] = [previousValue, toValue(value)];\n    }\n  }\n  return result;\n}\nexport {\n  decode,\n  encode\n};\n//# sourceMappingURL=qss.js.map\n","import { decode, encode } from \"./qss.js\";\nconst defaultParseSearch = parseSearchWith(JSON.parse);\nconst defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse\n);\nfunction parseSearchWith(parser) {\n  return (searchStr) => {\n    if (searchStr[0] === \"?\") {\n      searchStr = searchStr.substring(1);\n    }\n    const query = decode(searchStr);\n    for (const key in query) {\n      const value = query[key];\n      if (typeof value === \"string\") {\n        try {\n          query[key] = parser(value);\n        } catch (_err) {\n        }\n      }\n    }\n    return query;\n  };\n}\nfunction stringifySearchWith(stringify, parser) {\n  const hasParser = typeof parser === \"function\";\n  function stringifyValue(val) {\n    if (typeof val === \"object\" && val !== null) {\n      try {\n        return stringify(val);\n      } catch (_err) {\n      }\n    } else if (hasParser && typeof val === \"string\") {\n      try {\n        parser(val);\n        return stringify(val);\n      } catch (_err) {\n      }\n    }\n    return val;\n  }\n  return (search) => {\n    const searchStr = encode(search, stringifyValue);\n    return searchStr ? `?${searchStr}` : \"\";\n  };\n}\nexport {\n  defaultParseSearch,\n  defaultStringifySearch,\n  parseSearchWith,\n  stringifySearchWith\n};\n//# sourceMappingURL=searchParams.js.map\n","function redirect(opts) {\n  opts.statusCode = opts.statusCode || opts.code || 307;\n  if (!opts.reloadDocument && typeof opts.href === \"string\") {\n    try {\n      new URL(opts.href);\n      opts.reloadDocument = true;\n    } catch {\n    }\n  }\n  const headers = new Headers(opts.headers);\n  if (opts.href && headers.get(\"Location\") === null) {\n    headers.set(\"Location\", opts.href);\n  }\n  const response = new Response(null, {\n    status: opts.statusCode,\n    headers\n  });\n  response.options = opts;\n  if (opts.throw) {\n    throw response;\n  }\n  return response;\n}\nfunction isRedirect(obj) {\n  return obj instanceof Response && !!obj.options;\n}\nfunction isResolvedRedirect(obj) {\n  return isRedirect(obj) && !!obj.options.href;\n}\nfunction parseRedirect(obj) {\n  if (obj !== null && typeof obj === \"object\" && obj.isSerializedRedirect) {\n    return redirect(obj);\n  }\n  return void 0;\n}\nexport {\n  isRedirect,\n  isResolvedRedirect,\n  parseRedirect,\n  redirect\n};\n//# sourceMappingURL=redirect.js.map\n","function createLRUCache(max) {\n  const cache = /* @__PURE__ */ new Map();\n  let oldest;\n  let newest;\n  const touch = (entry) => {\n    if (!entry.next) return;\n    if (!entry.prev) {\n      entry.next.prev = void 0;\n      oldest = entry.next;\n      entry.next = void 0;\n      if (newest) {\n        entry.prev = newest;\n        newest.next = entry;\n      }\n    } else {\n      entry.prev.next = entry.next;\n      entry.next.prev = entry.prev;\n      entry.next = void 0;\n      if (newest) {\n        newest.next = entry;\n        entry.prev = newest;\n      }\n    }\n    newest = entry;\n  };\n  return {\n    get(key) {\n      const entry = cache.get(key);\n      if (!entry) return void 0;\n      touch(entry);\n      return entry.value;\n    },\n    set(key, value) {\n      if (cache.size >= max && oldest) {\n        const toDelete = oldest;\n        cache.delete(toDelete.key);\n        if (toDelete.next) {\n          oldest = toDelete.next;\n          toDelete.next.prev = void 0;\n        }\n        if (toDelete === newest) {\n          newest = void 0;\n        }\n      }\n      const existing = cache.get(key);\n      if (existing) {\n        existing.value = value;\n        touch(existing);\n      } else {\n        const entry = { key, value, prev: newest };\n        if (newest) newest.next = entry;\n        newest = entry;\n        if (!oldest) oldest = entry;\n        cache.set(key, entry);\n      }\n    }\n  };\n}\nexport {\n  createLRUCache\n};\n//# sourceMappingURL=lru-cache.js.map\n","import { batch } from \"@tanstack/store\";\nimport invariant from \"tiny-invariant\";\nimport { isPromise, createControlledPromise } from \"./utils.js\";\nimport { isNotFound } from \"./not-found.js\";\nimport { rootRouteId } from \"./root.js\";\nimport { isRedirect } from \"./redirect.js\";\nconst triggerOnReady = (inner) => {\n  if (!inner.rendered) {\n    inner.rendered = true;\n    return inner.onReady?.();\n  }\n};\nconst resolvePreload = (inner, matchId) => {\n  return !!(inner.preload && !inner.router.state.matches.some((d) => d.id === matchId));\n};\nconst _handleNotFound = (inner, err) => {\n  const routeCursor = inner.router.routesById[err.routeId ?? \"\"] ?? inner.router.routeTree;\n  if (!routeCursor.options.notFoundComponent && inner.router.options?.defaultNotFoundComponent) {\n    routeCursor.options.notFoundComponent = inner.router.options.defaultNotFoundComponent;\n  }\n  invariant(\n    routeCursor.options.notFoundComponent,\n    \"No notFoundComponent found. Please set a notFoundComponent on your route or provide a defaultNotFoundComponent to the router.\"\n  );\n  const matchForRoute = inner.matches.find((m) => m.routeId === routeCursor.id);\n  invariant(matchForRoute, \"Could not find match for route: \" + routeCursor.id);\n  inner.updateMatch(matchForRoute.id, (prev) => ({\n    ...prev,\n    status: \"notFound\",\n    error: err,\n    isFetching: false\n  }));\n  if (err.routerCode === \"BEFORE_LOAD\" && routeCursor.parentRoute) {\n    err.routeId = routeCursor.parentRoute.id;\n    _handleNotFound(inner, err);\n  }\n};\nconst handleRedirectAndNotFound = (inner, match, err) => {\n  if (!isRedirect(err) && !isNotFound(err)) return;\n  if (isRedirect(err) && err.redirectHandled && !err.options.reloadDocument) {\n    throw err;\n  }\n  if (match) {\n    match._nonReactive.beforeLoadPromise?.resolve();\n    match._nonReactive.loaderPromise?.resolve();\n    match._nonReactive.beforeLoadPromise = void 0;\n    match._nonReactive.loaderPromise = void 0;\n    const status = isRedirect(err) ? \"redirected\" : \"notFound\";\n    inner.updateMatch(match.id, (prev) => ({\n      ...prev,\n      status,\n      isFetching: false,\n      error: err\n    }));\n    if (isNotFound(err) && !err.routeId) {\n      err.routeId = match.routeId;\n    }\n    match._nonReactive.loadPromise?.resolve();\n  }\n  if (isRedirect(err)) {\n    inner.rendered = true;\n    err.options._fromLocation = inner.location;\n    err.redirectHandled = true;\n    err = inner.router.resolveRedirect(err);\n    throw err;\n  } else {\n    _handleNotFound(inner, err);\n    throw err;\n  }\n};\nconst shouldSkipLoader = (inner, matchId) => {\n  const match = inner.router.getMatch(matchId);\n  if (!inner.router.isServer && match._nonReactive.dehydrated) {\n    return true;\n  }\n  if (inner.router.isServer && match.ssr === false) {\n    return true;\n  }\n  return false;\n};\nconst handleSerialError = (inner, index, err, routerCode) => {\n  const { id: matchId, routeId } = inner.matches[index];\n  const route = inner.router.looseRoutesById[routeId];\n  if (err instanceof Promise) {\n    throw err;\n  }\n  err.routerCode = routerCode;\n  inner.firstBadMatchIndex ??= index;\n  handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err);\n  try {\n    route.options.onError?.(err);\n  } catch (errorHandlerErr) {\n    err = errorHandlerErr;\n    handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), err);\n  }\n  inner.updateMatch(matchId, (prev) => {\n    prev._nonReactive.beforeLoadPromise?.resolve();\n    prev._nonReactive.beforeLoadPromise = void 0;\n    prev._nonReactive.loadPromise?.resolve();\n    return {\n      ...prev,\n      error: err,\n      status: \"error\",\n      isFetching: false,\n      updatedAt: Date.now(),\n      abortController: new AbortController()\n    };\n  });\n};\nconst isBeforeLoadSsr = (inner, matchId, index, route) => {\n  const existingMatch = inner.router.getMatch(matchId);\n  const parentMatchId = inner.matches[index - 1]?.id;\n  const parentMatch = parentMatchId ? inner.router.getMatch(parentMatchId) : void 0;\n  if (inner.router.isShell()) {\n    existingMatch.ssr = matchId === rootRouteId;\n    return;\n  }\n  if (parentMatch?.ssr === false) {\n    existingMatch.ssr = false;\n    return;\n  }\n  const parentOverride = (tempSsr2) => {\n    if (tempSsr2 === true && parentMatch?.ssr === \"data-only\") {\n      return \"data-only\";\n    }\n    return tempSsr2;\n  };\n  const defaultSsr = inner.router.options.defaultSsr ?? true;\n  if (route.options.ssr === void 0) {\n    existingMatch.ssr = parentOverride(defaultSsr);\n    return;\n  }\n  if (typeof route.options.ssr !== \"function\") {\n    existingMatch.ssr = parentOverride(route.options.ssr);\n    return;\n  }\n  const { search, params } = existingMatch;\n  const ssrFnContext = {\n    search: makeMaybe(search, existingMatch.searchError),\n    params: makeMaybe(params, existingMatch.paramsError),\n    location: inner.location,\n    matches: inner.matches.map((match) => ({\n      index: match.index,\n      pathname: match.pathname,\n      fullPath: match.fullPath,\n      staticData: match.staticData,\n      id: match.id,\n      routeId: match.routeId,\n      search: makeMaybe(match.search, match.searchError),\n      params: makeMaybe(match.params, match.paramsError),\n      ssr: match.ssr\n    }))\n  };\n  const tempSsr = route.options.ssr(ssrFnContext);\n  if (isPromise(tempSsr)) {\n    return tempSsr.then((ssr) => {\n      existingMatch.ssr = parentOverride(ssr ?? defaultSsr);\n    });\n  }\n  existingMatch.ssr = parentOverride(tempSsr ?? defaultSsr);\n  return;\n};\nconst setupPendingTimeout = (inner, matchId, route, match) => {\n  if (match._nonReactive.pendingTimeout !== void 0) return;\n  const pendingMs = route.options.pendingMs ?? inner.router.options.defaultPendingMs;\n  const shouldPending = !!(inner.onReady && !inner.router.isServer && !resolvePreload(inner, matchId) && (route.options.loader || route.options.beforeLoad || routeNeedsPreload(route)) && typeof pendingMs === \"number\" && pendingMs !== Infinity && (route.options.pendingComponent ?? inner.router.options?.defaultPendingComponent));\n  if (shouldPending) {\n    const pendingTimeout = setTimeout(() => {\n      triggerOnReady(inner);\n    }, pendingMs);\n    match._nonReactive.pendingTimeout = pendingTimeout;\n  }\n};\nconst preBeforeLoadSetup = (inner, matchId, route) => {\n  const existingMatch = inner.router.getMatch(matchId);\n  if (!existingMatch._nonReactive.beforeLoadPromise && !existingMatch._nonReactive.loaderPromise)\n    return;\n  setupPendingTimeout(inner, matchId, route, existingMatch);\n  const then = () => {\n    const match = inner.router.getMatch(matchId);\n    if (match.preload && (match.status === \"redirected\" || match.status === \"notFound\")) {\n      handleRedirectAndNotFound(inner, match, match.error);\n    }\n  };\n  return existingMatch._nonReactive.beforeLoadPromise ? existingMatch._nonReactive.beforeLoadPromise.then(then) : then();\n};\nconst executeBeforeLoad = (inner, matchId, index, route) => {\n  const match = inner.router.getMatch(matchId);\n  const prevLoadPromise = match._nonReactive.loadPromise;\n  match._nonReactive.loadPromise = createControlledPromise(() => {\n    prevLoadPromise?.resolve();\n  });\n  const { paramsError, searchError } = match;\n  if (paramsError) {\n    handleSerialError(inner, index, paramsError, \"PARSE_PARAMS\");\n  }\n  if (searchError) {\n    handleSerialError(inner, index, searchError, \"VALIDATE_SEARCH\");\n  }\n  setupPendingTimeout(inner, matchId, route, match);\n  const abortController = new AbortController();\n  const parentMatchId = inner.matches[index - 1]?.id;\n  const parentMatch = parentMatchId ? inner.router.getMatch(parentMatchId) : void 0;\n  const parentMatchContext = parentMatch?.context ?? inner.router.options.context ?? void 0;\n  const context = { ...parentMatchContext, ...match.__routeContext };\n  let isPending = false;\n  const pending = () => {\n    if (isPending) return;\n    isPending = true;\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: \"beforeLoad\",\n      fetchCount: prev.fetchCount + 1,\n      abortController,\n      context\n    }));\n  };\n  const resolve = () => {\n    match._nonReactive.beforeLoadPromise?.resolve();\n    match._nonReactive.beforeLoadPromise = void 0;\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: false\n    }));\n  };\n  if (!route.options.beforeLoad) {\n    batch(() => {\n      pending();\n      resolve();\n    });\n    return;\n  }\n  match._nonReactive.beforeLoadPromise = createControlledPromise();\n  const { search, params, cause } = match;\n  const preload = resolvePreload(inner, matchId);\n  const beforeLoadFnContext = {\n    search,\n    abortController,\n    params,\n    preload,\n    context,\n    location: inner.location,\n    navigate: (opts) => inner.router.navigate({\n      ...opts,\n      _fromLocation: inner.location\n    }),\n    buildLocation: inner.router.buildLocation,\n    cause: preload ? \"preload\" : cause,\n    matches: inner.matches,\n    ...inner.router.options.additionalContext\n  };\n  const updateContext = (beforeLoadContext2) => {\n    if (beforeLoadContext2 === void 0) {\n      batch(() => {\n        pending();\n        resolve();\n      });\n      return;\n    }\n    if (isRedirect(beforeLoadContext2) || isNotFound(beforeLoadContext2)) {\n      pending();\n      handleSerialError(inner, index, beforeLoadContext2, \"BEFORE_LOAD\");\n    }\n    batch(() => {\n      pending();\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        __beforeLoadContext: beforeLoadContext2,\n        context: {\n          ...prev.context,\n          ...beforeLoadContext2\n        }\n      }));\n      resolve();\n    });\n  };\n  let beforeLoadContext;\n  try {\n    beforeLoadContext = route.options.beforeLoad(beforeLoadFnContext);\n    if (isPromise(beforeLoadContext)) {\n      pending();\n      return beforeLoadContext.catch((err) => {\n        handleSerialError(inner, index, err, \"BEFORE_LOAD\");\n      }).then(updateContext);\n    }\n  } catch (err) {\n    pending();\n    handleSerialError(inner, index, err, \"BEFORE_LOAD\");\n  }\n  updateContext(beforeLoadContext);\n  return;\n};\nconst handleBeforeLoad = (inner, index) => {\n  const { id: matchId, routeId } = inner.matches[index];\n  const route = inner.router.looseRoutesById[routeId];\n  const serverSsr = () => {\n    if (inner.router.isServer) {\n      const maybePromise = isBeforeLoadSsr(inner, matchId, index, route);\n      if (isPromise(maybePromise)) return maybePromise.then(queueExecution);\n    }\n    return queueExecution();\n  };\n  const execute = () => executeBeforeLoad(inner, matchId, index, route);\n  const queueExecution = () => {\n    if (shouldSkipLoader(inner, matchId)) return;\n    const result = preBeforeLoadSetup(inner, matchId, route);\n    return isPromise(result) ? result.then(execute) : execute();\n  };\n  return serverSsr();\n};\nconst executeHead = (inner, matchId, route) => {\n  const match = inner.router.getMatch(matchId);\n  if (!match) {\n    return;\n  }\n  if (!route.options.head && !route.options.scripts && !route.options.headers) {\n    return;\n  }\n  const assetContext = {\n    matches: inner.matches,\n    match,\n    params: match.params,\n    loaderData: match.loaderData\n  };\n  return Promise.all([\n    route.options.head?.(assetContext),\n    route.options.scripts?.(assetContext),\n    route.options.headers?.(assetContext)\n  ]).then(([headFnContent, scripts, headers]) => {\n    const meta = headFnContent?.meta;\n    const links = headFnContent?.links;\n    const headScripts = headFnContent?.scripts;\n    const styles = headFnContent?.styles;\n    return {\n      meta,\n      links,\n      headScripts,\n      headers,\n      scripts,\n      styles\n    };\n  });\n};\nconst getLoaderContext = (inner, matchId, index, route) => {\n  const parentMatchPromise = inner.matchPromises[index - 1];\n  const { params, loaderDeps, abortController, context, cause } = inner.router.getMatch(matchId);\n  const preload = resolvePreload(inner, matchId);\n  return {\n    params,\n    deps: loaderDeps,\n    preload: !!preload,\n    parentMatchPromise,\n    abortController,\n    context,\n    location: inner.location,\n    navigate: (opts) => inner.router.navigate({\n      ...opts,\n      _fromLocation: inner.location\n    }),\n    cause: preload ? \"preload\" : cause,\n    route,\n    ...inner.router.options.additionalContext\n  };\n};\nconst runLoader = async (inner, matchId, index, route) => {\n  try {\n    const match = inner.router.getMatch(matchId);\n    try {\n      if (!inner.router.isServer || match.ssr === true) {\n        loadRouteChunk(route);\n      }\n      const loaderResult = route.options.loader?.(\n        getLoaderContext(inner, matchId, index, route)\n      );\n      const loaderResultIsPromise = route.options.loader && isPromise(loaderResult);\n      const willLoadSomething = !!(loaderResultIsPromise || route._lazyPromise || route._componentsPromise || route.options.head || route.options.scripts || route.options.headers || match._nonReactive.minPendingPromise);\n      if (willLoadSomething) {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          isFetching: \"loader\"\n        }));\n      }\n      if (route.options.loader) {\n        const loaderData = loaderResultIsPromise ? await loaderResult : loaderResult;\n        handleRedirectAndNotFound(\n          inner,\n          inner.router.getMatch(matchId),\n          loaderData\n        );\n        if (loaderData !== void 0) {\n          inner.updateMatch(matchId, (prev) => ({\n            ...prev,\n            loaderData\n          }));\n        }\n      }\n      if (route._lazyPromise) await route._lazyPromise;\n      const headResult = executeHead(inner, matchId, route);\n      const head = headResult ? await headResult : void 0;\n      const pendingPromise = match._nonReactive.minPendingPromise;\n      if (pendingPromise) await pendingPromise;\n      if (route._componentsPromise) await route._componentsPromise;\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        error: void 0,\n        status: \"success\",\n        isFetching: false,\n        updatedAt: Date.now(),\n        ...head\n      }));\n    } catch (e) {\n      let error = e;\n      const pendingPromise = match._nonReactive.minPendingPromise;\n      if (pendingPromise) await pendingPromise;\n      if (isNotFound(e)) {\n        await route.options.notFoundComponent?.preload?.();\n      }\n      handleRedirectAndNotFound(inner, inner.router.getMatch(matchId), e);\n      try {\n        route.options.onError?.(e);\n      } catch (onErrorError) {\n        error = onErrorError;\n        handleRedirectAndNotFound(\n          inner,\n          inner.router.getMatch(matchId),\n          onErrorError\n        );\n      }\n      const headResult = executeHead(inner, matchId, route);\n      const head = headResult ? await headResult : void 0;\n      inner.updateMatch(matchId, (prev) => ({\n        ...prev,\n        error,\n        status: \"error\",\n        isFetching: false,\n        ...head\n      }));\n    }\n  } catch (err) {\n    const match = inner.router.getMatch(matchId);\n    if (match) {\n      const headResult = executeHead(inner, matchId, route);\n      if (headResult) {\n        const head = await headResult;\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          ...head\n        }));\n      }\n      match._nonReactive.loaderPromise = void 0;\n    }\n    handleRedirectAndNotFound(inner, match, err);\n  }\n};\nconst loadRouteMatch = async (inner, index) => {\n  const { id: matchId, routeId } = inner.matches[index];\n  let loaderShouldRunAsync = false;\n  let loaderIsRunningAsync = false;\n  const route = inner.router.looseRoutesById[routeId];\n  if (shouldSkipLoader(inner, matchId)) {\n    if (inner.router.isServer) {\n      const headResult = executeHead(inner, matchId, route);\n      if (headResult) {\n        const head = await headResult;\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          ...head\n        }));\n      }\n      return inner.router.getMatch(matchId);\n    }\n  } else {\n    const prevMatch = inner.router.getMatch(matchId);\n    if (prevMatch._nonReactive.loaderPromise) {\n      if (prevMatch.status === \"success\" && !inner.sync && !prevMatch.preload) {\n        return prevMatch;\n      }\n      await prevMatch._nonReactive.loaderPromise;\n      const match2 = inner.router.getMatch(matchId);\n      if (match2.error) {\n        handleRedirectAndNotFound(inner, match2, match2.error);\n      }\n    } else {\n      const age = Date.now() - prevMatch.updatedAt;\n      const preload = resolvePreload(inner, matchId);\n      const staleAge = preload ? route.options.preloadStaleTime ?? inner.router.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? inner.router.options.defaultStaleTime ?? 0;\n      const shouldReloadOption = route.options.shouldReload;\n      const shouldReload = typeof shouldReloadOption === \"function\" ? shouldReloadOption(getLoaderContext(inner, matchId, index, route)) : shouldReloadOption;\n      const nextPreload = !!preload && !inner.router.state.matches.some((d) => d.id === matchId);\n      const match2 = inner.router.getMatch(matchId);\n      match2._nonReactive.loaderPromise = createControlledPromise();\n      if (nextPreload !== match2.preload) {\n        inner.updateMatch(matchId, (prev) => ({\n          ...prev,\n          preload: nextPreload\n        }));\n      }\n      const { status, invalid } = match2;\n      loaderShouldRunAsync = status === \"success\" && (invalid || (shouldReload ?? age > staleAge));\n      if (preload && route.options.preload === false) ;\n      else if (loaderShouldRunAsync && !inner.sync) {\n        loaderIsRunningAsync = true;\n        (async () => {\n          try {\n            await runLoader(inner, matchId, index, route);\n            const match3 = inner.router.getMatch(matchId);\n            match3._nonReactive.loaderPromise?.resolve();\n            match3._nonReactive.loadPromise?.resolve();\n            match3._nonReactive.loaderPromise = void 0;\n          } catch (err) {\n            if (isRedirect(err)) {\n              await inner.router.navigate(err.options);\n            }\n          }\n        })();\n      } else if (status !== \"success\" || loaderShouldRunAsync && inner.sync) {\n        await runLoader(inner, matchId, index, route);\n      } else {\n        const headResult = executeHead(inner, matchId, route);\n        if (headResult) {\n          const head = await headResult;\n          inner.updateMatch(matchId, (prev) => ({\n            ...prev,\n            ...head\n          }));\n        }\n      }\n    }\n  }\n  const match = inner.router.getMatch(matchId);\n  if (!loaderIsRunningAsync) {\n    match._nonReactive.loaderPromise?.resolve();\n    match._nonReactive.loadPromise?.resolve();\n  }\n  clearTimeout(match._nonReactive.pendingTimeout);\n  match._nonReactive.pendingTimeout = void 0;\n  if (!loaderIsRunningAsync) match._nonReactive.loaderPromise = void 0;\n  match._nonReactive.dehydrated = void 0;\n  const nextIsFetching = loaderIsRunningAsync ? match.isFetching : false;\n  if (nextIsFetching !== match.isFetching || match.invalid !== false) {\n    inner.updateMatch(matchId, (prev) => ({\n      ...prev,\n      isFetching: nextIsFetching,\n      invalid: false\n    }));\n    return inner.router.getMatch(matchId);\n  } else {\n    return match;\n  }\n};\nasync function loadMatches(arg) {\n  const inner = Object.assign(arg, {\n    matchPromises: []\n  });\n  if (!inner.router.isServer && inner.router.state.matches.some((d) => d._forcePending)) {\n    triggerOnReady(inner);\n  }\n  try {\n    for (let i = 0; i < inner.matches.length; i++) {\n      const beforeLoad = handleBeforeLoad(inner, i);\n      if (isPromise(beforeLoad)) await beforeLoad;\n    }\n    const max = inner.firstBadMatchIndex ?? inner.matches.length;\n    for (let i = 0; i < max; i++) {\n      inner.matchPromises.push(loadRouteMatch(inner, i));\n    }\n    await Promise.all(inner.matchPromises);\n    const readyPromise = triggerOnReady(inner);\n    if (isPromise(readyPromise)) await readyPromise;\n  } catch (err) {\n    if (isNotFound(err) && !inner.preload) {\n      const readyPromise = triggerOnReady(inner);\n      if (isPromise(readyPromise)) await readyPromise;\n      throw err;\n    }\n    if (isRedirect(err)) {\n      throw err;\n    }\n  }\n  return inner.matches;\n}\nasync function loadRouteChunk(route) {\n  if (!route._lazyLoaded && route._lazyPromise === void 0) {\n    if (route.lazyFn) {\n      route._lazyPromise = route.lazyFn().then((lazyRoute) => {\n        const { id: _id, ...options } = lazyRoute.options;\n        Object.assign(route.options, options);\n        route._lazyLoaded = true;\n        route._lazyPromise = void 0;\n      });\n    } else {\n      route._lazyLoaded = true;\n    }\n  }\n  if (!route._componentsLoaded && route._componentsPromise === void 0) {\n    const loadComponents = () => {\n      const preloads = [];\n      for (const type of componentTypes) {\n        const preload = route.options[type]?.preload;\n        if (preload) preloads.push(preload());\n      }\n      if (preloads.length)\n        return Promise.all(preloads).then(() => {\n          route._componentsLoaded = true;\n          route._componentsPromise = void 0;\n        });\n      route._componentsLoaded = true;\n      route._componentsPromise = void 0;\n      return;\n    };\n    route._componentsPromise = route._lazyPromise ? route._lazyPromise.then(loadComponents) : loadComponents();\n  }\n  return route._componentsPromise;\n}\nfunction makeMaybe(value, error) {\n  if (error) {\n    return { status: \"error\", error };\n  }\n  return { status: \"success\", value };\n}\nfunction routeNeedsPreload(route) {\n  for (const componentType of componentTypes) {\n    if (route.options[componentType]?.preload) {\n      return true;\n    }\n  }\n  return false;\n}\nconst componentTypes = [\n  \"component\",\n  \"errorComponent\",\n  \"pendingComponent\",\n  \"notFoundComponent\"\n];\nexport {\n  componentTypes,\n  loadMatches,\n  loadRouteChunk,\n  routeNeedsPreload\n};\n//# sourceMappingURL=load-matches.js.map\n","import { trimPath, joinPaths } from \"./path.js\";\nfunction composeRewrites(rewrites) {\n  return {\n    input: ({ url }) => {\n      for (const rewrite of rewrites) {\n        url = executeRewriteInput(rewrite, url);\n      }\n      return url;\n    },\n    output: ({ url }) => {\n      for (let i = rewrites.length - 1; i >= 0; i--) {\n        url = executeRewriteOutput(rewrites[i], url);\n      }\n      return url;\n    }\n  };\n}\nfunction rewriteBasepath(opts) {\n  const trimmedBasepath = trimPath(opts.basepath);\n  const normalizedBasepath = `/${trimmedBasepath}`;\n  const normalizedBasepathWithSlash = `${normalizedBasepath}/`;\n  const checkBasepath = opts.caseSensitive ? normalizedBasepath : normalizedBasepath.toLowerCase();\n  const checkBasepathWithSlash = opts.caseSensitive ? normalizedBasepathWithSlash : normalizedBasepathWithSlash.toLowerCase();\n  return {\n    input: ({ url }) => {\n      const pathname = opts.caseSensitive ? url.pathname : url.pathname.toLowerCase();\n      if (pathname === checkBasepath) {\n        url.pathname = \"/\";\n      } else if (pathname.startsWith(checkBasepathWithSlash)) {\n        url.pathname = url.pathname.slice(normalizedBasepath.length);\n      }\n      return url;\n    },\n    output: ({ url }) => {\n      url.pathname = joinPaths([\"/\", trimmedBasepath, url.pathname]);\n      return url;\n    }\n  };\n}\nfunction executeRewriteInput(rewrite, url) {\n  const res = rewrite?.input?.({ url });\n  if (res) {\n    if (typeof res === \"string\") {\n      return new URL(res);\n    } else if (res instanceof URL) {\n      return res;\n    }\n  }\n  return url;\n}\nfunction executeRewriteOutput(rewrite, url) {\n  const res = rewrite?.output?.({ url });\n  if (res) {\n    if (typeof res === \"string\") {\n      return new URL(res);\n    } else if (res instanceof URL) {\n      return res;\n    }\n  }\n  return url;\n}\nexport {\n  composeRewrites,\n  executeRewriteInput,\n  executeRewriteOutput,\n  rewriteBasepath\n};\n//# sourceMappingURL=rewrite.js.map\n","import { Store, batch } from \"@tanstack/store\";\nimport { createBrowserHistory, parseHref } from \"@tanstack/history\";\nimport { createControlledPromise, deepEqual, replaceEqualDeep, last, findLast, functionalUpdate } from \"./utils.js\";\nimport { processRouteTree } from \"./process-route-tree.js\";\nimport { trimPath, resolvePath, cleanPath, trimPathRight, matchPathname, interpolatePath } from \"./path.js\";\nimport { isNotFound } from \"./not-found.js\";\nimport { setupScrollRestoration } from \"./scroll-restoration.js\";\nimport { defaultParseSearch, defaultStringifySearch } from \"./searchParams.js\";\nimport { rootRouteId } from \"./root.js\";\nimport { redirect, isRedirect } from \"./redirect.js\";\nimport { createLRUCache } from \"./lru-cache.js\";\nimport { loadMatches, loadRouteChunk, routeNeedsPreload } from \"./load-matches.js\";\nimport { rewriteBasepath, composeRewrites, executeRewriteInput, executeRewriteOutput } from \"./rewrite.js\";\nfunction defaultSerializeError(err) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message\n    };\n    if (process.env.NODE_ENV === \"development\") {\n      obj.stack = err.stack;\n    }\n    return obj;\n  }\n  return {\n    data: err\n  };\n}\nconst trailingSlashOptions = {\n  always: \"always\",\n  never: \"never\",\n  preserve: \"preserve\"\n};\nfunction getLocationChangeInfo(routerState) {\n  const fromLocation = routerState.resolvedLocation;\n  const toLocation = routerState.location;\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname;\n  const hrefChanged = fromLocation?.href !== toLocation.href;\n  const hashChanged = fromLocation?.hash !== toLocation.hash;\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged };\n}\nclass RouterCore {\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(options) {\n    this.tempLocationKey = `${Math.round(\n      Math.random() * 1e7\n    )}`;\n    this.resetNextScroll = true;\n    this.shouldViewTransition = void 0;\n    this.isViewTransitionTypesSupported = void 0;\n    this.subscribers = /* @__PURE__ */ new Set();\n    this.isScrollRestoring = false;\n    this.isScrollRestorationSetup = false;\n    this.startTransition = (fn) => fn();\n    this.update = (newOptions) => {\n      if (newOptions.notFoundRoute) {\n        console.warn(\n          \"The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.\"\n        );\n      }\n      const prevOptions = this.options;\n      const prevBasepath = this.basepath ?? prevOptions?.basepath ?? \"/\";\n      const basepathWasUnset = this.basepath === void 0;\n      const prevRewriteOption = prevOptions?.rewrite;\n      this.options = {\n        ...prevOptions,\n        ...newOptions\n      };\n      this.isServer = this.options.isServer ?? typeof document === \"undefined\";\n      this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters ? new Map(\n        this.options.pathParamsAllowedCharacters.map((char) => [\n          encodeURIComponent(char),\n          char\n        ])\n      ) : void 0;\n      if (!this.history || this.options.history && this.options.history !== this.history) {\n        if (!this.options.history) {\n          if (!this.isServer) {\n            this.history = createBrowserHistory();\n          }\n        } else {\n          this.history = this.options.history;\n        }\n      }\n      this.origin = this.options.origin;\n      if (!this.origin) {\n        if (!this.isServer && window?.origin && window.origin !== \"null\") {\n          this.origin = window.origin;\n        } else {\n          this.origin = \"http://localhost\";\n        }\n      }\n      if (this.history) {\n        this.updateLatestLocation();\n      }\n      if (this.options.routeTree !== this.routeTree) {\n        this.routeTree = this.options.routeTree;\n        this.buildRouteTree();\n      }\n      if (!this.__store && this.latestLocation) {\n        this.__store = new Store(getInitialRouterState(this.latestLocation), {\n          onUpdate: () => {\n            this.__store.state = {\n              ...this.state,\n              cachedMatches: this.state.cachedMatches.filter(\n                (d) => ![\"redirected\"].includes(d.status)\n              )\n            };\n          }\n        });\n        setupScrollRestoration(this);\n      }\n      let needsLocationUpdate = false;\n      const nextBasepath = this.options.basepath ?? \"/\";\n      const nextRewriteOption = this.options.rewrite;\n      const basepathChanged = basepathWasUnset || prevBasepath !== nextBasepath;\n      const rewriteChanged = prevRewriteOption !== nextRewriteOption;\n      if (basepathChanged || rewriteChanged) {\n        this.basepath = nextBasepath;\n        const rewrites = [];\n        if (trimPath(nextBasepath) !== \"\") {\n          rewrites.push(\n            rewriteBasepath({\n              basepath: nextBasepath\n            })\n          );\n        }\n        if (nextRewriteOption) {\n          rewrites.push(nextRewriteOption);\n        }\n        this.rewrite = rewrites.length === 0 ? void 0 : rewrites.length === 1 ? rewrites[0] : composeRewrites(rewrites);\n        if (this.history) {\n          this.updateLatestLocation();\n        }\n        needsLocationUpdate = true;\n      }\n      if (needsLocationUpdate && this.__store) {\n        this.__store.state = {\n          ...this.state,\n          location: this.latestLocation\n        };\n      }\n      if (typeof window !== \"undefined\" && \"CSS\" in window && typeof window.CSS?.supports === \"function\") {\n        this.isViewTransitionTypesSupported = window.CSS.supports(\n          \"selector(:active-view-transition-type(a)\"\n        );\n      }\n    };\n    this.updateLatestLocation = () => {\n      this.latestLocation = this.parseLocation(\n        this.history.location,\n        this.latestLocation\n      );\n    };\n    this.buildRouteTree = () => {\n      const { routesById, routesByPath, flatRoutes } = processRouteTree({\n        routeTree: this.routeTree,\n        initRoute: (route, i) => {\n          route.init({\n            originalIndex: i\n          });\n        }\n      });\n      this.routesById = routesById;\n      this.routesByPath = routesByPath;\n      this.flatRoutes = flatRoutes;\n      const notFoundRoute = this.options.notFoundRoute;\n      if (notFoundRoute) {\n        notFoundRoute.init({\n          originalIndex: 99999999999\n        });\n        this.routesById[notFoundRoute.id] = notFoundRoute;\n      }\n    };\n    this.subscribe = (eventType, fn) => {\n      const listener = {\n        eventType,\n        fn\n      };\n      this.subscribers.add(listener);\n      return () => {\n        this.subscribers.delete(listener);\n      };\n    };\n    this.emit = (routerEvent) => {\n      this.subscribers.forEach((listener) => {\n        if (listener.eventType === routerEvent.type) {\n          listener.fn(routerEvent);\n        }\n      });\n    };\n    this.parseLocation = (locationToParse, previousLocation) => {\n      const parse = ({\n        href,\n        state\n      }) => {\n        const fullUrl = new URL(href, this.origin);\n        const url = executeRewriteInput(this.rewrite, fullUrl);\n        const parsedSearch = this.options.parseSearch(url.search);\n        const searchStr = this.options.stringifySearch(parsedSearch);\n        url.search = searchStr;\n        const fullPath = url.href.replace(url.origin, \"\");\n        const { pathname, hash } = url;\n        return {\n          href: fullPath,\n          publicHref: href,\n          url: url.href,\n          pathname,\n          searchStr,\n          search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n          hash: hash.split(\"#\").reverse()[0] ?? \"\",\n          state: replaceEqualDeep(previousLocation?.state, state)\n        };\n      };\n      const location = parse(locationToParse);\n      const { __tempLocation, __tempKey } = location.state;\n      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n        const parsedTempLocation = parse(__tempLocation);\n        parsedTempLocation.state.key = location.state.key;\n        parsedTempLocation.state.__TSR_key = location.state.__TSR_key;\n        delete parsedTempLocation.state.__tempLocation;\n        return {\n          ...parsedTempLocation,\n          maskedLocation: location\n        };\n      }\n      return location;\n    };\n    this.resolvePathWithBase = (from, path) => {\n      const resolvedPath = resolvePath({\n        base: from,\n        to: cleanPath(path),\n        trailingSlash: this.options.trailingSlash,\n        parseCache: this.parsePathnameCache\n      });\n      return resolvedPath;\n    };\n    this.matchRoutes = (pathnameOrNext, locationSearchOrOpts, opts) => {\n      if (typeof pathnameOrNext === \"string\") {\n        return this.matchRoutesInternal(\n          {\n            pathname: pathnameOrNext,\n            search: locationSearchOrOpts\n          },\n          opts\n        );\n      }\n      return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts);\n    };\n    this.parsePathnameCache = createLRUCache(1e3);\n    this.getMatchedRoutes = (pathname, routePathname) => {\n      return getMatchedRoutes({\n        pathname,\n        routePathname,\n        caseSensitive: this.options.caseSensitive,\n        routesByPath: this.routesByPath,\n        routesById: this.routesById,\n        flatRoutes: this.flatRoutes,\n        parseCache: this.parsePathnameCache\n      });\n    };\n    this.cancelMatch = (id) => {\n      const match = this.getMatch(id);\n      if (!match) return;\n      match.abortController.abort();\n      clearTimeout(match._nonReactive.pendingTimeout);\n      match._nonReactive.pendingTimeout = void 0;\n    };\n    this.cancelMatches = () => {\n      this.state.pendingMatches?.forEach((match) => {\n        this.cancelMatch(match.id);\n      });\n    };\n    this.buildLocation = (opts) => {\n      const build = (dest = {}) => {\n        const currentLocation = dest._fromLocation || this.latestLocation;\n        const allCurrentLocationMatches = this.matchRoutes(currentLocation, {\n          _buildLocation: true\n        });\n        const lastMatch = last(allCurrentLocationMatches);\n        if (dest.from && process.env.NODE_ENV !== \"production\" && dest._isNavigate) {\n          const allFromMatches = this.getMatchedRoutes(\n            dest.from,\n            void 0\n          ).matchedRoutes;\n          const matchedFrom = findLast(allCurrentLocationMatches, (d) => {\n            return comparePaths(d.fullPath, dest.from);\n          });\n          const matchedCurrent = findLast(allFromMatches, (d) => {\n            return comparePaths(d.fullPath, lastMatch.fullPath);\n          });\n          if (!matchedFrom && !matchedCurrent) {\n            console.warn(`Could not find match for from: ${dest.from}`);\n          }\n        }\n        const defaultedFromPath = dest.unsafeRelative === \"path\" ? currentLocation.pathname : dest.from ?? lastMatch.fullPath;\n        const fromPath = this.resolvePathWithBase(defaultedFromPath, \".\");\n        const fromSearch = lastMatch.search;\n        const fromParams = { ...lastMatch.params };\n        const nextTo = dest.to ? this.resolvePathWithBase(fromPath, `${dest.to}`) : this.resolvePathWithBase(fromPath, \".\");\n        const nextParams = dest.params === false || dest.params === null ? {} : (dest.params ?? true) === true ? fromParams : Object.assign(\n          fromParams,\n          functionalUpdate(dest.params, fromParams)\n        );\n        const interpolatedNextTo = interpolatePath({\n          path: nextTo,\n          params: nextParams,\n          parseCache: this.parsePathnameCache\n        }).interpolatedPath;\n        const destRoutes = this.matchRoutes(interpolatedNextTo, void 0, {\n          _buildLocation: true\n        }).map((d) => this.looseRoutesById[d.routeId]);\n        if (Object.keys(nextParams).length > 0) {\n          for (const route of destRoutes) {\n            const fn = route.options.params?.stringify ?? route.options.stringifyParams;\n            if (fn) {\n              Object.assign(nextParams, fn(nextParams));\n            }\n          }\n        }\n        const nextPathname = interpolatePath({\n          // Use the original template path for interpolation\n          // This preserves the original parameter syntax including optional parameters\n          path: nextTo,\n          params: nextParams,\n          leaveWildcards: false,\n          leaveParams: opts.leaveParams,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n          parseCache: this.parsePathnameCache\n        }).interpolatedPath;\n        let nextSearch = fromSearch;\n        if (opts._includeValidateSearch && this.options.search?.strict) {\n          const validatedSearch = {};\n          destRoutes.forEach((route) => {\n            if (route.options.validateSearch) {\n              try {\n                Object.assign(\n                  validatedSearch,\n                  validateSearch(route.options.validateSearch, {\n                    ...validatedSearch,\n                    ...nextSearch\n                  })\n                );\n              } catch {\n              }\n            }\n          });\n          nextSearch = validatedSearch;\n        }\n        nextSearch = applySearchMiddleware({\n          search: nextSearch,\n          dest,\n          destRoutes,\n          _includeValidateSearch: opts._includeValidateSearch\n        });\n        nextSearch = replaceEqualDeep(fromSearch, nextSearch);\n        const searchStr = this.options.stringifySearch(nextSearch);\n        const hash = dest.hash === true ? currentLocation.hash : dest.hash ? functionalUpdate(dest.hash, currentLocation.hash) : void 0;\n        const hashStr = hash ? `#${hash}` : \"\";\n        let nextState = dest.state === true ? currentLocation.state : dest.state ? functionalUpdate(dest.state, currentLocation.state) : {};\n        nextState = replaceEqualDeep(currentLocation.state, nextState);\n        const fullPath = `${nextPathname}${searchStr}${hashStr}`;\n        const url = new URL(fullPath, this.origin);\n        const rewrittenUrl = executeRewriteOutput(this.rewrite, url);\n        return {\n          publicHref: rewrittenUrl.pathname + rewrittenUrl.search + rewrittenUrl.hash,\n          href: fullPath,\n          url: rewrittenUrl.href,\n          pathname: nextPathname,\n          search: nextSearch,\n          searchStr,\n          state: nextState,\n          hash: hash ?? \"\",\n          unmaskOnReload: dest.unmaskOnReload\n        };\n      };\n      const buildWithMatches = (dest = {}, maskedDest) => {\n        const next = build(dest);\n        let maskedNext = maskedDest ? build(maskedDest) : void 0;\n        if (!maskedNext) {\n          let params = {};\n          const foundMask = this.options.routeMasks?.find((d) => {\n            const match = matchPathname(\n              next.pathname,\n              {\n                to: d.from,\n                caseSensitive: false,\n                fuzzy: false\n              },\n              this.parsePathnameCache\n            );\n            if (match) {\n              params = match;\n              return true;\n            }\n            return false;\n          });\n          if (foundMask) {\n            const { from: _from, ...maskProps } = foundMask;\n            maskedDest = {\n              from: opts.from,\n              ...maskProps,\n              params\n            };\n            maskedNext = build(maskedDest);\n          }\n        }\n        if (maskedNext) {\n          next.maskedLocation = maskedNext;\n        }\n        return next;\n      };\n      if (opts.mask) {\n        return buildWithMatches(opts, {\n          from: opts.from,\n          ...opts.mask\n        });\n      }\n      return buildWithMatches(opts);\n    };\n    this.commitLocation = ({\n      viewTransition,\n      ignoreBlocker,\n      ...next\n    }) => {\n      const isSameState = () => {\n        const ignoredProps = [\n          \"key\",\n          // TODO: Remove in v2 - use __TSR_key instead\n          \"__TSR_key\",\n          \"__TSR_index\",\n          \"__hashScrollIntoViewOptions\"\n        ];\n        ignoredProps.forEach((prop) => {\n          next.state[prop] = this.latestLocation.state[prop];\n        });\n        const isEqual = deepEqual(next.state, this.latestLocation.state);\n        ignoredProps.forEach((prop) => {\n          delete next.state[prop];\n        });\n        return isEqual;\n      };\n      const isSameUrl = trimPathRight(this.latestLocation.href) === trimPathRight(next.href);\n      const previousCommitPromise = this.commitLocationPromise;\n      this.commitLocationPromise = createControlledPromise(() => {\n        previousCommitPromise?.resolve();\n      });\n      if (isSameUrl && isSameState()) {\n        this.load();\n      } else {\n        let { maskedLocation, hashScrollIntoView, ...nextHistory } = next;\n        if (maskedLocation) {\n          nextHistory = {\n            ...maskedLocation,\n            state: {\n              ...maskedLocation.state,\n              __tempKey: void 0,\n              __tempLocation: {\n                ...nextHistory,\n                search: nextHistory.searchStr,\n                state: {\n                  ...nextHistory.state,\n                  __tempKey: void 0,\n                  __tempLocation: void 0,\n                  __TSR_key: void 0,\n                  key: void 0\n                  // TODO: Remove in v2 - use __TSR_key instead\n                }\n              }\n            }\n          };\n          if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {\n            nextHistory.state.__tempKey = this.tempLocationKey;\n          }\n        }\n        nextHistory.state.__hashScrollIntoViewOptions = hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true;\n        this.shouldViewTransition = viewTransition;\n        this.history[next.replace ? \"replace\" : \"push\"](\n          nextHistory.publicHref,\n          nextHistory.state,\n          { ignoreBlocker }\n        );\n      }\n      this.resetNextScroll = next.resetScroll ?? true;\n      if (!this.history.subscribers.size) {\n        this.load();\n      }\n      return this.commitLocationPromise;\n    };\n    this.buildAndCommitLocation = ({\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      viewTransition,\n      ignoreBlocker,\n      href,\n      ...rest\n    } = {}) => {\n      if (href) {\n        const currentIndex = this.history.location.state.__TSR_index;\n        const parsed = parseHref(href, {\n          __TSR_index: replace ? currentIndex : currentIndex + 1\n        });\n        rest.to = parsed.pathname;\n        rest.search = this.options.parseSearch(parsed.search);\n        rest.hash = parsed.hash.slice(1);\n      }\n      const location = this.buildLocation({\n        ...rest,\n        _includeValidateSearch: true\n      });\n      return this.commitLocation({\n        ...location,\n        viewTransition,\n        replace,\n        resetScroll,\n        hashScrollIntoView,\n        ignoreBlocker\n      });\n    };\n    this.navigate = ({ to, reloadDocument, href, ...rest }) => {\n      if (!reloadDocument && href) {\n        try {\n          new URL(`${href}`);\n          reloadDocument = true;\n        } catch {\n        }\n      }\n      if (reloadDocument) {\n        if (!href) {\n          const location = this.buildLocation({ to, ...rest });\n          href = location.url;\n        }\n        if (rest.replace) {\n          window.location.replace(href);\n        } else {\n          window.location.href = href;\n        }\n        return Promise.resolve();\n      }\n      return this.buildAndCommitLocation({\n        ...rest,\n        href,\n        to,\n        _isNavigate: true\n      });\n    };\n    this.beforeLoad = () => {\n      this.cancelMatches();\n      this.updateLatestLocation();\n      if (this.isServer) {\n        const nextLocation = this.buildLocation({\n          to: this.latestLocation.pathname,\n          search: true,\n          params: true,\n          hash: true,\n          state: true,\n          _includeValidateSearch: true\n        });\n        const normalizeUrl = (url) => {\n          try {\n            return encodeURI(decodeURI(url));\n          } catch {\n            return url;\n          }\n        };\n        if (trimPath(normalizeUrl(this.latestLocation.href)) !== trimPath(normalizeUrl(nextLocation.href))) {\n          let href = nextLocation.url;\n          if (this.origin && href.startsWith(this.origin)) {\n            href = href.replace(this.origin, \"\") || \"/\";\n          }\n          throw redirect({ href });\n        }\n      }\n      const pendingMatches = this.matchRoutes(this.latestLocation);\n      this.__store.setState((s) => ({\n        ...s,\n        status: \"pending\",\n        statusCode: 200,\n        isLoading: true,\n        location: this.latestLocation,\n        pendingMatches,\n        // If a cached moved to pendingMatches, remove it from cachedMatches\n        cachedMatches: s.cachedMatches.filter(\n          (d) => !pendingMatches.some((e) => e.id === d.id)\n        )\n      }));\n    };\n    this.load = async (opts) => {\n      let redirect2;\n      let notFound;\n      let loadPromise;\n      loadPromise = new Promise((resolve) => {\n        this.startTransition(async () => {\n          try {\n            this.beforeLoad();\n            const next = this.latestLocation;\n            const prevLocation = this.state.resolvedLocation;\n            if (!this.state.redirect) {\n              this.emit({\n                type: \"onBeforeNavigate\",\n                ...getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next\n                })\n              });\n            }\n            this.emit({\n              type: \"onBeforeLoad\",\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next\n              })\n            });\n            await loadMatches({\n              router: this,\n              sync: opts?.sync,\n              matches: this.state.pendingMatches,\n              location: next,\n              updateMatch: this.updateMatch,\n              // eslint-disable-next-line @typescript-eslint/require-await\n              onReady: async () => {\n                this.startViewTransition(async () => {\n                  let exitingMatches;\n                  let enteringMatches;\n                  let stayingMatches;\n                  batch(() => {\n                    this.__store.setState((s) => {\n                      const previousMatches = s.matches;\n                      const newMatches = s.pendingMatches || s.matches;\n                      exitingMatches = previousMatches.filter(\n                        (match) => !newMatches.some((d) => d.id === match.id)\n                      );\n                      enteringMatches = newMatches.filter(\n                        (match) => !previousMatches.some((d) => d.id === match.id)\n                      );\n                      stayingMatches = previousMatches.filter(\n                        (match) => newMatches.some((d) => d.id === match.id)\n                      );\n                      return {\n                        ...s,\n                        isLoading: false,\n                        loadedAt: Date.now(),\n                        matches: newMatches,\n                        pendingMatches: void 0,\n                        cachedMatches: [\n                          ...s.cachedMatches,\n                          ...exitingMatches.filter((d) => d.status !== \"error\")\n                        ]\n                      };\n                    });\n                    this.clearExpiredCache();\n                  });\n                  [\n                    [exitingMatches, \"onLeave\"],\n                    [enteringMatches, \"onEnter\"],\n                    [stayingMatches, \"onStay\"]\n                  ].forEach(([matches, hook]) => {\n                    matches.forEach((match) => {\n                      this.looseRoutesById[match.routeId].options[hook]?.(match);\n                    });\n                  });\n                });\n              }\n            });\n          } catch (err) {\n            if (isRedirect(err)) {\n              redirect2 = err;\n              if (!this.isServer) {\n                this.navigate({\n                  ...redirect2.options,\n                  replace: true,\n                  ignoreBlocker: true\n                });\n              }\n            } else if (isNotFound(err)) {\n              notFound = err;\n            }\n            this.__store.setState((s) => ({\n              ...s,\n              statusCode: redirect2 ? redirect2.status : notFound ? 404 : s.matches.some((d) => d.status === \"error\") ? 500 : 200,\n              redirect: redirect2\n            }));\n          }\n          if (this.latestLoadPromise === loadPromise) {\n            this.commitLocationPromise?.resolve();\n            this.latestLoadPromise = void 0;\n            this.commitLocationPromise = void 0;\n          }\n          resolve();\n        });\n      });\n      this.latestLoadPromise = loadPromise;\n      await loadPromise;\n      while (this.latestLoadPromise && loadPromise !== this.latestLoadPromise) {\n        await this.latestLoadPromise;\n      }\n      let newStatusCode = void 0;\n      if (this.hasNotFoundMatch()) {\n        newStatusCode = 404;\n      } else if (this.__store.state.matches.some((d) => d.status === \"error\")) {\n        newStatusCode = 500;\n      }\n      if (newStatusCode !== void 0) {\n        this.__store.setState((s) => ({\n          ...s,\n          statusCode: newStatusCode\n        }));\n      }\n    };\n    this.startViewTransition = (fn) => {\n      const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;\n      delete this.shouldViewTransition;\n      if (shouldViewTransition && typeof document !== \"undefined\" && \"startViewTransition\" in document && typeof document.startViewTransition === \"function\") {\n        let startViewTransitionParams;\n        if (typeof shouldViewTransition === \"object\" && this.isViewTransitionTypesSupported) {\n          const next = this.latestLocation;\n          const prevLocation = this.state.resolvedLocation;\n          const resolvedViewTransitionTypes = typeof shouldViewTransition.types === \"function\" ? shouldViewTransition.types(\n            getLocationChangeInfo({\n              resolvedLocation: prevLocation,\n              location: next\n            })\n          ) : shouldViewTransition.types;\n          if (resolvedViewTransitionTypes === false) {\n            fn();\n            return;\n          }\n          startViewTransitionParams = {\n            update: fn,\n            types: resolvedViewTransitionTypes\n          };\n        } else {\n          startViewTransitionParams = fn;\n        }\n        document.startViewTransition(startViewTransitionParams);\n      } else {\n        fn();\n      }\n    };\n    this.updateMatch = (id, updater) => {\n      const matchesKey = this.state.pendingMatches?.some((d) => d.id === id) ? \"pendingMatches\" : this.state.matches.some((d) => d.id === id) ? \"matches\" : this.state.cachedMatches.some((d) => d.id === id) ? \"cachedMatches\" : \"\";\n      if (matchesKey) {\n        this.__store.setState((s) => ({\n          ...s,\n          [matchesKey]: s[matchesKey]?.map((d) => d.id === id ? updater(d) : d)\n        }));\n      }\n    };\n    this.getMatch = (matchId) => {\n      const findFn = (d) => d.id === matchId;\n      return this.state.cachedMatches.find(findFn) ?? this.state.pendingMatches?.find(findFn) ?? this.state.matches.find(findFn);\n    };\n    this.invalidate = (opts) => {\n      const invalidate = (d) => {\n        if (opts?.filter?.(d) ?? true) {\n          return {\n            ...d,\n            invalid: true,\n            ...opts?.forcePending || d.status === \"error\" ? { status: \"pending\", error: void 0 } : void 0\n          };\n        }\n        return d;\n      };\n      this.__store.setState((s) => ({\n        ...s,\n        matches: s.matches.map(invalidate),\n        cachedMatches: s.cachedMatches.map(invalidate),\n        pendingMatches: s.pendingMatches?.map(invalidate)\n      }));\n      this.shouldViewTransition = false;\n      return this.load({ sync: opts?.sync });\n    };\n    this.resolveRedirect = (redirect2) => {\n      if (!redirect2.options.href) {\n        const location = this.buildLocation(redirect2.options);\n        let href = location.url;\n        if (this.origin && href.startsWith(this.origin)) {\n          href = href.replace(this.origin, \"\") || \"/\";\n        }\n        redirect2.options.href = location.href;\n        redirect2.headers.set(\"Location\", href);\n      }\n      if (!redirect2.headers.get(\"Location\")) {\n        redirect2.headers.set(\"Location\", redirect2.options.href);\n      }\n      return redirect2;\n    };\n    this.clearCache = (opts) => {\n      const filter = opts?.filter;\n      if (filter !== void 0) {\n        this.__store.setState((s) => {\n          return {\n            ...s,\n            cachedMatches: s.cachedMatches.filter(\n              (m) => !filter(m)\n            )\n          };\n        });\n      } else {\n        this.__store.setState((s) => {\n          return {\n            ...s,\n            cachedMatches: []\n          };\n        });\n      }\n    };\n    this.clearExpiredCache = () => {\n      const filter = (d) => {\n        const route = this.looseRoutesById[d.routeId];\n        if (!route.options.loader) {\n          return true;\n        }\n        const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;\n        const isError = d.status === \"error\";\n        if (isError) return true;\n        const gcEligible = Date.now() - d.updatedAt >= gcTime;\n        return gcEligible;\n      };\n      this.clearCache({ filter });\n    };\n    this.loadRouteChunk = loadRouteChunk;\n    this.preloadRoute = async (opts) => {\n      const next = this.buildLocation(opts);\n      let matches = this.matchRoutes(next, {\n        throwOnError: true,\n        preload: true,\n        dest: opts\n      });\n      const activeMatchIds = new Set(\n        [...this.state.matches, ...this.state.pendingMatches ?? []].map(\n          (d) => d.id\n        )\n      );\n      const loadedMatchIds = /* @__PURE__ */ new Set([\n        ...activeMatchIds,\n        ...this.state.cachedMatches.map((d) => d.id)\n      ]);\n      batch(() => {\n        matches.forEach((match) => {\n          if (!loadedMatchIds.has(match.id)) {\n            this.__store.setState((s) => ({\n              ...s,\n              cachedMatches: [...s.cachedMatches, match]\n            }));\n          }\n        });\n      });\n      try {\n        matches = await loadMatches({\n          router: this,\n          matches,\n          location: next,\n          preload: true,\n          updateMatch: (id, updater) => {\n            if (activeMatchIds.has(id)) {\n              matches = matches.map((d) => d.id === id ? updater(d) : d);\n            } else {\n              this.updateMatch(id, updater);\n            }\n          }\n        });\n        return matches;\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (err.options.reloadDocument) {\n            return void 0;\n          }\n          return await this.preloadRoute({\n            ...err.options,\n            _fromLocation: next\n          });\n        }\n        if (!isNotFound(err)) {\n          console.error(err);\n        }\n        return void 0;\n      }\n    };\n    this.matchRoute = (location, opts) => {\n      const matchLocation = {\n        ...location,\n        to: location.to ? this.resolvePathWithBase(\n          location.from || \"\",\n          location.to\n        ) : void 0,\n        params: location.params || {},\n        leaveParams: true\n      };\n      const next = this.buildLocation(matchLocation);\n      if (opts?.pending && this.state.status !== \"pending\") {\n        return false;\n      }\n      const pending = opts?.pending === void 0 ? !this.state.isLoading : opts.pending;\n      const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation || this.state.location;\n      const match = matchPathname(\n        baseLocation.pathname,\n        {\n          ...opts,\n          to: next.pathname\n        },\n        this.parsePathnameCache\n      );\n      if (!match) {\n        return false;\n      }\n      if (location.params) {\n        if (!deepEqual(match, location.params, { partial: true })) {\n          return false;\n        }\n      }\n      if (match && (opts?.includeSearch ?? true)) {\n        return deepEqual(baseLocation.search, next.search, { partial: true }) ? match : false;\n      }\n      return match;\n    };\n    this.hasNotFoundMatch = () => {\n      return this.__store.state.matches.some(\n        (d) => d.status === \"notFound\" || d.globalNotFound\n      );\n    };\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1e3,\n      defaultPendingMinMs: 500,\n      context: void 0,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? \"fuzzy\",\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch\n    });\n    if (typeof document !== \"undefined\") {\n      self.__TSR_ROUTER__ = this;\n    }\n  }\n  isShell() {\n    return !!this.options.isShell;\n  }\n  isPrerendering() {\n    return !!this.options.isPrerendering;\n  }\n  get state() {\n    return this.__store.state;\n  }\n  get looseRoutesById() {\n    return this.routesById;\n  }\n  matchRoutesInternal(next, opts) {\n    const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(\n      next.pathname,\n      opts?.dest?.to\n    );\n    let isGlobalNotFound = false;\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute ? foundRoute.path !== \"/\" && routeParams[\"**\"] : (\n        // Or if we didn't find a route and we have left over path\n        trimPathRight(next.pathname)\n      )\n    ) {\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute);\n      } else {\n        isGlobalNotFound = true;\n      }\n    }\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return void 0;\n      }\n      if (this.options.notFoundMode !== \"root\") {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i];\n          if (route.children) {\n            return route.id;\n          }\n        }\n      }\n      return rootRouteId;\n    })();\n    const matches = [];\n    const getParentContext = (parentMatch) => {\n      const parentMatchId = parentMatch?.id;\n      const parentContext = !parentMatchId ? this.options.context ?? void 0 : parentMatch.context ?? this.options.context ?? void 0;\n      return parentContext;\n    };\n    matchedRoutes.forEach((route, index) => {\n      const parentMatch = matches[index - 1];\n      const [preMatchSearch, strictMatchSearch, searchError] = (() => {\n        const parentSearch = parentMatch?.search ?? next.search;\n        const parentStrictSearch = parentMatch?._strictSearch ?? void 0;\n        try {\n          const strictSearch = validateSearch(route.options.validateSearch, { ...parentSearch }) ?? void 0;\n          return [\n            {\n              ...parentSearch,\n              ...strictSearch\n            },\n            { ...parentStrictSearch, ...strictSearch },\n            void 0\n          ];\n        } catch (err) {\n          let searchParamError = err;\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err\n            });\n          }\n          if (opts?.throwOnError) {\n            throw searchParamError;\n          }\n          return [parentSearch, {}, searchParamError];\n        }\n      })();\n      const loaderDeps = route.options.loaderDeps?.({\n        search: preMatchSearch\n      }) ?? \"\";\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : \"\";\n      const { interpolatedPath, usedParams } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap\n      });\n      const matchId = interpolatePath({\n        path: route.id,\n        params: routeParams,\n        leaveWildcards: true,\n        decodeCharMap: this.pathParamsDecodeCharMap,\n        parseCache: this.parsePathnameCache\n      }).interpolatedPath + loaderDepsHash;\n      const existingMatch = this.getMatch(matchId);\n      const previousMatch = this.state.matches.find(\n        (d) => d.routeId === route.id\n      );\n      const strictParams = existingMatch?._strictParams ?? usedParams;\n      let paramsError = void 0;\n      if (!existingMatch) {\n        const strictParseParams = route.options.params?.parse ?? route.options.parseParams;\n        if (strictParseParams) {\n          try {\n            Object.assign(\n              strictParams,\n              strictParseParams(strictParams)\n            );\n          } catch (err) {\n            paramsError = new PathParamError(err.message, {\n              cause: err\n            });\n            if (opts?.throwOnError) {\n              throw paramsError;\n            }\n          }\n        }\n      }\n      Object.assign(routeParams, strictParams);\n      const cause = previousMatch ? \"stay\" : \"enter\";\n      let match;\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,\n          _strictParams: strictParams,\n          search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch\n        };\n      } else {\n        const status = route.options.loader || route.options.beforeLoad || route.lazyFn || routeNeedsPreload(route) ? \"pending\" : \"success\";\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,\n          _strictParams: strictParams,\n          pathname: interpolatedPath,\n          updatedAt: Date.now(),\n          search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: void 0,\n          status,\n          isFetching: false,\n          error: void 0,\n          paramsError,\n          __routeContext: void 0,\n          _nonReactive: {\n            loadPromise: createControlledPromise()\n          },\n          __beforeLoadContext: void 0,\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps) : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: void 0,\n          scripts: void 0,\n          headScripts: void 0,\n          meta: void 0,\n          staticData: route.options.staticData || {},\n          fullPath: route.fullPath\n        };\n      }\n      if (!opts?.preload) {\n        match.globalNotFound = globalNotFoundRouteId === route.id;\n      }\n      match.searchError = searchError;\n      const parentContext = getParentContext(parentMatch);\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext\n      };\n      matches.push(match);\n    });\n    matches.forEach((match, index) => {\n      const route = this.looseRoutesById[match.routeId];\n      const existingMatch = this.getMatch(match.id);\n      if (!existingMatch && opts?._buildLocation !== true) {\n        const parentMatch = matches[index - 1];\n        const parentContext = getParentContext(parentMatch);\n        if (route.options.context) {\n          const contextFnContext = {\n            deps: match.loaderDeps,\n            params: match.params,\n            context: parentContext ?? {},\n            location: next,\n            navigate: (opts2) => this.navigate({ ...opts2, _fromLocation: next }),\n            buildLocation: this.buildLocation,\n            cause: match.cause,\n            abortController: match.abortController,\n            preload: !!match.preload,\n            matches\n          };\n          match.__routeContext = route.options.context(contextFnContext) ?? void 0;\n        }\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext\n        };\n      }\n    });\n    return matches;\n  }\n}\nclass SearchParamError extends Error {\n}\nclass PathParamError extends Error {\n}\nconst normalize = (str) => str.endsWith(\"/\") && str.length > 1 ? str.slice(0, -1) : str;\nfunction comparePaths(a, b) {\n  return normalize(a) === normalize(b);\n}\nfunction lazyFn(fn, key) {\n  return async (...args) => {\n    const imported = await fn();\n    return imported[key || \"default\"](...args);\n  };\n}\nfunction getInitialRouterState(location) {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: \"idle\",\n    resolvedLocation: void 0,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200\n  };\n}\nfunction validateSearch(validateSearch2, input) {\n  if (validateSearch2 == null) return {};\n  if (\"~standard\" in validateSearch2) {\n    const result = validateSearch2[\"~standard\"].validate(input);\n    if (result instanceof Promise)\n      throw new SearchParamError(\"Async validation not supported\");\n    if (result.issues)\n      throw new SearchParamError(JSON.stringify(result.issues, void 0, 2), {\n        cause: result\n      });\n    return result.value;\n  }\n  if (\"parse\" in validateSearch2) {\n    return validateSearch2.parse(input);\n  }\n  if (typeof validateSearch2 === \"function\") {\n    return validateSearch2(input);\n  }\n  return {};\n}\nfunction getMatchedRoutes({\n  pathname,\n  routePathname,\n  caseSensitive,\n  routesByPath,\n  routesById,\n  flatRoutes,\n  parseCache\n}) {\n  let routeParams = {};\n  const trimmedPath = trimPathRight(pathname);\n  const getMatchedParams = (route) => {\n    const result = matchPathname(\n      trimmedPath,\n      {\n        to: route.fullPath,\n        caseSensitive: route.options?.caseSensitive ?? caseSensitive,\n        // we need fuzzy matching for `notFoundMode: 'fuzzy'`\n        fuzzy: true\n      },\n      parseCache\n    );\n    return result;\n  };\n  let foundRoute = routePathname !== void 0 ? routesByPath[routePathname] : void 0;\n  if (foundRoute) {\n    routeParams = getMatchedParams(foundRoute);\n  } else {\n    let fuzzyMatch = void 0;\n    for (const route of flatRoutes) {\n      const matchedParams = getMatchedParams(route);\n      if (matchedParams) {\n        if (route.path !== \"/\" && matchedParams[\"**\"]) {\n          if (!fuzzyMatch) {\n            fuzzyMatch = { foundRoute: route, routeParams: matchedParams };\n          }\n        } else {\n          foundRoute = route;\n          routeParams = matchedParams;\n          break;\n        }\n      }\n    }\n    if (!foundRoute && fuzzyMatch) {\n      foundRoute = fuzzyMatch.foundRoute;\n      routeParams = fuzzyMatch.routeParams;\n    }\n  }\n  let routeCursor = foundRoute || routesById[rootRouteId];\n  const matchedRoutes = [routeCursor];\n  while (routeCursor.parentRoute) {\n    routeCursor = routeCursor.parentRoute;\n    matchedRoutes.push(routeCursor);\n  }\n  matchedRoutes.reverse();\n  return { matchedRoutes, routeParams, foundRoute };\n}\nfunction applySearchMiddleware({\n  search,\n  dest,\n  destRoutes,\n  _includeValidateSearch\n}) {\n  const allMiddlewares = destRoutes.reduce(\n    (acc, route) => {\n      const middlewares = [];\n      if (\"search\" in route.options) {\n        if (route.options.search?.middlewares) {\n          middlewares.push(...route.options.search.middlewares);\n        }\n      } else if (route.options.preSearchFilters || route.options.postSearchFilters) {\n        const legacyMiddleware = ({\n          search: search2,\n          next\n        }) => {\n          let nextSearch = search2;\n          if (\"preSearchFilters\" in route.options && route.options.preSearchFilters) {\n            nextSearch = route.options.preSearchFilters.reduce(\n              (prev, next2) => next2(prev),\n              search2\n            );\n          }\n          const result = next(nextSearch);\n          if (\"postSearchFilters\" in route.options && route.options.postSearchFilters) {\n            return route.options.postSearchFilters.reduce(\n              (prev, next2) => next2(prev),\n              result\n            );\n          }\n          return result;\n        };\n        middlewares.push(legacyMiddleware);\n      }\n      if (_includeValidateSearch && route.options.validateSearch) {\n        const validate = ({ search: search2, next }) => {\n          const result = next(search2);\n          try {\n            const validatedSearch = {\n              ...result,\n              ...validateSearch(route.options.validateSearch, result) ?? void 0\n            };\n            return validatedSearch;\n          } catch {\n            return result;\n          }\n        };\n        middlewares.push(validate);\n      }\n      return acc.concat(middlewares);\n    },\n    []\n  ) ?? [];\n  const final = ({ search: search2 }) => {\n    if (!dest.search) {\n      return {};\n    }\n    if (dest.search === true) {\n      return search2;\n    }\n    return functionalUpdate(dest.search, search2);\n  };\n  allMiddlewares.push(final);\n  const applyNext = (index, currentSearch) => {\n    if (index >= allMiddlewares.length) {\n      return currentSearch;\n    }\n    const middleware = allMiddlewares[index];\n    const next = (newSearch) => {\n      return applyNext(index + 1, newSearch);\n    };\n    return middleware({ search: currentSearch, next });\n  };\n  return applyNext(0, search);\n}\nexport {\n  PathParamError,\n  RouterCore,\n  SearchParamError,\n  defaultSerializeError,\n  getInitialRouterState,\n  getLocationChangeInfo,\n  getMatchedRoutes,\n  lazyFn,\n  trailingSlashOptions\n};\n//# sourceMappingURL=router.js.map\n","import { defaultSerializeError } from \"./router.js\";\nconst TSR_DEFERRED_PROMISE = Symbol.for(\"TSR_DEFERRED_PROMISE\");\nfunction defer(_promise, options) {\n  const promise = _promise;\n  if (promise[TSR_DEFERRED_PROMISE]) {\n    return promise;\n  }\n  promise[TSR_DEFERRED_PROMISE] = { status: \"pending\" };\n  promise.then((data) => {\n    promise[TSR_DEFERRED_PROMISE].status = \"success\";\n    promise[TSR_DEFERRED_PROMISE].data = data;\n  }).catch((error) => {\n    promise[TSR_DEFERRED_PROMISE].status = \"error\";\n    promise[TSR_DEFERRED_PROMISE].error = {\n      data: (options?.serializeError ?? defaultSerializeError)(error),\n      __isServerError: true\n    };\n  });\n  return promise;\n}\nexport {\n  TSR_DEFERRED_PROMISE,\n  defer\n};\n//# sourceMappingURL=defer.js.map\n","const preloadWarning = \"Error preloading route! ☝️\";\nexport {\n  preloadWarning\n};\n//# sourceMappingURL=link.js.map\n","const isMatch = (match, path) => {\n  const parts = path.split(\".\");\n  let part;\n  let i = 0;\n  let value = match;\n  while ((part = parts[i++]) != null && value != null) {\n    value = value[part];\n  }\n  return value != null;\n};\nexport {\n  isMatch\n};\n//# sourceMappingURL=Matches.js.map\n","import invariant from \"tiny-invariant\";\nimport { trimPathLeft, joinPaths } from \"./path.js\";\nimport { notFound } from \"./not-found.js\";\nimport { rootRouteId } from \"./root.js\";\nclass BaseRoute {\n  constructor(options) {\n    this.init = (opts) => {\n      this.originalIndex = opts.originalIndex;\n      const options2 = this.options;\n      const isRoot = !options2?.path && !options2?.id;\n      this.parentRoute = this.options.getParentRoute?.();\n      if (isRoot) {\n        this._path = rootRouteId;\n      } else if (!this.parentRoute) {\n        invariant(\n          false,\n          `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`\n        );\n      }\n      let path = isRoot ? rootRouteId : options2?.path;\n      if (path && path !== \"/\") {\n        path = trimPathLeft(path);\n      }\n      const customId = options2?.id || path;\n      let id = isRoot ? rootRouteId : joinPaths([\n        this.parentRoute.id === rootRouteId ? \"\" : this.parentRoute.id,\n        customId\n      ]);\n      if (path === rootRouteId) {\n        path = \"/\";\n      }\n      if (id !== rootRouteId) {\n        id = joinPaths([\"/\", id]);\n      }\n      const fullPath = id === rootRouteId ? \"/\" : joinPaths([this.parentRoute.fullPath, path]);\n      this._path = path;\n      this._id = id;\n      this._fullPath = fullPath;\n      this._to = fullPath;\n    };\n    this.clone = (other) => {\n      this._path = other._path;\n      this._id = other._id;\n      this._fullPath = other._fullPath;\n      this._to = other._to;\n      this.options.getParentRoute = other.options.getParentRoute;\n      this.children = other.children;\n    };\n    this.addChildren = (children) => {\n      return this._addFileChildren(children);\n    };\n    this._addFileChildren = (children) => {\n      if (Array.isArray(children)) {\n        this.children = children;\n      }\n      if (typeof children === \"object\" && children !== null) {\n        this.children = Object.values(children);\n      }\n      return this;\n    };\n    this._addFileTypes = () => {\n      return this;\n    };\n    this.updateLoader = (options2) => {\n      Object.assign(this.options, options2);\n      return this;\n    };\n    this.update = (options2) => {\n      Object.assign(this.options, options2);\n      return this;\n    };\n    this.lazy = (lazyFn) => {\n      this.lazyFn = lazyFn;\n      return this;\n    };\n    this.options = options || {};\n    this.isRoot = !options?.getParentRoute;\n    if (options?.id && options?.path) {\n      throw new Error(`Route cannot have both an 'id' and a 'path' option.`);\n    }\n  }\n  get to() {\n    return this._to;\n  }\n  get id() {\n    return this._id;\n  }\n  get path() {\n    return this._path;\n  }\n  get fullPath() {\n    return this._fullPath;\n  }\n}\nclass BaseRouteApi {\n  constructor({ id }) {\n    this.notFound = (opts) => {\n      return notFound({ routeId: this.id, ...opts });\n    };\n    this.id = id;\n  }\n}\nclass BaseRootRoute extends BaseRoute {\n  constructor(options) {\n    super(options);\n  }\n}\nexport {\n  BaseRootRoute,\n  BaseRoute,\n  BaseRouteApi\n};\n//# sourceMappingURL=route.js.map\n","const createRouterConfig = (options) => {\n  return {\n    serializationAdapters: options.serializationAdapters,\n    defaultSsr: options.defaultSsr\n  };\n};\nexport {\n  createRouterConfig\n};\n//# sourceMappingURL=config.js.map\n","import { deepEqual } from \"./utils.js\";\nfunction retainSearchParams(keys) {\n  return ({ search, next }) => {\n    const result = next(search);\n    if (keys === true) {\n      return { ...search, ...result };\n    }\n    keys.forEach((key) => {\n      if (!(key in result)) {\n        result[key] = search[key];\n      }\n    });\n    return result;\n  };\n}\nfunction stripSearchParams(input) {\n  return ({ search, next }) => {\n    if (input === true) {\n      return {};\n    }\n    const result = next(search);\n    if (Array.isArray(input)) {\n      input.forEach((key) => {\n        delete result[key];\n      });\n    } else {\n      Object.entries(input).forEach(\n        ([key, value]) => {\n          if (deepEqual(result[key], value)) {\n            delete result[key];\n          }\n        }\n      );\n    }\n    return result;\n  };\n}\nexport {\n  retainSearchParams,\n  stripSearchParams\n};\n//# sourceMappingURL=searchMiddleware.js.map\n","// src/core/compat.ts\nvar Feature = /* @__PURE__ */ ((Feature2) => {\n  Feature2[Feature2[\"AggregateError\"] = 1] = \"AggregateError\";\n  Feature2[Feature2[\"ArrowFunction\"] = 2] = \"ArrowFunction\";\n  Feature2[Feature2[\"ErrorPrototypeStack\"] = 4] = \"ErrorPrototypeStack\";\n  Feature2[Feature2[\"ObjectAssign\"] = 8] = \"ObjectAssign\";\n  Feature2[Feature2[\"BigIntTypedArray\"] = 16] = \"BigIntTypedArray\";\n  return Feature2;\n})(Feature || {});\nvar ALL_ENABLED = 1 /* AggregateError */ | 2 /* ArrowFunction */ | 4 /* ErrorPrototypeStack */ | 8 /* ObjectAssign */ | 16 /* BigIntTypedArray */;\n\n// src/core/string.ts\nfunction serializeChar(str) {\n  switch (str) {\n    case '\"':\n      return '\\\\\"';\n    case \"\\\\\":\n      return \"\\\\\\\\\";\n    case \"\\n\":\n      return \"\\\\n\";\n    case \"\\r\":\n      return \"\\\\r\";\n    case \"\\b\":\n      return \"\\\\b\";\n    case \"\t\":\n      return \"\\\\t\";\n    case \"\\f\":\n      return \"\\\\f\";\n    case \"<\":\n      return \"\\\\x3C\";\n    case \"\\u2028\":\n      return \"\\\\u2028\";\n    case \"\\u2029\":\n      return \"\\\\u2029\";\n    default:\n      return void 0;\n  }\n}\nfunction serializeString(str) {\n  let result = \"\";\n  let lastPos = 0;\n  let replacement;\n  for (let i = 0, len = str.length; i < len; i++) {\n    replacement = serializeChar(str[i]);\n    if (replacement) {\n      result += str.slice(lastPos, i) + replacement;\n      lastPos = i + 1;\n    }\n  }\n  if (lastPos === 0) {\n    result = str;\n  } else {\n    result += str.slice(lastPos);\n  }\n  return result;\n}\nfunction deserializeReplacer(str) {\n  switch (str) {\n    case \"\\\\\\\\\":\n      return \"\\\\\";\n    case '\\\\\"':\n      return '\"';\n    case \"\\\\n\":\n      return \"\\n\";\n    case \"\\\\r\":\n      return \"\\r\";\n    case \"\\\\b\":\n      return \"\\b\";\n    case \"\\\\t\":\n      return \"\t\";\n    case \"\\\\f\":\n      return \"\\f\";\n    case \"\\\\x3C\":\n      return \"<\";\n    case \"\\\\u2028\":\n      return \"\\u2028\";\n    case \"\\\\u2029\":\n      return \"\\u2029\";\n    default:\n      return str;\n  }\n}\nfunction deserializeString(str) {\n  return str.replace(\n    /(\\\\\\\\|\\\\\"|\\\\n|\\\\r|\\\\b|\\\\t|\\\\f|\\\\u2028|\\\\u2029|\\\\x3C)/g,\n    deserializeReplacer\n  );\n}\n\n// src/core/keys.ts\nvar REFERENCES_KEY = \"__SEROVAL_REFS__\";\nvar GLOBAL_CONTEXT_REFERENCES = \"$R\";\nvar GLOBAL_CONTEXT_R = `self.${GLOBAL_CONTEXT_REFERENCES}`;\nfunction getCrossReferenceHeader(id) {\n  if (id == null) {\n    return `${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||[]`;\n  }\n  return `(${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||{})[\"${serializeString(\n    id\n  )}\"]=[]`;\n}\n\n// src/core/utils/assert.ts\nfunction assert(cond, error) {\n  if (!cond) {\n    throw error;\n  }\n}\n\n// src/core/reference.ts\nvar REFERENCE = /* @__PURE__ */ new Map();\nvar INV_REFERENCE = /* @__PURE__ */ new Map();\nfunction createReference(id, value) {\n  REFERENCE.set(value, id);\n  INV_REFERENCE.set(id, value);\n  return value;\n}\nfunction hasReferenceID(value) {\n  return REFERENCE.has(value);\n}\nfunction hasReference(id) {\n  return INV_REFERENCE.has(id);\n}\nfunction getReferenceID(value) {\n  assert(hasReferenceID(value), new SerovalMissingReferenceError(value));\n  return REFERENCE.get(value);\n}\nfunction getReference(id) {\n  assert(hasReference(id), new SerovalMissingReferenceForIdError(id));\n  return INV_REFERENCE.get(id);\n}\nif (typeof globalThis !== \"undefined\") {\n  Object.defineProperty(globalThis, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof window !== \"undefined\") {\n  Object.defineProperty(window, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof self !== \"undefined\") {\n  Object.defineProperty(self, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n} else if (typeof global !== \"undefined\") {\n  Object.defineProperty(global, REFERENCES_KEY, {\n    value: INV_REFERENCE,\n    configurable: true,\n    writable: false,\n    enumerable: false\n  });\n}\n\n// src/core/plugin.ts\nfunction createPlugin(plugin) {\n  return plugin;\n}\nfunction dedupePlugins(deduped, plugins) {\n  for (let i = 0, len = plugins.length; i < len; i++) {\n    const current = plugins[i];\n    if (!deduped.has(current)) {\n      deduped.add(current);\n      if (current.extends) {\n        dedupePlugins(deduped, current.extends);\n      }\n    }\n  }\n}\nfunction resolvePlugins(plugins) {\n  if (plugins) {\n    const deduped = /* @__PURE__ */ new Set();\n    dedupePlugins(deduped, plugins);\n    return [...deduped];\n  }\n  return void 0;\n}\n\n// src/core/constants.ts\nvar SYMBOL_STRING = {\n  [0 /* AsyncIterator */]: \"Symbol.asyncIterator\",\n  [1 /* HasInstance */]: \"Symbol.hasInstance\",\n  [2 /* IsConcatSpreadable */]: \"Symbol.isConcatSpreadable\",\n  [3 /* Iterator */]: \"Symbol.iterator\",\n  [4 /* Match */]: \"Symbol.match\",\n  [5 /* MatchAll */]: \"Symbol.matchAll\",\n  [6 /* Replace */]: \"Symbol.replace\",\n  [7 /* Search */]: \"Symbol.search\",\n  [8 /* Species */]: \"Symbol.species\",\n  [9 /* Split */]: \"Symbol.split\",\n  [10 /* ToPrimitive */]: \"Symbol.toPrimitive\",\n  [11 /* ToStringTag */]: \"Symbol.toStringTag\",\n  [12 /* Unscopables */]: \"Symbol.unscopables\"\n};\nvar INV_SYMBOL_REF = {\n  [Symbol.asyncIterator]: 0 /* AsyncIterator */,\n  [Symbol.hasInstance]: 1 /* HasInstance */,\n  [Symbol.isConcatSpreadable]: 2 /* IsConcatSpreadable */,\n  [Symbol.iterator]: 3 /* Iterator */,\n  [Symbol.match]: 4 /* Match */,\n  [Symbol.matchAll]: 5 /* MatchAll */,\n  [Symbol.replace]: 6 /* Replace */,\n  [Symbol.search]: 7 /* Search */,\n  [Symbol.species]: 8 /* Species */,\n  [Symbol.split]: 9 /* Split */,\n  [Symbol.toPrimitive]: 10 /* ToPrimitive */,\n  [Symbol.toStringTag]: 11 /* ToStringTag */,\n  [Symbol.unscopables]: 12 /* Unscopables */\n};\nvar SYMBOL_REF = {\n  [0 /* AsyncIterator */]: Symbol.asyncIterator,\n  [1 /* HasInstance */]: Symbol.hasInstance,\n  [2 /* IsConcatSpreadable */]: Symbol.isConcatSpreadable,\n  [3 /* Iterator */]: Symbol.iterator,\n  [4 /* Match */]: Symbol.match,\n  [5 /* MatchAll */]: Symbol.matchAll,\n  [6 /* Replace */]: Symbol.replace,\n  [7 /* Search */]: Symbol.search,\n  [8 /* Species */]: Symbol.species,\n  [9 /* Split */]: Symbol.split,\n  [10 /* ToPrimitive */]: Symbol.toPrimitive,\n  [11 /* ToStringTag */]: Symbol.toStringTag,\n  [12 /* Unscopables */]: Symbol.unscopables\n};\nvar CONSTANT_STRING = {\n  [2 /* True */]: \"!0\",\n  [3 /* False */]: \"!1\",\n  [1 /* Undefined */]: \"void 0\",\n  [0 /* Null */]: \"null\",\n  [4 /* NegZero */]: \"-0\",\n  [5 /* Inf */]: \"1/0\",\n  [6 /* NegInf */]: \"-1/0\",\n  [7 /* Nan */]: \"0/0\"\n};\nvar CONSTANT_VAL = {\n  [2 /* True */]: true,\n  [3 /* False */]: false,\n  [1 /* Undefined */]: void 0,\n  [0 /* Null */]: null,\n  [4 /* NegZero */]: -0,\n  [5 /* Inf */]: Number.POSITIVE_INFINITY,\n  [6 /* NegInf */]: Number.NEGATIVE_INFINITY,\n  [7 /* Nan */]: Number.NaN\n};\nvar ERROR_CONSTRUCTOR_STRING = {\n  [0 /* Error */]: \"Error\",\n  [1 /* EvalError */]: \"EvalError\",\n  [2 /* RangeError */]: \"RangeError\",\n  [3 /* ReferenceError */]: \"ReferenceError\",\n  [4 /* SyntaxError */]: \"SyntaxError\",\n  [5 /* TypeError */]: \"TypeError\",\n  [6 /* URIError */]: \"URIError\"\n};\nvar ERROR_CONSTRUCTOR = {\n  [0 /* Error */]: Error,\n  [1 /* EvalError */]: EvalError,\n  [2 /* RangeError */]: RangeError,\n  [3 /* ReferenceError */]: ReferenceError,\n  [4 /* SyntaxError */]: SyntaxError,\n  [5 /* TypeError */]: TypeError,\n  [6 /* URIError */]: URIError\n};\nvar NIL = void 0;\n\n// src/core/node.ts\nfunction createSerovalNode(t, i, s, l, c, m, p, e, a, f, b, o) {\n  return {\n    t,\n    i,\n    s,\n    l,\n    c,\n    m,\n    p,\n    e,\n    a,\n    f,\n    b,\n    o\n  };\n}\n\n// src/core/literals.ts\nfunction createConstantNode(value) {\n  return createSerovalNode(\n    2 /* Constant */,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nvar TRUE_NODE = /* @__PURE__ */ createConstantNode(\n  2 /* True */\n);\nvar FALSE_NODE = /* @__PURE__ */ createConstantNode(\n  3 /* False */\n);\nvar UNDEFINED_NODE = /* @__PURE__ */ createConstantNode(\n  1 /* Undefined */\n);\nvar NULL_NODE = /* @__PURE__ */ createConstantNode(\n  0 /* Null */\n);\nvar NEG_ZERO_NODE = /* @__PURE__ */ createConstantNode(\n  4 /* NegZero */\n);\nvar INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  5 /* Inf */\n);\nvar NEG_INFINITY_NODE = /* @__PURE__ */ createConstantNode(\n  6 /* NegInf */\n);\nvar NAN_NODE = /* @__PURE__ */ createConstantNode(7 /* Nan */);\n\n// src/core/utils/error.ts\nfunction getErrorConstructor(error) {\n  if (error instanceof EvalError) {\n    return 1 /* EvalError */;\n  }\n  if (error instanceof RangeError) {\n    return 2 /* RangeError */;\n  }\n  if (error instanceof ReferenceError) {\n    return 3 /* ReferenceError */;\n  }\n  if (error instanceof SyntaxError) {\n    return 4 /* SyntaxError */;\n  }\n  if (error instanceof TypeError) {\n    return 5 /* TypeError */;\n  }\n  if (error instanceof URIError) {\n    return 6 /* URIError */;\n  }\n  return 0 /* Error */;\n}\nfunction getInitialErrorOptions(error) {\n  const construct = ERROR_CONSTRUCTOR_STRING[getErrorConstructor(error)];\n  if (error.name !== construct) {\n    return { name: error.name };\n  }\n  if (error.constructor.name !== construct) {\n    return { name: error.constructor.name };\n  }\n  return {};\n}\nfunction getErrorOptions(error, features) {\n  let options = getInitialErrorOptions(error);\n  const names = Object.getOwnPropertyNames(error);\n  for (let i = 0, len = names.length, name; i < len; i++) {\n    name = names[i];\n    if (name !== \"name\" && name !== \"message\") {\n      if (name === \"stack\") {\n        if (features & 4 /* ErrorPrototypeStack */) {\n          options = options || {};\n          options[name] = error[name];\n        }\n      } else {\n        options = options || {};\n        options[name] = error[name];\n      }\n    }\n  }\n  return options;\n}\n\n// src/core/utils/get-object-flag.ts\nfunction getObjectFlag(obj) {\n  if (Object.isFrozen(obj)) {\n    return 3 /* Frozen */;\n  }\n  if (Object.isSealed(obj)) {\n    return 2 /* Sealed */;\n  }\n  if (Object.isExtensible(obj)) {\n    return 0 /* None */;\n  }\n  return 1 /* NonExtensible */;\n}\n\n// src/core/base-primitives.ts\nfunction createNumberNode(value) {\n  switch (value) {\n    case Number.POSITIVE_INFINITY:\n      return INFINITY_NODE;\n    case Number.NEGATIVE_INFINITY:\n      return NEG_INFINITY_NODE;\n  }\n  if (value !== value) {\n    return NAN_NODE;\n  }\n  if (Object.is(value, -0)) {\n    return NEG_ZERO_NODE;\n  }\n  return createSerovalNode(\n    0 /* Number */,\n    NIL,\n    value,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createStringNode(value) {\n  return createSerovalNode(\n    1 /* String */,\n    NIL,\n    serializeString(value),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createBigIntNode(current) {\n  return createSerovalNode(\n    3 /* BigInt */,\n    NIL,\n    \"\" + current,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createIndexedValueNode(id) {\n  return createSerovalNode(\n    4 /* IndexedValue */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createDateNode(id, current) {\n  const timestamp = current.valueOf();\n  return createSerovalNode(\n    5 /* Date */,\n    id,\n    timestamp !== timestamp ? \"\" : current.toISOString(),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createRegExpNode(id, current) {\n  return createSerovalNode(\n    6 /* RegExp */,\n    id,\n    NIL,\n    NIL,\n    serializeString(current.source),\n    current.flags,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createArrayBufferNode(id, current) {\n  const bytes = new Uint8Array(current);\n  const len = bytes.length;\n  const values = new Array(len);\n  for (let i = 0; i < len; i++) {\n    values[i] = bytes[i];\n  }\n  return createSerovalNode(\n    19 /* ArrayBuffer */,\n    id,\n    values,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createWKSymbolNode(id, current) {\n  return createSerovalNode(\n    17 /* WKSymbol */,\n    id,\n    INV_SYMBOL_REF[current],\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createReferenceNode(id, ref) {\n  return createSerovalNode(\n    18 /* Reference */,\n    id,\n    serializeString(getReferenceID(ref)),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createPluginNode(id, tag, value) {\n  return createSerovalNode(\n    25 /* Plugin */,\n    id,\n    value,\n    NIL,\n    serializeString(tag),\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createArrayNode(id, current, parsedItems) {\n  return createSerovalNode(\n    9 /* Array */,\n    id,\n    NIL,\n    current.length,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsedItems,\n    NIL,\n    NIL,\n    getObjectFlag(current)\n  );\n}\nfunction createBoxedNode(id, boxed) {\n  return createSerovalNode(\n    21 /* Boxed */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    boxed,\n    NIL,\n    NIL\n  );\n}\nfunction createTypedArrayNode(id, current, buffer) {\n  return createSerovalNode(\n    15 /* TypedArray */,\n    id,\n    NIL,\n    current.length,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL\n  );\n}\nfunction createBigIntTypedArrayNode(id, current, buffer) {\n  return createSerovalNode(\n    16 /* BigIntTypedArray */,\n    id,\n    NIL,\n    current.length,\n    current.constructor.name,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL\n  );\n}\nfunction createDataViewNode(id, current, buffer) {\n  return createSerovalNode(\n    20 /* DataView */,\n    id,\n    NIL,\n    current.byteLength,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    buffer,\n    current.byteOffset,\n    NIL\n  );\n}\nfunction createErrorNode(id, current, options) {\n  return createSerovalNode(\n    13 /* Error */,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createAggregateErrorNode(id, current, options) {\n  return createSerovalNode(\n    14 /* AggregateError */,\n    id,\n    getErrorConstructor(current),\n    NIL,\n    NIL,\n    serializeString(current.message),\n    options,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createSetNode(id, size, items) {\n  return createSerovalNode(\n    7 /* Set */,\n    id,\n    NIL,\n    size,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    items,\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createIteratorFactoryInstanceNode(factory, items) {\n  return createSerovalNode(\n    28 /* IteratorFactoryInstance */,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createAsyncIteratorFactoryInstanceNode(factory, items) {\n  return createSerovalNode(\n    30 /* AsyncIteratorFactoryInstance */,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    [factory, items],\n    NIL,\n    NIL,\n    NIL\n  );\n}\nfunction createStreamConstructorNode(id, factory, sequence) {\n  return createSerovalNode(\n    31 /* StreamConstructor */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    sequence,\n    factory,\n    NIL,\n    NIL\n  );\n}\nfunction createStreamNextNode(id, parsed) {\n  return createSerovalNode(\n    32 /* StreamNext */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL\n  );\n}\nfunction createStreamThrowNode(id, parsed) {\n  return createSerovalNode(\n    33 /* StreamThrow */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL\n  );\n}\nfunction createStreamReturnNode(id, parsed) {\n  return createSerovalNode(\n    34 /* StreamReturn */,\n    id,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    NIL,\n    parsed,\n    NIL,\n    NIL\n  );\n}\n\n// src/core/errors.ts\nvar { toString: objectToString } = Object.prototype;\nfunction getErrorMessage(type, cause) {\n  if (cause instanceof Error) {\n    return `Seroval caught an error during the ${type} process.\n  \n${cause.name}\n${cause.message}\n\n- For more information, please check the \"cause\" property of this error.\n- If you believe this is an error in Seroval, please submit an issue at https://github.com/lxsmnsyc/seroval/issues/new`;\n  }\n  return `Seroval caught an error during the ${type} process.\n\n\"${objectToString.call(cause)}\"\n\nFor more information, please check the \"cause\" property of this error.`;\n}\nvar SerovalError = class extends Error {\n  constructor(type, cause) {\n    super(getErrorMessage(type, cause));\n    this.cause = cause;\n  }\n};\nvar SerovalParserError = class extends SerovalError {\n  constructor(cause) {\n    super(\"parsing\", cause);\n  }\n};\nvar SerovalSerializationError = class extends SerovalError {\n  constructor(cause) {\n    super(\"serialization\", cause);\n  }\n};\nvar SerovalDeserializationError = class extends SerovalError {\n  constructor(cause) {\n    super(\"deserialization\", cause);\n  }\n};\nvar SerovalUnsupportedTypeError = class extends Error {\n  constructor(value) {\n    super(\n      `The value ${objectToString.call(value)} of type \"${typeof value}\" cannot be parsed/serialized.\n      \nThere are few workarounds for this problem:\n- Transform the value in a way that it can be serialized.\n- If the reference is present on multiple runtimes (isomorphic), you can use the Reference API to map the references.`\n    );\n    this.value = value;\n  }\n};\nvar SerovalUnsupportedNodeError = class extends Error {\n  constructor(node) {\n    super('Unsupported node type \"' + node.t + '\".');\n  }\n};\nvar SerovalMissingPluginError = class extends Error {\n  constructor(tag) {\n    super('Missing plugin for tag \"' + tag + '\".');\n  }\n};\nvar SerovalMissingInstanceError = class extends Error {\n  constructor(tag) {\n    super('Missing \"' + tag + '\" instance.');\n  }\n};\nvar SerovalMissingReferenceError = class extends Error {\n  constructor(value) {\n    super(\n      'Missing reference for the value \"' + objectToString.call(value) + '\" of type \"' + typeof value + '\"'\n    );\n    this.value = value;\n  }\n};\nvar SerovalMissingReferenceForIdError = class extends Error {\n  constructor(id) {\n    super('Missing reference for id \"' + serializeString(id) + '\"');\n  }\n};\nvar SerovalUnknownTypedArrayError = class extends Error {\n  constructor(name) {\n    super('Unknown TypedArray \"' + name + '\"');\n  }\n};\n\n// src/core/opaque-reference.ts\nvar OpaqueReference = class {\n  constructor(value, replacement) {\n    this.value = value;\n    this.replacement = replacement;\n  }\n};\n\n// src/core/function-string.ts\nfunction createFunction(features, parameters, body) {\n  if (features & 2 /* ArrowFunction */) {\n    const joined = parameters.length === 1 ? parameters[0] : \"(\" + parameters.join(\",\") + \")\";\n    return joined + \"=>\" + (body.startsWith(\"{\") ? \"(\" + body + \")\" : body);\n  }\n  return \"function(\" + parameters.join(\",\") + \"){return \" + body + \"}\";\n}\nfunction createEffectfulFunction(features, parameters, body) {\n  if (features & 2 /* ArrowFunction */) {\n    const joined = parameters.length === 1 ? parameters[0] : \"(\" + parameters.join(\",\") + \")\";\n    return joined + \"=>{\" + body + \"}\";\n  }\n  return \"function(\" + parameters.join(\",\") + \"){\" + body + \"}\";\n}\n\n// src/core/special-reference.ts\nvar ITERATOR = {};\nvar ASYNC_ITERATOR = {};\nvar SPECIAL_REFS = {\n  [0 /* MapSentinel */]: {},\n  [1 /* PromiseConstructor */]: {},\n  [2 /* PromiseSuccess */]: {},\n  [3 /* PromiseFailure */]: {},\n  [4 /* StreamConstructor */]: {}\n};\nfunction serializePromiseConstructor(features) {\n  return createFunction(\n    features,\n    [\"r\"],\n    \"(r.p=new Promise(\" + createEffectfulFunction(features, [\"s\", \"f\"], \"r.s=s,r.f=f\") + \"))\"\n  );\n}\nfunction serializePromiseSuccess(features) {\n  return createEffectfulFunction(\n    features,\n    [\"r\", \"d\"],\n    \"r.s(d),r.p.s=1,r.p.v=d\"\n  );\n}\nfunction serializePromiseFailure(features) {\n  return createEffectfulFunction(\n    features,\n    [\"r\", \"d\"],\n    \"r.f(d),r.p.s=2,r.p.v=d\"\n  );\n}\nfunction serializeStreamConstructor(features) {\n  return createFunction(\n    features,\n    [\"b\", \"a\", \"s\", \"l\", \"p\", \"f\", \"e\", \"n\"],\n    \"(b=[],a=!0,s=!1,l=[],p=0,f=\" + createEffectfulFunction(\n      features,\n      [\"v\", \"m\", \"x\"],\n      \"for(x=0;x<p;x++)l[x]&&l[x][m](v)\"\n    ) + \",n=\" + createEffectfulFunction(\n      features,\n      [\"o\", \"x\", \"z\", \"c\"],\n      'for(x=0,z=b.length;x<z;x++)(c=b[x],(!a&&x===z-1)?o[s?\"return\":\"throw\"](c):o.next(c))'\n    ) + \",e=\" + createFunction(\n      features,\n      [\"o\", \"t\"],\n      \"(a&&(l[t=p++]=o),n(o),\" + createEffectfulFunction(features, [], \"a&&(l[t]=void 0)\") + \")\"\n    ) + \",{__SEROVAL_STREAM__:!0,on:\" + createFunction(features, [\"o\"], \"e(o)\") + \",next:\" + createEffectfulFunction(features, [\"v\"], 'a&&(b.push(v),f(v,\"next\"))') + \",throw:\" + createEffectfulFunction(\n      features,\n      [\"v\"],\n      'a&&(b.push(v),f(v,\"throw\"),a=s=!1,l.length=0)'\n    ) + \",return:\" + createEffectfulFunction(\n      features,\n      [\"v\"],\n      'a&&(b.push(v),f(v,\"return\"),a=!1,s=!0,l.length=0)'\n    ) + \"})\"\n  );\n}\nfunction serializeSpecialReferenceValue(features, ref) {\n  switch (ref) {\n    case 0 /* MapSentinel */:\n      return \"[]\";\n    case 1 /* PromiseConstructor */:\n      return serializePromiseConstructor(features);\n    case 2 /* PromiseSuccess */:\n      return serializePromiseSuccess(features);\n    case 3 /* PromiseFailure */:\n      return serializePromiseFailure(features);\n    case 4 /* StreamConstructor */:\n      return serializeStreamConstructor(features);\n    default:\n      return \"\";\n  }\n}\n\n// src/core/utils/deferred.ts\nfunction createDeferred() {\n  let resolve;\n  let reject;\n  return {\n    promise: new Promise((res, rej) => {\n      resolve = res;\n      reject = rej;\n    }),\n    resolve(value) {\n      resolve(value);\n    },\n    reject(value) {\n      reject(value);\n    }\n  };\n}\n\n// src/core/stream.ts\nfunction isStream(value) {\n  return \"__SEROVAL_STREAM__\" in value;\n}\nfunction createStream() {\n  const listeners = /* @__PURE__ */ new Set();\n  const buffer = [];\n  let alive = true;\n  let success = true;\n  function flushNext(value) {\n    for (const listener of listeners.keys()) {\n      listener.next(value);\n    }\n  }\n  function flushThrow(value) {\n    for (const listener of listeners.keys()) {\n      listener.throw(value);\n    }\n  }\n  function flushReturn(value) {\n    for (const listener of listeners.keys()) {\n      listener.return(value);\n    }\n  }\n  return {\n    __SEROVAL_STREAM__: true,\n    on(listener) {\n      if (alive) {\n        listeners.add(listener);\n      }\n      for (let i = 0, len = buffer.length; i < len; i++) {\n        const value = buffer[i];\n        if (i === len - 1 && !alive) {\n          if (success) {\n            listener.return(value);\n          } else {\n            listener.throw(value);\n          }\n        } else {\n          listener.next(value);\n        }\n      }\n      return () => {\n        if (alive) {\n          listeners.delete(listener);\n        }\n      };\n    },\n    next(value) {\n      if (alive) {\n        buffer.push(value);\n        flushNext(value);\n      }\n    },\n    throw(value) {\n      if (alive) {\n        buffer.push(value);\n        flushThrow(value);\n        alive = false;\n        success = false;\n        listeners.clear();\n      }\n    },\n    return(value) {\n      if (alive) {\n        buffer.push(value);\n        flushReturn(value);\n        alive = false;\n        success = true;\n        listeners.clear();\n      }\n    }\n  };\n}\nfunction createStreamFromAsyncIterable(iterable) {\n  const stream = createStream();\n  const iterator = iterable[Symbol.asyncIterator]();\n  async function push() {\n    try {\n      const value = await iterator.next();\n      if (value.done) {\n        stream.return(value.value);\n      } else {\n        stream.next(value.value);\n        await push();\n      }\n    } catch (error) {\n      stream.throw(error);\n    }\n  }\n  push().catch(() => {\n  });\n  return stream;\n}\nfunction streamToAsyncIterable(stream) {\n  return () => {\n    const buffer = [];\n    const pending = [];\n    let count = 0;\n    let doneAt = -1;\n    let isThrow = false;\n    function resolveAll() {\n      for (let i = 0, len = pending.length; i < len; i++) {\n        pending[i].resolve({ done: true, value: void 0 });\n      }\n    }\n    stream.on({\n      next(value) {\n        const current = pending.shift();\n        if (current) {\n          current.resolve({ done: false, value });\n        }\n        buffer.push(value);\n      },\n      throw(value) {\n        const current = pending.shift();\n        if (current) {\n          current.reject(value);\n        }\n        resolveAll();\n        doneAt = buffer.length;\n        buffer.push(value);\n        isThrow = true;\n      },\n      return(value) {\n        const current = pending.shift();\n        if (current) {\n          current.resolve({ done: true, value });\n        }\n        resolveAll();\n        doneAt = buffer.length;\n        buffer.push(value);\n      }\n    });\n    function finalize() {\n      const current = count++;\n      const value = buffer[current];\n      if (current !== doneAt) {\n        return { done: false, value };\n      }\n      if (isThrow) {\n        throw value;\n      }\n      return { done: true, value };\n    }\n    return {\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      async next() {\n        if (doneAt === -1) {\n          const current = count++;\n          if (current >= buffer.length) {\n            const deferred = createDeferred();\n            pending.push(deferred);\n            return await deferred.promise;\n          }\n          return { done: false, value: buffer[current] };\n        }\n        if (count > doneAt) {\n          return { done: true, value: void 0 };\n        }\n        return finalize();\n      }\n    };\n  };\n}\n\n// src/core/utils/iterator-to-sequence.ts\nfunction iteratorToSequence(source) {\n  const values = [];\n  let throwsAt = -1;\n  let doneAt = -1;\n  const iterator = source[Symbol.iterator]();\n  while (true) {\n    try {\n      const value = iterator.next();\n      values.push(value.value);\n      if (value.done) {\n        doneAt = values.length - 1;\n        break;\n      }\n    } catch (error) {\n      throwsAt = values.length;\n      values.push(error);\n    }\n  }\n  return {\n    v: values,\n    t: throwsAt,\n    d: doneAt\n  };\n}\nfunction sequenceToIterator(sequence) {\n  return () => {\n    let index = 0;\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        if (index > sequence.d) {\n          return {\n            done: true,\n            value: NIL\n          };\n        }\n        const currentIndex = index++;\n        const currentItem = sequence.v[currentIndex];\n        if (currentIndex === sequence.t) {\n          throw currentItem;\n        }\n        return {\n          done: currentIndex === sequence.d,\n          value: currentItem\n        };\n      }\n    };\n  };\n}\n\n// src/core/utils/promise-to-result.ts\nasync function promiseToResult(current) {\n  try {\n    return [1, await current];\n  } catch (e) {\n    return [0, e];\n  }\n}\n\n// src/core/context/parser.ts\nvar BaseParserContext = class {\n  constructor(options) {\n    this.marked = /* @__PURE__ */ new Set();\n    this.plugins = options.plugins;\n    this.features = ALL_ENABLED ^ (options.disabledFeatures || 0);\n    this.refs = options.refs || /* @__PURE__ */ new Map();\n  }\n  markRef(id) {\n    this.marked.add(id);\n  }\n  isMarked(id) {\n    return this.marked.has(id);\n  }\n  createIndex(current) {\n    const id = this.refs.size;\n    this.refs.set(current, id);\n    return id;\n  }\n  getIndexedValue(current) {\n    const registeredId = this.refs.get(current);\n    if (registeredId != null) {\n      this.markRef(registeredId);\n      return {\n        type: 1 /* Indexed */,\n        value: createIndexedValueNode(registeredId)\n      };\n    }\n    return {\n      type: 0 /* Fresh */,\n      value: this.createIndex(current)\n    };\n  }\n  getReference(current) {\n    const indexed = this.getIndexedValue(current);\n    if (indexed.type === 1 /* Indexed */) {\n      return indexed;\n    }\n    if (hasReferenceID(current)) {\n      return {\n        type: 2 /* Referenced */,\n        value: createReferenceNode(indexed.value, current)\n      };\n    }\n    return indexed;\n  }\n  parseWellKnownSymbol(current) {\n    const ref = this.getReference(current);\n    if (ref.type !== 0 /* Fresh */) {\n      return ref.value;\n    }\n    assert(current in INV_SYMBOL_REF, new SerovalUnsupportedTypeError(current));\n    return createWKSymbolNode(ref.value, current);\n  }\n  parseSpecialReference(ref) {\n    const result = this.getIndexedValue(SPECIAL_REFS[ref]);\n    if (result.type === 1 /* Indexed */) {\n      return result.value;\n    }\n    return createSerovalNode(\n      26 /* SpecialReference */,\n      result.value,\n      ref,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL\n    );\n  }\n  parseIteratorFactory() {\n    const result = this.getIndexedValue(ITERATOR);\n    if (result.type === 1 /* Indexed */) {\n      return result.value;\n    }\n    return createSerovalNode(\n      27 /* IteratorFactory */,\n      result.value,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      this.parseWellKnownSymbol(Symbol.iterator),\n      NIL,\n      NIL\n    );\n  }\n  parseAsyncIteratorFactory() {\n    const result = this.getIndexedValue(ASYNC_ITERATOR);\n    if (result.type === 1 /* Indexed */) {\n      return result.value;\n    }\n    return createSerovalNode(\n      29 /* AsyncIteratorFactory */,\n      result.value,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      [\n        this.parseSpecialReference(1 /* PromiseConstructor */),\n        this.parseWellKnownSymbol(Symbol.asyncIterator)\n      ],\n      NIL,\n      NIL,\n      NIL\n    );\n  }\n  createObjectNode(id, current, empty, record) {\n    return createSerovalNode(\n      empty ? 11 /* NullConstructor */ : 10 /* Object */,\n      id,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      record,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      getObjectFlag(current)\n    );\n  }\n  createMapNode(id, k, v, s) {\n    return createSerovalNode(\n      8 /* Map */,\n      id,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      { k, v, s },\n      NIL,\n      this.parseSpecialReference(0 /* MapSentinel */),\n      NIL,\n      NIL\n    );\n  }\n  createPromiseConstructorNode(id, resolver) {\n    return createSerovalNode(\n      22 /* PromiseConstructor */,\n      id,\n      resolver,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      this.parseSpecialReference(1 /* PromiseConstructor */),\n      NIL,\n      NIL\n    );\n  }\n};\n\n// src/core/context/parser/async.ts\nvar BaseAsyncParserContext = class extends BaseParserContext {\n  async parseItems(current) {\n    const nodes = [];\n    for (let i = 0, len = current.length; i < len; i++) {\n      if (i in current) {\n        nodes[i] = await this.parse(current[i]);\n      }\n    }\n    return nodes;\n  }\n  async parseArray(id, current) {\n    return createArrayNode(id, current, await this.parseItems(current));\n  }\n  async parseProperties(properties) {\n    const entries = Object.entries(properties);\n    const keyNodes = [];\n    const valueNodes = [];\n    for (let i = 0, len = entries.length; i < len; i++) {\n      keyNodes.push(serializeString(entries[i][0]));\n      valueNodes.push(await this.parse(entries[i][1]));\n    }\n    let symbol = Symbol.iterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createIteratorFactoryInstanceNode(\n          this.parseIteratorFactory(),\n          await this.parse(\n            iteratorToSequence(properties)\n          )\n        )\n      );\n    }\n    symbol = Symbol.asyncIterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createAsyncIteratorFactoryInstanceNode(\n          this.parseAsyncIteratorFactory(),\n          await this.parse(\n            createStreamFromAsyncIterable(\n              properties\n            )\n          )\n        )\n      );\n    }\n    symbol = Symbol.toStringTag;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(createStringNode(properties[symbol]));\n    }\n    symbol = Symbol.isConcatSpreadable;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n    }\n    return {\n      k: keyNodes,\n      v: valueNodes,\n      s: keyNodes.length\n    };\n  }\n  async parsePlainObject(id, current, empty) {\n    return this.createObjectNode(\n      id,\n      current,\n      empty,\n      await this.parseProperties(current)\n    );\n  }\n  async parseBoxed(id, current) {\n    return createBoxedNode(id, await this.parse(current.valueOf()));\n  }\n  async parseTypedArray(id, current) {\n    return createTypedArrayNode(id, current, await this.parse(current.buffer));\n  }\n  async parseBigIntTypedArray(id, current) {\n    return createBigIntTypedArrayNode(\n      id,\n      current,\n      await this.parse(current.buffer)\n    );\n  }\n  async parseDataView(id, current) {\n    return createDataViewNode(id, current, await this.parse(current.buffer));\n  }\n  async parseError(id, current) {\n    const options = getErrorOptions(current, this.features);\n    return createErrorNode(\n      id,\n      current,\n      options ? await this.parseProperties(options) : NIL\n    );\n  }\n  async parseAggregateError(id, current) {\n    const options = getErrorOptions(current, this.features);\n    return createAggregateErrorNode(\n      id,\n      current,\n      options ? await this.parseProperties(options) : NIL\n    );\n  }\n  async parseMap(id, current) {\n    const keyNodes = [];\n    const valueNodes = [];\n    for (const [key, value] of current.entries()) {\n      keyNodes.push(await this.parse(key));\n      valueNodes.push(await this.parse(value));\n    }\n    return this.createMapNode(id, keyNodes, valueNodes, current.size);\n  }\n  async parseSet(id, current) {\n    const items = [];\n    for (const item of current.keys()) {\n      items.push(await this.parse(item));\n    }\n    return createSetNode(id, current.size, items);\n  }\n  async parsePromise(id, current) {\n    const [status, result] = await promiseToResult(current);\n    return createSerovalNode(\n      12 /* Promise */,\n      id,\n      status,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      NIL,\n      await this.parse(result),\n      NIL,\n      NIL\n    );\n  }\n  async parsePlugin(id, current) {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.parse.async && plugin.test(current)) {\n          return createPluginNode(\n            id,\n            plugin.tag,\n            await plugin.parse.async(current, this, {\n              id\n            })\n          );\n        }\n      }\n    }\n    return NIL;\n  }\n  async parseStream(id, current) {\n    return createStreamConstructorNode(\n      id,\n      this.parseSpecialReference(4 /* StreamConstructor */),\n      await new Promise((resolve, reject) => {\n        const sequence = [];\n        const cleanup = current.on({\n          next: (value) => {\n            this.markRef(id);\n            this.parse(value).then(\n              (data) => {\n                sequence.push(createStreamNextNode(id, data));\n              },\n              (data) => {\n                reject(data);\n                cleanup();\n              }\n            );\n          },\n          throw: (value) => {\n            this.markRef(id);\n            this.parse(value).then(\n              (data) => {\n                sequence.push(createStreamThrowNode(id, data));\n                resolve(sequence);\n                cleanup();\n              },\n              (data) => {\n                reject(data);\n                cleanup();\n              }\n            );\n          },\n          return: (value) => {\n            this.markRef(id);\n            this.parse(value).then(\n              (data) => {\n                sequence.push(createStreamReturnNode(id, data));\n                resolve(sequence);\n                cleanup();\n              },\n              (data) => {\n                reject(data);\n                cleanup();\n              }\n            );\n          }\n        });\n      })\n    );\n  }\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: ehh\n  async parseObject(id, current) {\n    if (Array.isArray(current)) {\n      return this.parseArray(id, current);\n    }\n    if (isStream(current)) {\n      return this.parseStream(id, current);\n    }\n    const currentClass = current.constructor;\n    if (currentClass === OpaqueReference) {\n      return this.parse(\n        current.replacement\n      );\n    }\n    const parsed = await this.parsePlugin(id, current);\n    if (parsed) {\n      return parsed;\n    }\n    switch (currentClass) {\n      case Object:\n        return this.parsePlainObject(\n          id,\n          current,\n          false\n        );\n      case NIL:\n        return this.parsePlainObject(\n          id,\n          current,\n          true\n        );\n      case Date:\n        return createDateNode(id, current);\n      case RegExp:\n        return createRegExpNode(id, current);\n      case Error:\n      case EvalError:\n      case RangeError:\n      case ReferenceError:\n      case SyntaxError:\n      case TypeError:\n      case URIError:\n        return this.parseError(id, current);\n      case Number:\n      case Boolean:\n      case String:\n      case BigInt:\n        return this.parseBoxed(id, current);\n      case ArrayBuffer:\n        return createArrayBufferNode(id, current);\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case Uint8Array:\n      case Uint16Array:\n      case Uint32Array:\n      case Uint8ClampedArray:\n      case Float32Array:\n      case Float64Array:\n        return this.parseTypedArray(id, current);\n      case DataView:\n        return this.parseDataView(id, current);\n      case Map:\n        return this.parseMap(id, current);\n      case Set:\n        return this.parseSet(id, current);\n      default:\n        break;\n    }\n    if (currentClass === Promise || current instanceof Promise) {\n      return this.parsePromise(id, current);\n    }\n    const currentFeatures = this.features;\n    if (currentFeatures & 16 /* BigIntTypedArray */) {\n      switch (currentClass) {\n        case BigInt64Array:\n        case BigUint64Array:\n          return this.parseBigIntTypedArray(\n            id,\n            current\n          );\n        default:\n          break;\n      }\n    }\n    if (currentFeatures & 1 /* AggregateError */ && typeof AggregateError !== \"undefined\" && (currentClass === AggregateError || current instanceof AggregateError)) {\n      return this.parseAggregateError(id, current);\n    }\n    if (current instanceof Error) {\n      return this.parseError(id, current);\n    }\n    if (Symbol.iterator in current || Symbol.asyncIterator in current) {\n      return this.parsePlainObject(id, current, !!currentClass);\n    }\n    throw new SerovalUnsupportedTypeError(current);\n  }\n  async parseFunction(current) {\n    const ref = this.getReference(current);\n    if (ref.type !== 0 /* Fresh */) {\n      return ref.value;\n    }\n    const plugin = await this.parsePlugin(ref.value, current);\n    if (plugin) {\n      return plugin;\n    }\n    throw new SerovalUnsupportedTypeError(current);\n  }\n  async parse(current) {\n    switch (typeof current) {\n      case \"boolean\":\n        return current ? TRUE_NODE : FALSE_NODE;\n      case \"undefined\":\n        return UNDEFINED_NODE;\n      case \"string\":\n        return createStringNode(current);\n      case \"number\":\n        return createNumberNode(current);\n      case \"bigint\":\n        return createBigIntNode(current);\n      case \"object\": {\n        if (current) {\n          const ref = this.getReference(current);\n          return ref.type === 0 ? await this.parseObject(ref.value, current) : ref.value;\n        }\n        return NULL_NODE;\n      }\n      case \"symbol\":\n        return this.parseWellKnownSymbol(current);\n      case \"function\":\n        return this.parseFunction(current);\n      default:\n        throw new SerovalUnsupportedTypeError(current);\n    }\n  }\n  async parseTop(current) {\n    try {\n      return await this.parse(current);\n    } catch (error) {\n      throw error instanceof SerovalParserError ? error : new SerovalParserError(error);\n    }\n  }\n};\n\n// src/core/cross/async.ts\nvar CrossAsyncParserContext = class extends BaseAsyncParserContext {\n  constructor() {\n    super(...arguments);\n    this.mode = \"cross\";\n  }\n};\n\n// src/core/utils/typed-array.ts\nfunction getTypedArrayConstructor(name) {\n  switch (name) {\n    case \"Int8Array\":\n      return Int8Array;\n    case \"Int16Array\":\n      return Int16Array;\n    case \"Int32Array\":\n      return Int32Array;\n    case \"Uint8Array\":\n      return Uint8Array;\n    case \"Uint16Array\":\n      return Uint16Array;\n    case \"Uint32Array\":\n      return Uint32Array;\n    case \"Uint8ClampedArray\":\n      return Uint8ClampedArray;\n    case \"Float32Array\":\n      return Float32Array;\n    case \"Float64Array\":\n      return Float64Array;\n    case \"BigInt64Array\":\n      return BigInt64Array;\n    case \"BigUint64Array\":\n      return BigUint64Array;\n    default:\n      throw new SerovalUnknownTypedArrayError(name);\n  }\n}\n\n// src/core/context/deserializer.ts\nfunction applyObjectFlag(obj, flag) {\n  switch (flag) {\n    case 3 /* Frozen */:\n      return Object.freeze(obj);\n    case 1 /* NonExtensible */:\n      return Object.preventExtensions(obj);\n    case 2 /* Sealed */:\n      return Object.seal(obj);\n    default:\n      return obj;\n  }\n}\nvar BaseDeserializerContext = class {\n  constructor(options) {\n    this.plugins = options.plugins;\n    this.refs = options.refs || /* @__PURE__ */ new Map();\n  }\n  deserializeReference(node) {\n    return this.assignIndexedValue(\n      node.i,\n      getReference(deserializeString(node.s))\n    );\n  }\n  deserializeArray(node) {\n    const len = node.l;\n    const result = this.assignIndexedValue(\n      node.i,\n      new Array(len)\n    );\n    let item;\n    for (let i = 0; i < len; i++) {\n      item = node.a[i];\n      if (item) {\n        result[i] = this.deserialize(item);\n      }\n    }\n    applyObjectFlag(result, node.o);\n    return result;\n  }\n  deserializeProperties(node, result) {\n    const len = node.s;\n    if (len) {\n      const keys = node.k;\n      const vals = node.v;\n      for (let i = 0, key; i < len; i++) {\n        key = keys[i];\n        if (typeof key === \"string\") {\n          result[deserializeString(key)] = this.deserialize(vals[i]);\n        } else {\n          result[this.deserialize(key)] = this.deserialize(vals[i]);\n        }\n      }\n    }\n    return result;\n  }\n  deserializeObject(node) {\n    const result = this.assignIndexedValue(\n      node.i,\n      node.t === 10 /* Object */ ? {} : /* @__PURE__ */ Object.create(null)\n    );\n    this.deserializeProperties(node.p, result);\n    applyObjectFlag(result, node.o);\n    return result;\n  }\n  deserializeDate(node) {\n    return this.assignIndexedValue(node.i, new Date(node.s));\n  }\n  deserializeRegExp(node) {\n    return this.assignIndexedValue(\n      node.i,\n      new RegExp(deserializeString(node.c), node.m)\n    );\n  }\n  deserializeSet(node) {\n    const result = this.assignIndexedValue(node.i, /* @__PURE__ */ new Set());\n    const items = node.a;\n    for (let i = 0, len = node.l; i < len; i++) {\n      result.add(this.deserialize(items[i]));\n    }\n    return result;\n  }\n  deserializeMap(node) {\n    const result = this.assignIndexedValue(node.i, /* @__PURE__ */ new Map());\n    const keys = node.e.k;\n    const vals = node.e.v;\n    for (let i = 0, len = node.e.s; i < len; i++) {\n      result.set(this.deserialize(keys[i]), this.deserialize(vals[i]));\n    }\n    return result;\n  }\n  deserializeArrayBuffer(node) {\n    const bytes = new Uint8Array(node.s);\n    const result = this.assignIndexedValue(node.i, bytes.buffer);\n    return result;\n  }\n  deserializeTypedArray(node) {\n    const construct = getTypedArrayConstructor(node.c);\n    const source = this.deserialize(node.f);\n    const result = this.assignIndexedValue(\n      node.i,\n      new construct(source, node.b, node.l)\n    );\n    return result;\n  }\n  deserializeDataView(node) {\n    const source = this.deserialize(node.f);\n    const result = this.assignIndexedValue(\n      node.i,\n      new DataView(source, node.b, node.l)\n    );\n    return result;\n  }\n  deserializeDictionary(node, result) {\n    if (node.p) {\n      const fields = this.deserializeProperties(node.p, {});\n      Object.assign(result, fields);\n    }\n    return result;\n  }\n  deserializeAggregateError(node) {\n    const result = this.assignIndexedValue(\n      node.i,\n      new AggregateError([], deserializeString(node.m))\n    );\n    return this.deserializeDictionary(node, result);\n  }\n  deserializeError(node) {\n    const construct = ERROR_CONSTRUCTOR[node.s];\n    const result = this.assignIndexedValue(\n      node.i,\n      new construct(deserializeString(node.m))\n    );\n    return this.deserializeDictionary(node, result);\n  }\n  deserializePromise(node) {\n    const deferred = createDeferred();\n    const result = this.assignIndexedValue(node.i, deferred);\n    const deserialized = this.deserialize(node.f);\n    if (node.s) {\n      deferred.resolve(deserialized);\n    } else {\n      deferred.reject(deserialized);\n    }\n    return result.promise;\n  }\n  deserializeBoxed(node) {\n    return this.assignIndexedValue(node.i, Object(this.deserialize(node.f)));\n  }\n  deserializePlugin(node) {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      const tag = deserializeString(node.c);\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.tag === tag) {\n          return this.assignIndexedValue(\n            node.i,\n            plugin.deserialize(node.s, this, {\n              id: node.i\n            })\n          );\n        }\n      }\n    }\n    throw new SerovalMissingPluginError(node.c);\n  }\n  deserializePromiseConstructor(node) {\n    return this.assignIndexedValue(\n      node.i,\n      this.assignIndexedValue(node.s, createDeferred()).promise\n    );\n  }\n  deserializePromiseResolve(node) {\n    const deferred = this.refs.get(node.i);\n    assert(deferred, new SerovalMissingInstanceError(\"Promise\"));\n    deferred.resolve(this.deserialize(node.a[1]));\n    return void 0;\n  }\n  deserializePromiseReject(node) {\n    const deferred = this.refs.get(node.i);\n    assert(deferred, new SerovalMissingInstanceError(\"Promise\"));\n    deferred.reject(this.deserialize(node.a[1]));\n    return void 0;\n  }\n  deserializeIteratorFactoryInstance(node) {\n    this.deserialize(node.a[0]);\n    const source = this.deserialize(node.a[1]);\n    return sequenceToIterator(source);\n  }\n  deserializeAsyncIteratorFactoryInstance(node) {\n    this.deserialize(node.a[0]);\n    const source = this.deserialize(node.a[1]);\n    return streamToAsyncIterable(source);\n  }\n  deserializeStreamConstructor(node) {\n    const result = this.assignIndexedValue(node.i, createStream());\n    const len = node.a.length;\n    if (len) {\n      for (let i = 0; i < len; i++) {\n        this.deserialize(node.a[i]);\n      }\n    }\n    return result;\n  }\n  deserializeStreamNext(node) {\n    const deferred = this.refs.get(node.i);\n    assert(deferred, new SerovalMissingInstanceError(\"Stream\"));\n    deferred.next(this.deserialize(node.f));\n    return void 0;\n  }\n  deserializeStreamThrow(node) {\n    const deferred = this.refs.get(node.i);\n    assert(deferred, new SerovalMissingInstanceError(\"Stream\"));\n    deferred.throw(this.deserialize(node.f));\n    return void 0;\n  }\n  deserializeStreamReturn(node) {\n    const deferred = this.refs.get(node.i);\n    assert(deferred, new SerovalMissingInstanceError(\"Stream\"));\n    deferred.return(this.deserialize(node.f));\n    return void 0;\n  }\n  deserializeIteratorFactory(node) {\n    this.deserialize(node.f);\n    return void 0;\n  }\n  deserializeAsyncIteratorFactory(node) {\n    this.deserialize(node.a[1]);\n    return void 0;\n  }\n  deserializeTop(node) {\n    try {\n      return this.deserialize(node);\n    } catch (error) {\n      throw new SerovalDeserializationError(error);\n    }\n  }\n  deserialize(node) {\n    switch (node.t) {\n      case 2 /* Constant */:\n        return CONSTANT_VAL[node.s];\n      case 0 /* Number */:\n        return node.s;\n      case 1 /* String */:\n        return deserializeString(node.s);\n      case 3 /* BigInt */:\n        return BigInt(node.s);\n      case 4 /* IndexedValue */:\n        return this.refs.get(node.i);\n      case 18 /* Reference */:\n        return this.deserializeReference(node);\n      case 9 /* Array */:\n        return this.deserializeArray(node);\n      case 10 /* Object */:\n      case 11 /* NullConstructor */:\n        return this.deserializeObject(node);\n      case 5 /* Date */:\n        return this.deserializeDate(node);\n      case 6 /* RegExp */:\n        return this.deserializeRegExp(node);\n      case 7 /* Set */:\n        return this.deserializeSet(node);\n      case 8 /* Map */:\n        return this.deserializeMap(node);\n      case 19 /* ArrayBuffer */:\n        return this.deserializeArrayBuffer(node);\n      case 16 /* BigIntTypedArray */:\n      case 15 /* TypedArray */:\n        return this.deserializeTypedArray(node);\n      case 20 /* DataView */:\n        return this.deserializeDataView(node);\n      case 14 /* AggregateError */:\n        return this.deserializeAggregateError(node);\n      case 13 /* Error */:\n        return this.deserializeError(node);\n      case 12 /* Promise */:\n        return this.deserializePromise(node);\n      case 17 /* WKSymbol */:\n        return SYMBOL_REF[node.s];\n      case 21 /* Boxed */:\n        return this.deserializeBoxed(node);\n      case 25 /* Plugin */:\n        return this.deserializePlugin(node);\n      case 22 /* PromiseConstructor */:\n        return this.deserializePromiseConstructor(node);\n      case 23 /* PromiseSuccess */:\n        return this.deserializePromiseResolve(node);\n      case 24 /* PromiseFailure */:\n        return this.deserializePromiseReject(node);\n      case 28 /* IteratorFactoryInstance */:\n        return this.deserializeIteratorFactoryInstance(node);\n      case 30 /* AsyncIteratorFactoryInstance */:\n        return this.deserializeAsyncIteratorFactoryInstance(node);\n      case 31 /* StreamConstructor */:\n        return this.deserializeStreamConstructor(node);\n      case 32 /* StreamNext */:\n        return this.deserializeStreamNext(node);\n      case 33 /* StreamThrow */:\n        return this.deserializeStreamThrow(node);\n      case 34 /* StreamReturn */:\n        return this.deserializeStreamReturn(node);\n      case 27 /* IteratorFactory */:\n        return this.deserializeIteratorFactory(node);\n      case 29 /* AsyncIteratorFactory */:\n        return this.deserializeAsyncIteratorFactory(node);\n      // case SerovalNodeType.SpecialReference:\n      default:\n        throw new SerovalUnsupportedNodeError(node);\n    }\n  }\n};\n\n// src/core/cross/deserializer.ts\nvar CrossDeserializerContext = class extends BaseDeserializerContext {\n  constructor() {\n    super(...arguments);\n    this.mode = \"cross\";\n  }\n  assignIndexedValue(index, value) {\n    if (!this.refs.has(index)) {\n      this.refs.set(index, value);\n    }\n    return value;\n  }\n};\n\n// src/core/utils/is-valid-identifier.ts\nvar IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\nfunction isValidIdentifier(name) {\n  const char = name[0];\n  return (char === \"$\" || char === \"_\" || char >= \"A\" && char <= \"Z\" || char >= \"a\" && char <= \"z\") && IDENTIFIER_CHECK.test(name);\n}\n\n// src/core/context/serializer.ts\nfunction getAssignmentExpression(assignment) {\n  switch (assignment.t) {\n    case 0 /* Index */:\n      return assignment.s + \"=\" + assignment.v;\n    case 2 /* Set */:\n      return assignment.s + \".set(\" + assignment.k + \",\" + assignment.v + \")\";\n    case 1 /* Add */:\n      return assignment.s + \".add(\" + assignment.v + \")\";\n    case 3 /* Delete */:\n      return assignment.s + \".delete(\" + assignment.k + \")\";\n  }\n}\nfunction mergeAssignments(assignments) {\n  const newAssignments = [];\n  let current = assignments[0];\n  for (let i = 1, len = assignments.length, item, prev = current; i < len; i++) {\n    item = assignments[i];\n    if (item.t === 0 /* Index */ && item.v === prev.v) {\n      current = {\n        t: 0 /* Index */,\n        s: item.s,\n        k: NIL,\n        v: getAssignmentExpression(current)\n      };\n    } else if (item.t === 2 /* Set */ && item.s === prev.s) {\n      current = {\n        t: 2 /* Set */,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: item.v\n      };\n    } else if (item.t === 1 /* Add */ && item.s === prev.s) {\n      current = {\n        t: 1 /* Add */,\n        s: getAssignmentExpression(current),\n        k: NIL,\n        v: item.v\n      };\n    } else if (item.t === 3 /* Delete */ && item.s === prev.s) {\n      current = {\n        t: 3 /* Delete */,\n        s: getAssignmentExpression(current),\n        k: item.k,\n        v: NIL\n      };\n    } else {\n      newAssignments.push(current);\n      current = item;\n    }\n    prev = item;\n  }\n  newAssignments.push(current);\n  return newAssignments;\n}\nfunction resolveAssignments(assignments) {\n  if (assignments.length) {\n    let result = \"\";\n    const merged = mergeAssignments(assignments);\n    for (let i = 0, len = merged.length; i < len; i++) {\n      result += getAssignmentExpression(merged[i]) + \",\";\n    }\n    return result;\n  }\n  return NIL;\n}\nvar NULL_CONSTRUCTOR = \"Object.create(null)\";\nvar SET_CONSTRUCTOR = \"new Set\";\nvar MAP_CONSTRUCTOR = \"new Map\";\nvar PROMISE_RESOLVE = \"Promise.resolve\";\nvar PROMISE_REJECT = \"Promise.reject\";\nvar OBJECT_FLAG_CONSTRUCTOR = {\n  [3 /* Frozen */]: \"Object.freeze\",\n  [2 /* Sealed */]: \"Object.seal\",\n  [1 /* NonExtensible */]: \"Object.preventExtensions\",\n  [0 /* None */]: NIL\n};\nvar BaseSerializerContext = class {\n  constructor(options) {\n    /**\n     * To check if an object is synchronously referencing itself\n     * @private\n     */\n    this.stack = [];\n    /**\n     * Array of object mutations\n     * @private\n     */\n    this.flags = [];\n    /**\n     * Array of assignments to be done (used for recursion)\n     * @private\n     */\n    this.assignments = [];\n    this.plugins = options.plugins;\n    this.features = options.features;\n    this.marked = new Set(options.markedRefs);\n  }\n  createFunction(parameters, body) {\n    return createFunction(this.features, parameters, body);\n  }\n  createEffectfulFunction(parameters, body) {\n    return createEffectfulFunction(this.features, parameters, body);\n  }\n  /**\n   * A tiny function that tells if a reference\n   * is to be accessed. This is a requirement for\n   * deciding whether or not we should generate\n   * an identifier for the object\n   */\n  markRef(id) {\n    this.marked.add(id);\n  }\n  isMarked(id) {\n    return this.marked.has(id);\n  }\n  pushObjectFlag(flag, id) {\n    if (flag !== 0 /* None */) {\n      this.markRef(id);\n      this.flags.push({\n        type: flag,\n        value: this.getRefParam(id)\n      });\n    }\n  }\n  resolveFlags() {\n    let result = \"\";\n    for (let i = 0, current = this.flags, len = current.length; i < len; i++) {\n      const flag = current[i];\n      result += OBJECT_FLAG_CONSTRUCTOR[flag.type] + \"(\" + flag.value + \"),\";\n    }\n    return result;\n  }\n  resolvePatches() {\n    const assignments = resolveAssignments(this.assignments);\n    const flags = this.resolveFlags();\n    if (assignments) {\n      if (flags) {\n        return assignments + flags;\n      }\n      return assignments;\n    }\n    return flags;\n  }\n  /**\n   * Generates the inlined assignment for the reference\n   * This is different from the assignments array as this one\n   * signifies creation rather than mutation\n   */\n  createAssignment(source, value) {\n    this.assignments.push({\n      t: 0 /* Index */,\n      s: source,\n      k: NIL,\n      v: value\n    });\n  }\n  createAddAssignment(ref, value) {\n    this.assignments.push({\n      t: 1 /* Add */,\n      s: this.getRefParam(ref),\n      k: NIL,\n      v: value\n    });\n  }\n  createSetAssignment(ref, key, value) {\n    this.assignments.push({\n      t: 2 /* Set */,\n      s: this.getRefParam(ref),\n      k: key,\n      v: value\n    });\n  }\n  createDeleteAssignment(ref, key) {\n    this.assignments.push({\n      t: 3 /* Delete */,\n      s: this.getRefParam(ref),\n      k: key,\n      v: NIL\n    });\n  }\n  createArrayAssign(ref, index, value) {\n    this.createAssignment(this.getRefParam(ref) + \"[\" + index + \"]\", value);\n  }\n  createObjectAssign(ref, key, value) {\n    this.createAssignment(this.getRefParam(ref) + \".\" + key, value);\n  }\n  /**\n   * Checks if the value is in the stack. Stack here is a reference\n   * structure to know if a object is to be accessed in a TDZ.\n   */\n  isIndexedValueInStack(node) {\n    return node.t === 4 /* IndexedValue */ && this.stack.includes(node.i);\n  }\n  serializeReference(node) {\n    return this.assignIndexedValue(\n      node.i,\n      REFERENCES_KEY + '.get(\"' + node.s + '\")'\n    );\n  }\n  serializeArrayItem(id, item, index) {\n    if (item) {\n      if (this.isIndexedValueInStack(item)) {\n        this.markRef(id);\n        this.createArrayAssign(\n          id,\n          index,\n          this.getRefParam(item.i)\n        );\n        return \"\";\n      }\n      return this.serialize(item);\n    }\n    return \"\";\n  }\n  serializeArray(node) {\n    const id = node.i;\n    if (node.l) {\n      this.stack.push(id);\n      const list = node.a;\n      let values = this.serializeArrayItem(id, list[0], 0);\n      let isHoley = values === \"\";\n      for (let i = 1, len = node.l, item; i < len; i++) {\n        item = this.serializeArrayItem(id, list[i], i);\n        values += \",\" + item;\n        isHoley = item === \"\";\n      }\n      this.stack.pop();\n      this.pushObjectFlag(node.o, node.i);\n      return this.assignIndexedValue(id, \"[\" + values + (isHoley ? \",]\" : \"]\"));\n    }\n    return this.assignIndexedValue(id, \"[]\");\n  }\n  serializeProperty(source, key, val) {\n    if (typeof key === \"string\") {\n      const check = Number(key);\n      const isIdentifier = (\n        // Test if key is a valid positive number or JS identifier\n        // so that we don't have to serialize the key and wrap with brackets\n        check >= 0 && // It's also important to consider that if the key is\n        // indeed numeric, we need to make sure that when\n        // converted back into a string, it's still the same\n        // to the original key. This allows us to differentiate\n        // keys that has numeric formats but in a different\n        // format, which can cause unintentional key declaration\n        // Example: { 0x1: 1 } vs { '0x1': 1 }\n        check.toString() === key || isValidIdentifier(key)\n      );\n      if (this.isIndexedValueInStack(val)) {\n        const refParam = this.getRefParam(val.i);\n        this.markRef(source.i);\n        if (isIdentifier && check !== check) {\n          this.createObjectAssign(source.i, key, refParam);\n        } else {\n          this.createArrayAssign(\n            source.i,\n            isIdentifier ? key : '\"' + key + '\"',\n            refParam\n          );\n        }\n        return \"\";\n      }\n      return (isIdentifier ? key : '\"' + key + '\"') + \":\" + this.serialize(val);\n    }\n    return \"[\" + this.serialize(key) + \"]:\" + this.serialize(val);\n  }\n  serializeProperties(source, record) {\n    const len = record.s;\n    if (len) {\n      const keys = record.k;\n      const values = record.v;\n      this.stack.push(source.i);\n      let result = this.serializeProperty(source, keys[0], values[0]);\n      for (let i = 1, item = result; i < len; i++) {\n        item = this.serializeProperty(source, keys[i], values[i]);\n        result += (item && result && \",\") + item;\n      }\n      this.stack.pop();\n      return \"{\" + result + \"}\";\n    }\n    return \"{}\";\n  }\n  serializeObject(node) {\n    this.pushObjectFlag(node.o, node.i);\n    return this.assignIndexedValue(\n      node.i,\n      this.serializeProperties(node, node.p)\n    );\n  }\n  serializeWithObjectAssign(source, value, serialized) {\n    const fields = this.serializeProperties(source, value);\n    if (fields !== \"{}\") {\n      return \"Object.assign(\" + serialized + \",\" + fields + \")\";\n    }\n    return serialized;\n  }\n  serializeStringKeyAssignment(source, mainAssignments, key, value) {\n    const serialized = this.serialize(value);\n    const check = Number(key);\n    const isIdentifier = (\n      // Test if key is a valid positive number or JS identifier\n      // so that we don't have to serialize the key and wrap with brackets\n      check >= 0 && // It's also important to consider that if the key is\n      // indeed numeric, we need to make sure that when\n      // converted back into a string, it's still the same\n      // to the original key. This allows us to differentiate\n      // keys that has numeric formats but in a different\n      // format, which can cause unintentional key declaration\n      // Example: { 0x1: 1 } vs { '0x1': 1 }\n      check.toString() === key || isValidIdentifier(key)\n    );\n    if (this.isIndexedValueInStack(value)) {\n      if (isIdentifier && check !== check) {\n        this.createObjectAssign(source.i, key, serialized);\n      } else {\n        this.createArrayAssign(\n          source.i,\n          isIdentifier ? key : '\"' + key + '\"',\n          serialized\n        );\n      }\n    } else {\n      const parentAssignment = this.assignments;\n      this.assignments = mainAssignments;\n      if (isIdentifier && check !== check) {\n        this.createObjectAssign(source.i, key, serialized);\n      } else {\n        this.createArrayAssign(\n          source.i,\n          isIdentifier ? key : '\"' + key + '\"',\n          serialized\n        );\n      }\n      this.assignments = parentAssignment;\n    }\n  }\n  serializeAssignment(source, mainAssignments, key, value) {\n    if (typeof key === \"string\") {\n      this.serializeStringKeyAssignment(source, mainAssignments, key, value);\n    } else {\n      const parent = this.stack;\n      this.stack = [];\n      const serialized = this.serialize(value);\n      this.stack = parent;\n      const parentAssignment = this.assignments;\n      this.assignments = mainAssignments;\n      this.createArrayAssign(source.i, this.serialize(key), serialized);\n      this.assignments = parentAssignment;\n    }\n  }\n  serializeAssignments(source, node) {\n    const len = node.s;\n    if (len) {\n      const mainAssignments = [];\n      const keys = node.k;\n      const values = node.v;\n      this.stack.push(source.i);\n      for (let i = 0; i < len; i++) {\n        this.serializeAssignment(source, mainAssignments, keys[i], values[i]);\n      }\n      this.stack.pop();\n      return resolveAssignments(mainAssignments);\n    }\n    return NIL;\n  }\n  serializeDictionary(node, init) {\n    if (node.p) {\n      if (this.features & 8 /* ObjectAssign */) {\n        init = this.serializeWithObjectAssign(node, node.p, init);\n      } else {\n        this.markRef(node.i);\n        const assignments = this.serializeAssignments(node, node.p);\n        if (assignments) {\n          return \"(\" + this.assignIndexedValue(node.i, init) + \",\" + assignments + this.getRefParam(node.i) + \")\";\n        }\n      }\n    }\n    return this.assignIndexedValue(node.i, init);\n  }\n  serializeNullConstructor(node) {\n    this.pushObjectFlag(node.o, node.i);\n    return this.serializeDictionary(node, NULL_CONSTRUCTOR);\n  }\n  serializeDate(node) {\n    return this.assignIndexedValue(node.i, 'new Date(\"' + node.s + '\")');\n  }\n  serializeRegExp(node) {\n    return this.assignIndexedValue(node.i, \"/\" + node.c + \"/\" + node.m);\n  }\n  serializeSetItem(id, item) {\n    if (this.isIndexedValueInStack(item)) {\n      this.markRef(id);\n      this.createAddAssignment(\n        id,\n        this.getRefParam(item.i)\n      );\n      return \"\";\n    }\n    return this.serialize(item);\n  }\n  serializeSet(node) {\n    let serialized = SET_CONSTRUCTOR;\n    const size = node.l;\n    const id = node.i;\n    if (size) {\n      const items = node.a;\n      this.stack.push(id);\n      let result = this.serializeSetItem(id, items[0]);\n      for (let i = 1, item = result; i < size; i++) {\n        item = this.serializeSetItem(id, items[i]);\n        result += (item && result && \",\") + item;\n      }\n      this.stack.pop();\n      if (result) {\n        serialized += \"([\" + result + \"])\";\n      }\n    }\n    return this.assignIndexedValue(id, serialized);\n  }\n  serializeMapEntry(id, key, val, sentinel) {\n    if (this.isIndexedValueInStack(key)) {\n      const keyRef = this.getRefParam(key.i);\n      this.markRef(id);\n      if (this.isIndexedValueInStack(val)) {\n        const valueRef = this.getRefParam(val.i);\n        this.createSetAssignment(id, keyRef, valueRef);\n        return \"\";\n      }\n      if (val.t !== 4 /* IndexedValue */ && val.i != null && this.isMarked(val.i)) {\n        const serialized = \"(\" + this.serialize(val) + \",[\" + sentinel + \",\" + sentinel + \"])\";\n        this.createSetAssignment(id, keyRef, this.getRefParam(val.i));\n        this.createDeleteAssignment(id, sentinel);\n        return serialized;\n      }\n      const parent = this.stack;\n      this.stack = [];\n      this.createSetAssignment(id, keyRef, this.serialize(val));\n      this.stack = parent;\n      return \"\";\n    }\n    if (this.isIndexedValueInStack(val)) {\n      const valueRef = this.getRefParam(val.i);\n      this.markRef(id);\n      if (key.t !== 4 /* IndexedValue */ && key.i != null && this.isMarked(key.i)) {\n        const serialized = \"(\" + this.serialize(key) + \",[\" + sentinel + \",\" + sentinel + \"])\";\n        this.createSetAssignment(id, this.getRefParam(key.i), valueRef);\n        this.createDeleteAssignment(id, sentinel);\n        return serialized;\n      }\n      const parent = this.stack;\n      this.stack = [];\n      this.createSetAssignment(id, this.serialize(key), valueRef);\n      this.stack = parent;\n      return \"\";\n    }\n    return \"[\" + this.serialize(key) + \",\" + this.serialize(val) + \"]\";\n  }\n  serializeMap(node) {\n    let serialized = MAP_CONSTRUCTOR;\n    const size = node.e.s;\n    const id = node.i;\n    const sentinel = node.f;\n    const sentinelId = this.getRefParam(sentinel.i);\n    if (size) {\n      const keys = node.e.k;\n      const vals = node.e.v;\n      this.stack.push(id);\n      let result = this.serializeMapEntry(id, keys[0], vals[0], sentinelId);\n      for (let i = 1, item = result; i < size; i++) {\n        item = this.serializeMapEntry(id, keys[i], vals[i], sentinelId);\n        result += (item && result && \",\") + item;\n      }\n      this.stack.pop();\n      if (result) {\n        serialized += \"([\" + result + \"])\";\n      }\n    }\n    if (sentinel.t === 26 /* SpecialReference */) {\n      this.markRef(sentinel.i);\n      serialized = \"(\" + this.serialize(sentinel) + \",\" + serialized + \")\";\n    }\n    return this.assignIndexedValue(id, serialized);\n  }\n  serializeArrayBuffer(node) {\n    let result = \"new Uint8Array(\";\n    const buffer = node.s;\n    const len = buffer.length;\n    if (len) {\n      result += \"[\" + buffer[0];\n      for (let i = 1; i < len; i++) {\n        result += \",\" + buffer[i];\n      }\n      result += \"]\";\n    }\n    return this.assignIndexedValue(node.i, result + \").buffer\");\n  }\n  serializeTypedArray(node) {\n    return this.assignIndexedValue(\n      node.i,\n      \"new \" + node.c + \"(\" + this.serialize(node.f) + \",\" + node.b + \",\" + node.l + \")\"\n    );\n  }\n  serializeDataView(node) {\n    return this.assignIndexedValue(\n      node.i,\n      \"new DataView(\" + this.serialize(node.f) + \",\" + node.b + \",\" + node.l + \")\"\n    );\n  }\n  serializeAggregateError(node) {\n    const id = node.i;\n    this.stack.push(id);\n    const serialized = this.serializeDictionary(\n      node,\n      'new AggregateError([],\"' + node.m + '\")'\n    );\n    this.stack.pop();\n    return serialized;\n  }\n  serializeError(node) {\n    return this.serializeDictionary(\n      node,\n      \"new \" + ERROR_CONSTRUCTOR_STRING[node.s] + '(\"' + node.m + '\")'\n    );\n  }\n  serializePromise(node) {\n    let serialized;\n    const fulfilled = node.f;\n    const id = node.i;\n    const promiseConstructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;\n    if (this.isIndexedValueInStack(fulfilled)) {\n      const ref = this.getRefParam(fulfilled.i);\n      serialized = promiseConstructor + (node.s ? \"().then(\" + this.createFunction([], ref) + \")\" : \"().catch(\" + this.createEffectfulFunction([], \"throw \" + ref) + \")\");\n    } else {\n      this.stack.push(id);\n      const result = this.serialize(fulfilled);\n      this.stack.pop();\n      serialized = promiseConstructor + \"(\" + result + \")\";\n    }\n    return this.assignIndexedValue(id, serialized);\n  }\n  serializeWellKnownSymbol(node) {\n    return this.assignIndexedValue(node.i, SYMBOL_STRING[node.s]);\n  }\n  serializeBoxed(node) {\n    return this.assignIndexedValue(\n      node.i,\n      \"Object(\" + this.serialize(node.f) + \")\"\n    );\n  }\n  serializePlugin(node) {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.tag === node.c) {\n          return this.assignIndexedValue(\n            node.i,\n            plugin.serialize(node.s, this, {\n              id: node.i\n            })\n          );\n        }\n      }\n    }\n    throw new SerovalMissingPluginError(node.c);\n  }\n  getConstructor(node) {\n    const current = this.serialize(node);\n    return current === this.getRefParam(node.i) ? current : \"(\" + current + \")\";\n  }\n  serializePromiseConstructor(node) {\n    const resolver = this.assignIndexedValue(node.s, \"{p:0,s:0,f:0}\");\n    return this.assignIndexedValue(\n      node.i,\n      this.getConstructor(node.f) + \"(\" + resolver + \")\"\n    );\n  }\n  serializePromiseResolve(node) {\n    return this.getConstructor(node.a[0]) + \"(\" + this.getRefParam(node.i) + \",\" + this.serialize(node.a[1]) + \")\";\n  }\n  serializePromiseReject(node) {\n    return this.getConstructor(node.a[0]) + \"(\" + this.getRefParam(node.i) + \",\" + this.serialize(node.a[1]) + \")\";\n  }\n  serializeSpecialReference(node) {\n    return this.assignIndexedValue(\n      node.i,\n      serializeSpecialReferenceValue(this.features, node.s)\n    );\n  }\n  serializeIteratorFactory(node) {\n    let result = \"\";\n    let initialized = false;\n    if (node.f.t !== 4 /* IndexedValue */) {\n      this.markRef(node.f.i);\n      result = \"(\" + this.serialize(node.f) + \",\";\n      initialized = true;\n    }\n    result += this.assignIndexedValue(\n      node.i,\n      this.createFunction(\n        [\"s\"],\n        this.createFunction(\n          [\"i\", \"c\", \"d\", \"t\"],\n          \"(i=0,t={[\" + this.getRefParam(node.f.i) + \"]:\" + this.createFunction([], \"t\") + \",next:\" + this.createEffectfulFunction(\n            [],\n            \"if(i>s.d)return{done:!0,value:void 0};if(d=s.v[c=i++],c===s.t)throw d;return{done:c===s.d,value:d}\"\n          ) + \"})\"\n        )\n      )\n    );\n    if (initialized) {\n      result += \")\";\n    }\n    return result;\n  }\n  serializeIteratorFactoryInstance(node) {\n    return this.getConstructor(node.a[0]) + \"(\" + this.serialize(node.a[1]) + \")\";\n  }\n  serializeAsyncIteratorFactory(node) {\n    const promise = node.a[0];\n    const symbol = node.a[1];\n    let result = \"\";\n    if (promise.t !== 4 /* IndexedValue */) {\n      this.markRef(promise.i);\n      result += \"(\" + this.serialize(promise);\n    }\n    if (symbol.t !== 4 /* IndexedValue */) {\n      this.markRef(symbol.i);\n      result += (result ? \",\" : \"(\") + this.serialize(symbol);\n    }\n    if (result) {\n      result += \",\";\n    }\n    const iterator = this.assignIndexedValue(\n      node.i,\n      this.createFunction(\n        [\"s\"],\n        this.createFunction(\n          [\"b\", \"c\", \"p\", \"d\", \"e\", \"t\", \"f\"],\n          /**\n           * b = resolved values\n           * c = b size\n           * p = pending promises\n           * d = index where the resolved value stops\n           * e = if the last value is a throw\n           * t = placeholder variable\n           * f = finalize\n           */\n          \"(b=[],c=0,p=[],d=-1,e=!1,f=\" + this.createEffectfulFunction(\n            [\"i\", \"l\"],\n            \"for(i=0,l=p.length;i<l;i++)p[i].s({done:!0,value:void 0})\"\n          ) + \",s.on({next:\" + this.createEffectfulFunction(\n            [\"v\", \"t\"],\n            \"if(t=p.shift())t.s({done:!1,value:v});b.push(v)\"\n          ) + \",throw:\" + this.createEffectfulFunction(\n            [\"v\", \"t\"],\n            \"if(t=p.shift())t.f(v);f(),d=b.length,e=!0,b.push(v)\"\n          ) + \",return:\" + this.createEffectfulFunction(\n            [\"v\", \"t\"],\n            \"if(t=p.shift())t.s({done:!0,value:v});f(),d=b.length,b.push(v)\"\n          ) + \"}),t={[\" + this.getRefParam(symbol.i) + \"]:\" + this.createFunction([], \"t.p\") + \",next:\" + this.createEffectfulFunction(\n            [\"i\", \"t\", \"v\"],\n            \"if(d===-1){return((i=c++)>=b.length)?(\" + this.getRefParam(promise.i) + \"(t={p:0,s:0,f:0}),p.push(t),t.p):{done:!1,value:b[i]}}if(c>d)return{done:!0,value:void 0};if(v=b[i=c++],i!==d)return{done:!1,value:v};if(e)throw v;return{done:!0,value:v}\"\n          ) + \"})\"\n        )\n      )\n    );\n    if (result) {\n      return result + iterator + \")\";\n    }\n    return iterator;\n  }\n  serializeAsyncIteratorFactoryInstance(node) {\n    return this.getConstructor(node.a[0]) + \"(\" + this.serialize(node.a[1]) + \")\";\n  }\n  serializeStreamConstructor(node) {\n    const result = this.assignIndexedValue(\n      node.i,\n      this.getConstructor(node.f) + \"()\"\n    );\n    const len = node.a.length;\n    if (len) {\n      let values = this.serialize(node.a[0]);\n      for (let i = 1; i < len; i++) {\n        values += \",\" + this.serialize(node.a[i]);\n      }\n      return \"(\" + result + \",\" + values + \",\" + this.getRefParam(node.i) + \")\";\n    }\n    return result;\n  }\n  serializeStreamNext(node) {\n    return this.getRefParam(node.i) + \".next(\" + this.serialize(node.f) + \")\";\n  }\n  serializeStreamThrow(node) {\n    return this.getRefParam(node.i) + \".throw(\" + this.serialize(node.f) + \")\";\n  }\n  serializeStreamReturn(node) {\n    return this.getRefParam(node.i) + \".return(\" + this.serialize(node.f) + \")\";\n  }\n  serialize(node) {\n    try {\n      switch (node.t) {\n        case 2 /* Constant */:\n          return CONSTANT_STRING[node.s];\n        case 0 /* Number */:\n          return \"\" + node.s;\n        case 1 /* String */:\n          return '\"' + node.s + '\"';\n        case 3 /* BigInt */:\n          return node.s + \"n\";\n        case 4 /* IndexedValue */:\n          return this.getRefParam(node.i);\n        case 18 /* Reference */:\n          return this.serializeReference(node);\n        case 9 /* Array */:\n          return this.serializeArray(node);\n        case 10 /* Object */:\n          return this.serializeObject(node);\n        case 11 /* NullConstructor */:\n          return this.serializeNullConstructor(node);\n        case 5 /* Date */:\n          return this.serializeDate(node);\n        case 6 /* RegExp */:\n          return this.serializeRegExp(node);\n        case 7 /* Set */:\n          return this.serializeSet(node);\n        case 8 /* Map */:\n          return this.serializeMap(node);\n        case 19 /* ArrayBuffer */:\n          return this.serializeArrayBuffer(node);\n        case 16 /* BigIntTypedArray */:\n        case 15 /* TypedArray */:\n          return this.serializeTypedArray(node);\n        case 20 /* DataView */:\n          return this.serializeDataView(node);\n        case 14 /* AggregateError */:\n          return this.serializeAggregateError(node);\n        case 13 /* Error */:\n          return this.serializeError(node);\n        case 12 /* Promise */:\n          return this.serializePromise(node);\n        case 17 /* WKSymbol */:\n          return this.serializeWellKnownSymbol(node);\n        case 21 /* Boxed */:\n          return this.serializeBoxed(node);\n        case 22 /* PromiseConstructor */:\n          return this.serializePromiseConstructor(node);\n        case 23 /* PromiseSuccess */:\n          return this.serializePromiseResolve(node);\n        case 24 /* PromiseFailure */:\n          return this.serializePromiseReject(node);\n        case 25 /* Plugin */:\n          return this.serializePlugin(node);\n        case 26 /* SpecialReference */:\n          return this.serializeSpecialReference(node);\n        case 27 /* IteratorFactory */:\n          return this.serializeIteratorFactory(node);\n        case 28 /* IteratorFactoryInstance */:\n          return this.serializeIteratorFactoryInstance(node);\n        case 29 /* AsyncIteratorFactory */:\n          return this.serializeAsyncIteratorFactory(node);\n        case 30 /* AsyncIteratorFactoryInstance */:\n          return this.serializeAsyncIteratorFactoryInstance(node);\n        case 31 /* StreamConstructor */:\n          return this.serializeStreamConstructor(node);\n        case 32 /* StreamNext */:\n          return this.serializeStreamNext(node);\n        case 33 /* StreamThrow */:\n          return this.serializeStreamThrow(node);\n        case 34 /* StreamReturn */:\n          return this.serializeStreamReturn(node);\n        default:\n          throw new SerovalUnsupportedNodeError(node);\n      }\n    } catch (error) {\n      throw new SerovalSerializationError(error);\n    }\n  }\n};\n\n// src/core/cross/serializer.ts\nvar CrossSerializerContext = class extends BaseSerializerContext {\n  constructor(options) {\n    super(options);\n    this.mode = \"cross\";\n    this.scopeId = options.scopeId;\n  }\n  getRefParam(id) {\n    return GLOBAL_CONTEXT_REFERENCES + \"[\" + id + \"]\";\n  }\n  assignIndexedValue(index, value) {\n    return this.getRefParam(index) + \"=\" + value;\n  }\n  serializeTop(tree) {\n    const result = this.serialize(tree);\n    const id = tree.i;\n    if (id == null) {\n      return result;\n    }\n    const patches = this.resolvePatches();\n    const ref = this.getRefParam(id);\n    const params = this.scopeId == null ? \"\" : GLOBAL_CONTEXT_REFERENCES;\n    const body = patches ? \"(\" + result + \",\" + patches + ref + \")\" : result;\n    if (params === \"\") {\n      if (tree.t === 10 /* Object */ && !patches) {\n        return \"(\" + body + \")\";\n      }\n      return body;\n    }\n    const args = this.scopeId == null ? \"()\" : \"(\" + GLOBAL_CONTEXT_REFERENCES + '[\"' + serializeString(this.scopeId) + '\"])';\n    return \"(\" + this.createFunction([params], body) + \")\" + args;\n  }\n};\n\n// src/core/context/parser/sync.ts\nvar BaseSyncParserContext = class extends BaseParserContext {\n  parseItems(current) {\n    const nodes = [];\n    for (let i = 0, len = current.length; i < len; i++) {\n      if (i in current) {\n        nodes[i] = this.parse(current[i]);\n      }\n    }\n    return nodes;\n  }\n  parseArray(id, current) {\n    return createArrayNode(id, current, this.parseItems(current));\n  }\n  parseProperties(properties) {\n    const entries = Object.entries(properties);\n    const keyNodes = [];\n    const valueNodes = [];\n    for (let i = 0, len = entries.length; i < len; i++) {\n      keyNodes.push(serializeString(entries[i][0]));\n      valueNodes.push(this.parse(entries[i][1]));\n    }\n    let symbol = Symbol.iterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createIteratorFactoryInstanceNode(\n          this.parseIteratorFactory(),\n          this.parse(\n            iteratorToSequence(properties)\n          )\n        )\n      );\n    }\n    symbol = Symbol.asyncIterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createAsyncIteratorFactoryInstanceNode(\n          this.parseAsyncIteratorFactory(),\n          this.parse(createStream())\n        )\n      );\n    }\n    symbol = Symbol.toStringTag;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(createStringNode(properties[symbol]));\n    }\n    symbol = Symbol.isConcatSpreadable;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n    }\n    return {\n      k: keyNodes,\n      v: valueNodes,\n      s: keyNodes.length\n    };\n  }\n  parsePlainObject(id, current, empty) {\n    return this.createObjectNode(\n      id,\n      current,\n      empty,\n      this.parseProperties(current)\n    );\n  }\n  parseBoxed(id, current) {\n    return createBoxedNode(id, this.parse(current.valueOf()));\n  }\n  parseTypedArray(id, current) {\n    return createTypedArrayNode(id, current, this.parse(current.buffer));\n  }\n  parseBigIntTypedArray(id, current) {\n    return createBigIntTypedArrayNode(id, current, this.parse(current.buffer));\n  }\n  parseDataView(id, current) {\n    return createDataViewNode(id, current, this.parse(current.buffer));\n  }\n  parseError(id, current) {\n    const options = getErrorOptions(current, this.features);\n    return createErrorNode(\n      id,\n      current,\n      options ? this.parseProperties(options) : NIL\n    );\n  }\n  parseAggregateError(id, current) {\n    const options = getErrorOptions(current, this.features);\n    return createAggregateErrorNode(\n      id,\n      current,\n      options ? this.parseProperties(options) : NIL\n    );\n  }\n  parseMap(id, current) {\n    const keyNodes = [];\n    const valueNodes = [];\n    for (const [key, value] of current.entries()) {\n      keyNodes.push(this.parse(key));\n      valueNodes.push(this.parse(value));\n    }\n    return this.createMapNode(id, keyNodes, valueNodes, current.size);\n  }\n  parseSet(id, current) {\n    const items = [];\n    for (const item of current.keys()) {\n      items.push(this.parse(item));\n    }\n    return createSetNode(id, current.size, items);\n  }\n  parsePlugin(id, current) {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.parse.sync && plugin.test(current)) {\n          return createPluginNode(\n            id,\n            plugin.tag,\n            plugin.parse.sync(current, this, {\n              id\n            })\n          );\n        }\n      }\n    }\n    return void 0;\n  }\n  parseStream(id, _current) {\n    return createStreamConstructorNode(\n      id,\n      this.parseSpecialReference(4 /* StreamConstructor */),\n      []\n    );\n  }\n  parsePromise(id, _current) {\n    return this.createPromiseConstructorNode(id, this.createIndex({}));\n  }\n  // biome-ignore lint/complexity/noExcessiveCognitiveComplexity: ehh\n  parseObject(id, current) {\n    if (Array.isArray(current)) {\n      return this.parseArray(id, current);\n    }\n    if (isStream(current)) {\n      return this.parseStream(id, current);\n    }\n    const currentClass = current.constructor;\n    if (currentClass === OpaqueReference) {\n      return this.parse(\n        current.replacement\n      );\n    }\n    const parsed = this.parsePlugin(id, current);\n    if (parsed) {\n      return parsed;\n    }\n    switch (currentClass) {\n      case Object:\n        return this.parsePlainObject(\n          id,\n          current,\n          false\n        );\n      case void 0:\n        return this.parsePlainObject(\n          id,\n          current,\n          true\n        );\n      case Date:\n        return createDateNode(id, current);\n      case RegExp:\n        return createRegExpNode(id, current);\n      case Error:\n      case EvalError:\n      case RangeError:\n      case ReferenceError:\n      case SyntaxError:\n      case TypeError:\n      case URIError:\n        return this.parseError(id, current);\n      case Number:\n      case Boolean:\n      case String:\n      case BigInt:\n        return this.parseBoxed(id, current);\n      case ArrayBuffer:\n        return createArrayBufferNode(id, current);\n      case Int8Array:\n      case Int16Array:\n      case Int32Array:\n      case Uint8Array:\n      case Uint16Array:\n      case Uint32Array:\n      case Uint8ClampedArray:\n      case Float32Array:\n      case Float64Array:\n        return this.parseTypedArray(id, current);\n      case DataView:\n        return this.parseDataView(id, current);\n      case Map:\n        return this.parseMap(id, current);\n      case Set:\n        return this.parseSet(id, current);\n      default:\n        break;\n    }\n    if (currentClass === Promise || current instanceof Promise) {\n      return this.parsePromise(id, current);\n    }\n    const currentFeatures = this.features;\n    if (currentFeatures & 16 /* BigIntTypedArray */) {\n      switch (currentClass) {\n        case BigInt64Array:\n        case BigUint64Array:\n          return this.parseBigIntTypedArray(\n            id,\n            current\n          );\n        default:\n          break;\n      }\n    }\n    if (currentFeatures & 1 /* AggregateError */ && typeof AggregateError !== \"undefined\" && (currentClass === AggregateError || current instanceof AggregateError)) {\n      return this.parseAggregateError(id, current);\n    }\n    if (current instanceof Error) {\n      return this.parseError(id, current);\n    }\n    if (Symbol.iterator in current || Symbol.asyncIterator in current) {\n      return this.parsePlainObject(id, current, !!currentClass);\n    }\n    throw new SerovalUnsupportedTypeError(current);\n  }\n  parseFunction(current) {\n    const ref = this.getReference(current);\n    if (ref.type !== 0 /* Fresh */) {\n      return ref.value;\n    }\n    const plugin = this.parsePlugin(ref.value, current);\n    if (plugin) {\n      return plugin;\n    }\n    throw new SerovalUnsupportedTypeError(current);\n  }\n  parse(current) {\n    switch (typeof current) {\n      case \"boolean\":\n        return current ? TRUE_NODE : FALSE_NODE;\n      case \"undefined\":\n        return UNDEFINED_NODE;\n      case \"string\":\n        return createStringNode(current);\n      case \"number\":\n        return createNumberNode(current);\n      case \"bigint\":\n        return createBigIntNode(current);\n      case \"object\": {\n        if (current) {\n          const ref = this.getReference(current);\n          return ref.type === 0 /* Fresh */ ? this.parseObject(ref.value, current) : ref.value;\n        }\n        return NULL_NODE;\n      }\n      case \"symbol\":\n        return this.parseWellKnownSymbol(current);\n      case \"function\": {\n        return this.parseFunction(current);\n      }\n      default:\n        throw new SerovalUnsupportedTypeError(current);\n    }\n  }\n  parseTop(current) {\n    try {\n      return this.parse(current);\n    } catch (error) {\n      throw error instanceof SerovalParserError ? error : new SerovalParserError(error);\n    }\n  }\n};\n\n// src/core/context/parser/stream.ts\nvar BaseStreamParserContext = class extends BaseSyncParserContext {\n  constructor(options) {\n    super(options);\n    // Life\n    this.alive = true;\n    // Amount of pending promises/streams\n    this.pending = 0;\n    this.initial = true;\n    this.buffer = [];\n    this.onParseCallback = options.onParse;\n    this.onErrorCallback = options.onError;\n    this.onDoneCallback = options.onDone;\n  }\n  onParseInternal(node, initial) {\n    try {\n      this.onParseCallback(node, initial);\n    } catch (error) {\n      this.onError(error);\n    }\n  }\n  flush() {\n    for (let i = 0, len = this.buffer.length; i < len; i++) {\n      this.onParseInternal(this.buffer[i], false);\n    }\n  }\n  onParse(node) {\n    if (this.initial) {\n      this.buffer.push(node);\n    } else {\n      this.onParseInternal(node, false);\n    }\n  }\n  onError(error) {\n    if (this.onErrorCallback) {\n      this.onErrorCallback(error);\n    } else {\n      throw error;\n    }\n  }\n  onDone() {\n    if (this.onDoneCallback) {\n      this.onDoneCallback();\n    }\n  }\n  pushPendingState() {\n    this.pending++;\n  }\n  popPendingState() {\n    if (--this.pending <= 0) {\n      this.onDone();\n    }\n  }\n  parseProperties(properties) {\n    const entries = Object.entries(properties);\n    const keyNodes = [];\n    const valueNodes = [];\n    for (let i = 0, len = entries.length; i < len; i++) {\n      keyNodes.push(serializeString(entries[i][0]));\n      valueNodes.push(this.parse(entries[i][1]));\n    }\n    let symbol = Symbol.iterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createIteratorFactoryInstanceNode(\n          this.parseIteratorFactory(),\n          this.parse(\n            iteratorToSequence(properties)\n          )\n        )\n      );\n    }\n    symbol = Symbol.asyncIterator;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(\n        createAsyncIteratorFactoryInstanceNode(\n          this.parseAsyncIteratorFactory(),\n          this.parse(\n            createStreamFromAsyncIterable(\n              properties\n            )\n          )\n        )\n      );\n    }\n    symbol = Symbol.toStringTag;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(createStringNode(properties[symbol]));\n    }\n    symbol = Symbol.isConcatSpreadable;\n    if (symbol in properties) {\n      keyNodes.push(this.parseWellKnownSymbol(symbol));\n      valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n    }\n    return {\n      k: keyNodes,\n      v: valueNodes,\n      s: keyNodes.length\n    };\n  }\n  handlePromiseSuccess(id, data) {\n    const parsed = this.parseWithError(data);\n    if (parsed) {\n      this.onParse(\n        createSerovalNode(\n          23 /* PromiseSuccess */,\n          id,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          NIL,\n          [this.parseSpecialReference(2 /* PromiseSuccess */), parsed],\n          NIL,\n          NIL,\n          NIL\n        )\n      );\n    }\n    this.popPendingState();\n  }\n  handlePromiseFailure(id, data) {\n    if (this.alive) {\n      const parsed = this.parseWithError(data);\n      if (parsed) {\n        this.onParse(\n          createSerovalNode(\n            24 /* PromiseFailure */,\n            id,\n            NIL,\n            NIL,\n            NIL,\n            NIL,\n            NIL,\n            NIL,\n            [\n              this.parseSpecialReference(3 /* PromiseFailure */),\n              parsed\n            ],\n            NIL,\n            NIL,\n            NIL\n          )\n        );\n      }\n    }\n    this.popPendingState();\n  }\n  parsePromise(id, current) {\n    const resolver = this.createIndex({});\n    current.then(\n      this.handlePromiseSuccess.bind(this, resolver),\n      this.handlePromiseFailure.bind(this, resolver)\n    );\n    this.pushPendingState();\n    return this.createPromiseConstructorNode(id, resolver);\n  }\n  parsePlugin(id, current) {\n    const currentPlugins = this.plugins;\n    if (currentPlugins) {\n      for (let i = 0, len = currentPlugins.length; i < len; i++) {\n        const plugin = currentPlugins[i];\n        if (plugin.parse.stream && plugin.test(current)) {\n          return createPluginNode(\n            id,\n            plugin.tag,\n            plugin.parse.stream(current, this, {\n              id\n            })\n          );\n        }\n      }\n    }\n    return NIL;\n  }\n  parseStream(id, current) {\n    const result = createStreamConstructorNode(\n      id,\n      this.parseSpecialReference(4 /* StreamConstructor */),\n      []\n    );\n    this.pushPendingState();\n    current.on({\n      next: (value) => {\n        if (this.alive) {\n          const parsed = this.parseWithError(value);\n          if (parsed) {\n            this.onParse(createStreamNextNode(id, parsed));\n          }\n        }\n      },\n      throw: (value) => {\n        if (this.alive) {\n          const parsed = this.parseWithError(value);\n          if (parsed) {\n            this.onParse(createStreamThrowNode(id, parsed));\n          }\n        }\n        this.popPendingState();\n      },\n      return: (value) => {\n        if (this.alive) {\n          const parsed = this.parseWithError(value);\n          if (parsed) {\n            this.onParse(createStreamReturnNode(id, parsed));\n          }\n        }\n        this.popPendingState();\n      }\n    });\n    return result;\n  }\n  parseWithError(current) {\n    try {\n      return this.parse(current);\n    } catch (err) {\n      this.onError(err);\n      return NIL;\n    }\n  }\n  /**\n   * @private\n   */\n  start(current) {\n    const parsed = this.parseWithError(current);\n    if (parsed) {\n      this.onParseInternal(parsed, true);\n      this.initial = false;\n      this.flush();\n      if (this.pending <= 0) {\n        this.destroy();\n      }\n    }\n  }\n  /**\n   * @private\n   */\n  destroy() {\n    if (this.alive) {\n      this.onDone();\n      this.alive = false;\n    }\n  }\n  isAlive() {\n    return this.alive;\n  }\n};\n\n// src/core/cross/stream.ts\nvar CrossStreamParserContext = class extends BaseStreamParserContext {\n  constructor() {\n    super(...arguments);\n    this.mode = \"cross\";\n  }\n};\n\n// src/core/cross/sync.ts\nvar CrossSyncParserContext = class extends BaseSyncParserContext {\n  constructor() {\n    super(...arguments);\n    this.mode = \"cross\";\n  }\n};\n\n// src/core/cross/index.ts\nfunction crossSerialize(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new CrossSyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs\n  });\n  const tree = ctx.parseTop(source);\n  const serial = new CrossSerializerContext({\n    plugins,\n    features: ctx.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.marked\n  });\n  return serial.serializeTop(tree);\n}\nasync function crossSerializeAsync(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new CrossAsyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs\n  });\n  const tree = await ctx.parseTop(source);\n  const serial = new CrossSerializerContext({\n    plugins,\n    features: ctx.features,\n    scopeId: options.scopeId,\n    markedRefs: ctx.marked\n  });\n  return serial.serializeTop(tree);\n}\nfunction toCrossJSON(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new CrossSyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs\n  });\n  return ctx.parseTop(source);\n}\nasync function toCrossJSONAsync(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new CrossAsyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures,\n    refs: options.refs\n  });\n  return await ctx.parseTop(source);\n}\nfunction crossSerializeStream(source, options) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new CrossStreamParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse(node, initial) {\n      const serial = new CrossSerializerContext({\n        plugins,\n        features: ctx.features,\n        scopeId: options.scopeId,\n        markedRefs: ctx.marked\n      });\n      let serialized;\n      try {\n        serialized = serial.serializeTop(node);\n      } catch (err) {\n        if (options.onError) {\n          options.onError(err);\n        }\n        return;\n      }\n      options.onSerialize(serialized, initial);\n    },\n    onError: options.onError,\n    onDone: options.onDone\n  });\n  ctx.start(source);\n  return ctx.destroy.bind(ctx);\n}\nfunction toCrossJSONStream(source, options) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new CrossStreamParserContext({\n    plugins,\n    refs: options.refs,\n    disabledFeatures: options.disabledFeatures,\n    onParse: options.onParse,\n    onError: options.onError,\n    onDone: options.onDone\n  });\n  ctx.start(source);\n  return ctx.destroy.bind(ctx);\n}\nfunction fromCrossJSON(source, options) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new CrossDeserializerContext({\n    plugins,\n    refs: options.refs\n  });\n  return ctx.deserializeTop(source);\n}\n\n// src/core/tree/async.ts\nvar AsyncParserContext = class extends BaseAsyncParserContext {\n  constructor() {\n    super(...arguments);\n    this.mode = \"vanilla\";\n  }\n};\n\n// src/core/tree/deserializer.ts\nvar VanillaDeserializerContext = class extends BaseDeserializerContext {\n  constructor(options) {\n    super(options);\n    this.mode = \"vanilla\";\n    this.marked = new Set(options.markedRefs);\n  }\n  assignIndexedValue(index, value) {\n    if (this.marked.has(index)) {\n      this.refs.set(index, value);\n    }\n    return value;\n  }\n};\n\n// src/core/utils/get-identifier.ts\nvar REF_START_CHARS = \"hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_\";\nvar REF_START_CHARS_LEN = REF_START_CHARS.length;\nvar REF_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_\";\nvar REF_CHARS_LEN = REF_CHARS.length;\nfunction getIdentifier(index) {\n  let mod = index % REF_START_CHARS_LEN;\n  let ref = REF_START_CHARS[mod];\n  index = (index - mod) / REF_START_CHARS_LEN;\n  while (index > 0) {\n    mod = index % REF_CHARS_LEN;\n    ref += REF_CHARS[mod];\n    index = (index - mod) / REF_CHARS_LEN;\n  }\n  return ref;\n}\n\n// src/core/tree/serializer.ts\nvar VanillaSerializerContext = class extends BaseSerializerContext {\n  constructor() {\n    super(...arguments);\n    this.mode = \"vanilla\";\n    /**\n     * Map tree refs to actual refs\n     * @private\n     */\n    this.valid = /* @__PURE__ */ new Map();\n    /**\n     * Variables\n     * @private\n     */\n    this.vars = [];\n  }\n  /**\n   * Creates the reference param (identifier) from the given reference ID\n   * Calling this function means the value has been referenced somewhere\n   */\n  getRefParam(index) {\n    let actualIndex = this.valid.get(index);\n    if (actualIndex == null) {\n      actualIndex = this.valid.size;\n      this.valid.set(index, actualIndex);\n    }\n    let identifier = this.vars[actualIndex];\n    if (identifier == null) {\n      identifier = getIdentifier(actualIndex);\n      this.vars[actualIndex] = identifier;\n    }\n    return identifier;\n  }\n  assignIndexedValue(index, value) {\n    if (this.isMarked(index)) {\n      return this.getRefParam(index) + \"=\" + value;\n    }\n    return value;\n  }\n  serializePromiseConstructor(node) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  serializePromiseResolve(node) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  serializePromiseReject(node) {\n    throw new SerovalUnsupportedNodeError(node);\n  }\n  serializeTop(tree) {\n    const result = this.serialize(tree);\n    if (tree.i != null && this.vars.length) {\n      const patches = this.resolvePatches();\n      let body = result;\n      if (patches) {\n        const index = this.getRefParam(tree.i);\n        body = result + \",\" + patches + index;\n        if (!result.startsWith(index + \"=\")) {\n          body = index + \"=\" + body;\n        }\n        body = \"(\" + body + \")\";\n      }\n      return \"(\" + this.createFunction(this.vars, body) + \")()\";\n    }\n    if (tree.t === 10 /* Object */) {\n      return \"(\" + result + \")\";\n    }\n    return result;\n  }\n};\n\n// src/core/tree/sync.ts\nvar SyncParserContext = class extends BaseSyncParserContext {\n  constructor() {\n    super(...arguments);\n    this.mode = \"vanilla\";\n  }\n};\n\n// src/core/tree/index.ts\nfunction serialize(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new SyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures\n  });\n  const tree = ctx.parseTop(source);\n  const serial = new VanillaSerializerContext({\n    plugins,\n    features: ctx.features,\n    markedRefs: ctx.marked\n  });\n  return serial.serializeTop(tree);\n}\nasync function serializeAsync(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new AsyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures\n  });\n  const tree = await ctx.parseTop(source);\n  const serial = new VanillaSerializerContext({\n    plugins,\n    features: ctx.features,\n    markedRefs: ctx.marked\n  });\n  return serial.serializeTop(tree);\n}\nfunction deserialize(source) {\n  return (0, eval)(source);\n}\nfunction toJSON(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new SyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures\n  });\n  return {\n    t: ctx.parseTop(source),\n    f: ctx.features,\n    m: Array.from(ctx.marked)\n  };\n}\nasync function toJSONAsync(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new AsyncParserContext({\n    plugins,\n    disabledFeatures: options.disabledFeatures\n  });\n  return {\n    t: await ctx.parseTop(source),\n    f: ctx.features,\n    m: Array.from(ctx.marked)\n  };\n}\nfunction compileJSON(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new VanillaSerializerContext({\n    plugins,\n    features: source.f,\n    markedRefs: source.m\n  });\n  return ctx.serializeTop(source.t);\n}\nfunction fromJSON(source, options = {}) {\n  const plugins = resolvePlugins(options.plugins);\n  const ctx = new VanillaDeserializerContext({\n    plugins,\n    markedRefs: source.m\n  });\n  return ctx.deserializeTop(source.t);\n}\n\n// src/core/Serializer.ts\nvar Serializer = class {\n  constructor(options) {\n    this.options = options;\n    this.alive = true;\n    this.flushed = false;\n    this.done = false;\n    this.pending = 0;\n    this.cleanups = [];\n    this.refs = /* @__PURE__ */ new Map();\n    this.keys = /* @__PURE__ */ new Set();\n    this.ids = 0;\n    this.plugins = resolvePlugins(options.plugins);\n  }\n  write(key, value) {\n    if (this.alive && !this.flushed) {\n      this.pending++;\n      this.keys.add(key);\n      this.cleanups.push(\n        crossSerializeStream(value, {\n          plugins: this.plugins,\n          scopeId: this.options.scopeId,\n          refs: this.refs,\n          disabledFeatures: this.options.disabledFeatures,\n          onError: this.options.onError,\n          onSerialize: (data, initial) => {\n            if (this.alive) {\n              this.options.onData(\n                initial ? this.options.globalIdentifier + '[\"' + serializeString(key) + '\"]=' + data : data\n              );\n            }\n          },\n          onDone: () => {\n            if (this.alive) {\n              this.pending--;\n              if (this.pending <= 0 && this.flushed && !this.done && this.options.onDone) {\n                this.options.onDone();\n                this.done = true;\n              }\n            }\n          }\n        })\n      );\n    }\n  }\n  getNextID() {\n    while (this.keys.has(\"\" + this.ids)) {\n      this.ids++;\n    }\n    return \"\" + this.ids;\n  }\n  push(value) {\n    const newID = this.getNextID();\n    this.write(newID, value);\n    return newID;\n  }\n  flush() {\n    if (this.alive) {\n      this.flushed = true;\n      if (this.pending <= 0 && !this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n    }\n  }\n  close() {\n    if (this.alive) {\n      for (let i = 0, len = this.cleanups.length; i < len; i++) {\n        this.cleanups[i]();\n      }\n      if (!this.done && this.options.onDone) {\n        this.options.onDone();\n        this.done = true;\n      }\n      this.alive = false;\n    }\n  }\n};\nexport {\n  Feature,\n  OpaqueReference,\n  Serializer,\n  SerovalDeserializationError,\n  SerovalError,\n  SerovalMissingInstanceError,\n  SerovalMissingPluginError,\n  SerovalMissingReferenceError,\n  SerovalMissingReferenceForIdError,\n  SerovalParserError,\n  SerovalSerializationError,\n  SerovalUnknownTypedArrayError,\n  SerovalUnsupportedNodeError,\n  SerovalUnsupportedTypeError,\n  compileJSON,\n  createPlugin,\n  createReference,\n  createStream,\n  crossSerialize,\n  crossSerializeAsync,\n  crossSerializeStream,\n  deserialize,\n  fromCrossJSON,\n  fromJSON,\n  getCrossReferenceHeader,\n  resolvePlugins,\n  serialize,\n  serializeAsync,\n  toCrossJSON,\n  toCrossJSONAsync,\n  toCrossJSONStream,\n  toJSON,\n  toJSONAsync\n};\n//# sourceMappingURL=index.mjs.map\n","import { createPlugin } from \"seroval\";\nimport { GLOBAL_TSR } from \"../constants.js\";\nfunction createSerializationAdapter(opts) {\n  return opts;\n}\nfunction makeSsrSerovalPlugin(serializationAdapter, options) {\n  return createPlugin({\n    tag: \"$TSR/t/\" + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value));\n      }\n    },\n    serialize(node, ctx) {\n      options.didRun = true;\n      return GLOBAL_TSR + '.t.get(\"' + serializationAdapter.key + '\")(' + ctx.serialize(node) + \")\";\n    },\n    // we never deserialize on the server during SSR\n    deserialize: void 0\n  });\n}\nfunction makeSerovalPlugin(serializationAdapter) {\n  return createPlugin({\n    tag: \"$TSR/t/\" + serializationAdapter.key,\n    test: serializationAdapter.test,\n    parse: {\n      sync(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value));\n      },\n      async async(value, ctx) {\n        return await ctx.parse(serializationAdapter.toSerializable(value));\n      },\n      stream(value, ctx) {\n        return ctx.parse(serializationAdapter.toSerializable(value));\n      }\n    },\n    // we don't generate JS code outside of SSR (for now)\n    serialize: void 0,\n    deserialize(node, ctx) {\n      return serializationAdapter.fromSerializable(ctx.deserialize(node));\n    }\n  });\n}\nexport {\n  createSerializationAdapter,\n  makeSerovalPlugin,\n  makeSsrSerovalPlugin\n};\n//# sourceMappingURL=transformer.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { defer, TSR_DEFERRED_PROMISE } from \"@tanstack/router-core\";\nfunction useAwaited({\n  promise: _promise\n}) {\n  const promise = defer(_promise);\n  if (promise[TSR_DEFERRED_PROMISE].status === \"pending\") {\n    throw promise;\n  }\n  if (promise[TSR_DEFERRED_PROMISE].status === \"error\") {\n    throw promise[TSR_DEFERRED_PROMISE].error;\n  }\n  return [promise[TSR_DEFERRED_PROMISE].data, promise];\n}\nfunction Await(props) {\n  const inner = /* @__PURE__ */ jsx(AwaitInner, { ...props });\n  if (props.fallback) {\n    return /* @__PURE__ */ jsx(React.Suspense, { fallback: props.fallback, children: inner });\n  }\n  return inner;\n}\nfunction AwaitInner(props) {\n  const [data] = useAwaited(props);\n  return props.children(data);\n}\nexport {\n  Await,\n  useAwaited\n};\n//# sourceMappingURL=awaited.js.map\n","import { jsx, jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nfunction CatchBoundary(props) {\n  const errorComponent = props.errorComponent ?? ErrorComponent;\n  return /* @__PURE__ */ jsx(\n    CatchBoundaryImpl,\n    {\n      getResetKey: props.getResetKey,\n      onCatch: props.onCatch,\n      children: ({ error, reset }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n            reset\n          });\n        }\n        return props.children;\n      }\n    }\n  );\n}\nclass CatchBoundaryImpl extends React.Component {\n  constructor() {\n    super(...arguments);\n    this.state = { error: null };\n  }\n  static getDerivedStateFromProps(props) {\n    return { resetKey: props.getResetKey() };\n  }\n  static getDerivedStateFromError(error) {\n    return { error };\n  }\n  reset() {\n    this.setState({ error: null });\n  }\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.error && prevState.resetKey !== this.state.resetKey) {\n      this.reset();\n    }\n  }\n  componentDidCatch(error, errorInfo) {\n    if (this.props.onCatch) {\n      this.props.onCatch(error, errorInfo);\n    }\n  }\n  render() {\n    return this.props.children({\n      error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,\n      reset: () => {\n        this.reset();\n      }\n    });\n  }\n}\nfunction ErrorComponent({ error }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== \"production\");\n  return /* @__PURE__ */ jsxs(\"div\", { style: { padding: \".5rem\", maxWidth: \"100%\" }, children: [\n    /* @__PURE__ */ jsxs(\"div\", { style: { display: \"flex\", alignItems: \"center\", gap: \".5rem\" }, children: [\n      /* @__PURE__ */ jsx(\"strong\", { style: { fontSize: \"1rem\" }, children: \"Something went wrong!\" }),\n      /* @__PURE__ */ jsx(\n        \"button\",\n        {\n          style: {\n            appearance: \"none\",\n            fontSize: \".6em\",\n            border: \"1px solid currentColor\",\n            padding: \".1rem .2rem\",\n            fontWeight: \"bold\",\n            borderRadius: \".25rem\"\n          },\n          onClick: () => setShow((d) => !d),\n          children: show ? \"Hide Error\" : \"Show Error\"\n        }\n      )\n    ] }),\n    /* @__PURE__ */ jsx(\"div\", { style: { height: \".25rem\" } }),\n    show ? /* @__PURE__ */ jsx(\"div\", { children: /* @__PURE__ */ jsx(\n      \"pre\",\n      {\n        style: {\n          fontSize: \".7em\",\n          border: \"1px solid red\",\n          borderRadius: \".25rem\",\n          padding: \".3rem\",\n          color: \"red\",\n          overflow: \"auto\"\n        },\n        children: error.message ? /* @__PURE__ */ jsx(\"code\", { children: error.message }) : null\n      }\n    ) }) : null\n  ] });\n}\nexport {\n  CatchBoundary,\n  ErrorComponent\n};\n//# sourceMappingURL=CatchBoundary.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport React__default from \"react\";\nfunction ClientOnly({ children, fallback = null }) {\n  return useHydrated() ? /* @__PURE__ */ jsx(React__default.Fragment, { children }) : /* @__PURE__ */ jsx(React__default.Fragment, { children: fallback });\n}\nfunction useHydrated() {\n  return React__default.useSyncExternalStore(\n    subscribe,\n    () => true,\n    () => false\n  );\n}\nfunction subscribe() {\n  return () => {\n  };\n}\nexport {\n  ClientOnly\n};\n//# sourceMappingURL=ClientOnly.js.map\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    function useSyncExternalStore$2(subscribe, getSnapshot) {\n      didWarnOld18Alpha ||\n        void 0 === React.startTransition ||\n        ((didWarnOld18Alpha = !0),\n        console.error(\n          \"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"\n        ));\n      var value = getSnapshot();\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedValue = getSnapshot();\n        objectIs(value, cachedValue) ||\n          (console.error(\n            \"The result of getSnapshot should be cached to avoid an infinite loop\"\n          ),\n          (didWarnUncachedGetSnapshot = !0));\n      }\n      cachedValue = useState({\n        inst: { value: value, getSnapshot: getSnapshot }\n      });\n      var inst = cachedValue[0].inst,\n        forceUpdate = cachedValue[1];\n      useLayoutEffect(\n        function () {\n          inst.value = value;\n          inst.getSnapshot = getSnapshot;\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n        },\n        [subscribe, value, getSnapshot]\n      );\n      useEffect(\n        function () {\n          checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          return subscribe(function () {\n            checkIfSnapshotChanged(inst) && forceUpdate({ inst: inst });\n          });\n        },\n        [subscribe]\n      );\n      useDebugValue(value);\n      return value;\n    }\n    function checkIfSnapshotChanged(inst) {\n      var latestGetSnapshot = inst.getSnapshot;\n      inst = inst.value;\n      try {\n        var nextValue = latestGetSnapshot();\n        return !objectIs(inst, nextValue);\n      } catch (error) {\n        return !0;\n      }\n    }\n    function useSyncExternalStore$1(subscribe, getSnapshot) {\n      return getSnapshot();\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useState = React.useState,\n      useEffect = React.useEffect,\n      useLayoutEffect = React.useLayoutEffect,\n      useDebugValue = React.useDebugValue,\n      didWarnOld18Alpha = !1,\n      didWarnUncachedGetSnapshot = !1,\n      shim =\n        \"undefined\" === typeof window ||\n        \"undefined\" === typeof window.document ||\n        \"undefined\" === typeof window.document.createElement\n          ? useSyncExternalStore$1\n          : useSyncExternalStore$2;\n    exports.useSyncExternalStore =\n      void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim.development.js');\n}\n","/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\"production\" !== process.env.NODE_ENV &&\n  (function () {\n    function is(x, y) {\n      return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n    }\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React = require(\"react\"),\n      shim = require(\"use-sync-external-store/shim\"),\n      objectIs = \"function\" === typeof Object.is ? Object.is : is,\n      useSyncExternalStore = shim.useSyncExternalStore,\n      useRef = React.useRef,\n      useEffect = React.useEffect,\n      useMemo = React.useMemo,\n      useDebugValue = React.useDebugValue;\n    exports.useSyncExternalStoreWithSelector = function (\n      subscribe,\n      getSnapshot,\n      getServerSnapshot,\n      selector,\n      isEqual\n    ) {\n      var instRef = useRef(null);\n      if (null === instRef.current) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo(\n        function () {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              hasMemo = !0;\n              memoizedSnapshot = nextSnapshot;\n              nextSnapshot = selector(nextSnapshot);\n              if (void 0 !== isEqual && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return (memoizedSelection = currentSelection);\n              }\n              return (memoizedSelection = nextSnapshot);\n            }\n            currentSelection = memoizedSelection;\n            if (objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))\n              return (memoizedSnapshot = nextSnapshot), currentSelection;\n            memoizedSnapshot = nextSnapshot;\n            return (memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1,\n            memoizedSnapshot,\n            memoizedSelection,\n            maybeGetServerSnapshot =\n              void 0 === getServerSnapshot ? null : getServerSnapshot;\n          return [\n            function () {\n              return memoizedSelector(getSnapshot());\n            },\n            null === maybeGetServerSnapshot\n              ? void 0\n              : function () {\n                  return memoizedSelector(maybeGetServerSnapshot());\n                }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);\n      useEffect(\n        function () {\n          inst.hasValue = !0;\n          inst.value = value;\n        },\n        [value]\n      );\n      useDebugValue(value);\n      return value;\n    };\n    \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n      \"function\" ===\n        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  })();\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.production.js');\n} else {\n  module.exports = require('../cjs/use-sync-external-store-shim/with-selector.development.js');\n}\n","import { useSyncExternalStoreWithSelector } from \"use-sync-external-store/shim/with-selector.js\";\nexport * from \"@tanstack/store\";\nfunction useStore(store, selector = (d) => d) {\n  const slice = useSyncExternalStoreWithSelector(\n    store.subscribe,\n    () => store.state,\n    () => store.state,\n    selector,\n    shallow\n  );\n  return slice;\n}\nfunction shallow(objA, objB) {\n  if (Object.is(objA, objB)) {\n    return true;\n  }\n  if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n    return false;\n  }\n  if (objA instanceof Map && objB instanceof Map) {\n    if (objA.size !== objB.size) return false;\n    for (const [k, v] of objA) {\n      if (!objB.has(k) || !Object.is(v, objB.get(k))) return false;\n    }\n    return true;\n  }\n  if (objA instanceof Set && objB instanceof Set) {\n    if (objA.size !== objB.size) return false;\n    for (const v of objA) {\n      if (!objB.has(v)) return false;\n    }\n    return true;\n  }\n  if (objA instanceof Date && objB instanceof Date) {\n    if (objA.getTime() !== objB.getTime()) return false;\n    return true;\n  }\n  const keysA = getOwnKeys(objA);\n  if (keysA.length !== getOwnKeys(objB).length) {\n    return false;\n  }\n  for (let i = 0; i < keysA.length; i++) {\n    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getOwnKeys(obj) {\n  return Object.keys(obj).concat(\n    Object.getOwnPropertySymbols(obj)\n  );\n}\nexport {\n  shallow,\n  useStore\n};\n//# sourceMappingURL=index.js.map\n","import * as React from \"react\";\nconst routerContext = React.createContext(null);\nfunction getRouterContext() {\n  if (typeof document === \"undefined\") {\n    return routerContext;\n  }\n  if (window.__TSR_ROUTER_CONTEXT__) {\n    return window.__TSR_ROUTER_CONTEXT__;\n  }\n  window.__TSR_ROUTER_CONTEXT__ = routerContext;\n  return routerContext;\n}\nexport {\n  getRouterContext\n};\n//# sourceMappingURL=routerContext.js.map\n","import * as React from \"react\";\nimport warning from \"tiny-warning\";\nimport { getRouterContext } from \"./routerContext.js\";\nfunction useRouter(opts) {\n  const value = React.useContext(getRouterContext());\n  warning(\n    !((opts?.warn ?? true) && !value),\n    \"useRouter must be used inside a <RouterProvider> component!\"\n  );\n  return value;\n}\nexport {\n  useRouter\n};\n//# sourceMappingURL=useRouter.js.map\n","import { useStore } from \"@tanstack/react-store\";\nimport { useRef } from \"react\";\nimport { replaceEqualDeep } from \"@tanstack/router-core\";\nimport { useRouter } from \"./useRouter.js\";\nfunction useRouterState(opts) {\n  const contextRouter = useRouter({\n    warn: opts?.router === void 0\n  });\n  const router = opts?.router || contextRouter;\n  const previousResult = useRef(void 0);\n  return useStore(router.__store, (state) => {\n    if (opts?.select) {\n      if (opts.structuralSharing ?? router.options.defaultStructuralSharing) {\n        const newSlice = replaceEqualDeep(\n          previousResult.current,\n          opts.select(state)\n        );\n        previousResult.current = newSlice;\n        return newSlice;\n      }\n      return opts.select(state);\n    }\n    return state;\n  });\n}\nexport {\n  useRouterState\n};\n//# sourceMappingURL=useRouterState.js.map\n","import * as React from \"react\";\nconst matchContext = React.createContext(void 0);\nconst dummyMatchContext = React.createContext(\n  void 0\n);\nexport {\n  dummyMatchContext,\n  matchContext\n};\n//# sourceMappingURL=matchContext.js.map\n","import * as React from \"react\";\nimport invariant from \"tiny-invariant\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { dummyMatchContext, matchContext } from \"./matchContext.js\";\nfunction useMatch(opts) {\n  const nearestMatchId = React.useContext(\n    opts.from ? dummyMatchContext : matchContext\n  );\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = state.matches.find(\n        (d) => opts.from ? opts.from === d.routeId : d.id === nearestMatchId\n      );\n      invariant(\n        !((opts.shouldThrow ?? true) && !match),\n        `Could not find ${opts.from ? `an active match from \"${opts.from}\"` : \"a nearest match!\"}`\n      );\n      if (match === void 0) {\n        return void 0;\n      }\n      return opts.select ? opts.select(match) : match;\n    },\n    structuralSharing: opts.structuralSharing\n  });\n  return matchSelection;\n}\nexport {\n  useMatch\n};\n//# sourceMappingURL=useMatch.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useLoaderData(opts) {\n  return useMatch({\n    from: opts.from,\n    strict: opts.strict,\n    structuralSharing: opts.structuralSharing,\n    select: (s) => {\n      return opts.select ? opts.select(s.loaderData) : s.loaderData;\n    }\n  });\n}\nexport {\n  useLoaderData\n};\n//# sourceMappingURL=useLoaderData.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useLoaderDeps(opts) {\n  const { select, ...rest } = opts;\n  return useMatch({\n    ...rest,\n    select: (s) => {\n      return select ? select(s.loaderDeps) : s.loaderDeps;\n    }\n  });\n}\nexport {\n  useLoaderDeps\n};\n//# sourceMappingURL=useLoaderDeps.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useParams(opts) {\n  return useMatch({\n    from: opts.from,\n    shouldThrow: opts.shouldThrow,\n    structuralSharing: opts.structuralSharing,\n    strict: opts.strict,\n    select: (match) => {\n      const params = opts.strict === false ? match.params : match._strictParams;\n      return opts.select ? opts.select(params) : params;\n    }\n  });\n}\nexport {\n  useParams\n};\n//# sourceMappingURL=useParams.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useSearch(opts) {\n  return useMatch({\n    from: opts.from,\n    strict: opts.strict,\n    shouldThrow: opts.shouldThrow,\n    structuralSharing: opts.structuralSharing,\n    select: (match) => {\n      return opts.select ? opts.select(match.search) : match.search;\n    }\n  });\n}\nexport {\n  useSearch\n};\n//# sourceMappingURL=useSearch.js.map\n","import * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nfunction useNavigate(_defaultOpts) {\n  const router = useRouter();\n  return React.useCallback(\n    (options) => {\n      return router.navigate({\n        ...options,\n        from: options.from ?? _defaultOpts?.from\n      });\n    },\n    [_defaultOpts?.from, router]\n  );\n}\nfunction Navigate(props) {\n  const router = useRouter();\n  const navigate = useNavigate();\n  const previousPropsRef = React.useRef(null);\n  React.useEffect(() => {\n    if (previousPropsRef.current !== props) {\n      navigate(props);\n      previousPropsRef.current = props;\n    }\n  }, [router, props, navigate]);\n  return null;\n}\nexport {\n  Navigate,\n  useNavigate\n};\n//# sourceMappingURL=useNavigate.js.map\n","import * as React from \"react\";\nfunction useStableCallback(fn) {\n  const fnRef = React.useRef(fn);\n  fnRef.current = fn;\n  const ref = React.useRef((...args) => fnRef.current(...args));\n  return ref.current;\n}\nconst useLayoutEffect = typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction usePrevious(value) {\n  const ref = React.useRef({\n    value,\n    prev: null\n  });\n  const current = ref.current.value;\n  if (value !== current) {\n    ref.current = {\n      value,\n      prev: current\n    };\n  }\n  return ref.current.prev;\n}\nfunction useIntersectionObserver(ref, callback, intersectionObserverOptions = {}, options = {}) {\n  React.useEffect(() => {\n    if (!ref.current || options.disabled || typeof IntersectionObserver !== \"function\") {\n      return;\n    }\n    const observer = new IntersectionObserver(([entry]) => {\n      callback(entry);\n    }, intersectionObserverOptions);\n    observer.observe(ref.current);\n    return () => {\n      observer.disconnect();\n    };\n  }, [callback, intersectionObserverOptions, options.disabled, ref]);\n}\nfunction useForwardedRef(ref) {\n  const innerRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => innerRef.current, []);\n  return innerRef;\n}\nexport {\n  useForwardedRef,\n  useIntersectionObserver,\n  useLayoutEffect,\n  usePrevious,\n  useStableCallback\n};\n//# sourceMappingURL=utils.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { flushSync } from \"react-dom\";\nimport { preloadWarning, functionalUpdate, exactPathTest, removeTrailingSlash, deepEqual } from \"@tanstack/router-core\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useForwardedRef, useIntersectionObserver } from \"./utils.js\";\nfunction useLinkProps(options, forwardedRef) {\n  const router = useRouter();\n  const [isTransitioning, setIsTransitioning] = React.useState(false);\n  const hasRenderFetched = React.useRef(false);\n  const innerRef = useForwardedRef(forwardedRef);\n  const {\n    // custom props\n    activeProps,\n    inactiveProps,\n    activeOptions,\n    to,\n    preload: userPreload,\n    preloadDelay: userPreloadDelay,\n    hashScrollIntoView,\n    replace,\n    startTransition,\n    resetScroll,\n    viewTransition,\n    // element props\n    children,\n    target,\n    disabled,\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ignoreBlocker,\n    // prevent these from being returned\n    params: _params,\n    search: _search,\n    hash: _hash,\n    state: _state,\n    mask: _mask,\n    reloadDocument: _reloadDocument,\n    unsafeRelative: _unsafeRelative,\n    from: _from,\n    _fromLocation,\n    ...propsSafeToSpread\n  } = options;\n  const currentSearch = useRouterState({\n    select: (s) => s.location.search,\n    structuralSharing: true\n  });\n  const from = options.from;\n  const _options = React.useMemo(\n    () => {\n      return { ...options, from };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      router,\n      currentSearch,\n      from,\n      options._fromLocation,\n      options.hash,\n      options.to,\n      options.search,\n      options.params,\n      options.state,\n      options.mask,\n      options.unsafeRelative\n    ]\n  );\n  const next = React.useMemo(\n    () => router.buildLocation({ ..._options }),\n    [router, _options]\n  );\n  const hrefOption = React.useMemo(() => {\n    if (disabled) {\n      return void 0;\n    }\n    let href = next.maskedLocation ? next.maskedLocation.url : next.url;\n    let external = false;\n    if (router.origin) {\n      if (href.startsWith(router.origin)) {\n        href = router.history.createHref(href.replace(router.origin, \"\")) || \"/\";\n      } else {\n        external = true;\n      }\n    }\n    return { href, external };\n  }, [disabled, next.maskedLocation, next.url, router.origin, router.history]);\n  const externalLink = React.useMemo(() => {\n    if (hrefOption?.external) {\n      return hrefOption.href;\n    }\n    try {\n      new URL(to);\n      return to;\n    } catch {\n    }\n    return void 0;\n  }, [to, hrefOption]);\n  const preload = options.reloadDocument || externalLink ? false : userPreload ?? router.options.defaultPreload;\n  const preloadDelay = userPreloadDelay ?? router.options.defaultPreloadDelay ?? 0;\n  const isActive = useRouterState({\n    select: (s) => {\n      if (externalLink) return false;\n      if (activeOptions?.exact) {\n        const testExact = exactPathTest(\n          s.location.pathname,\n          next.pathname,\n          router.basepath\n        );\n        if (!testExact) {\n          return false;\n        }\n      } else {\n        const currentPathSplit = removeTrailingSlash(\n          s.location.pathname,\n          router.basepath\n        );\n        const nextPathSplit = removeTrailingSlash(\n          next.pathname,\n          router.basepath\n        );\n        const pathIsFuzzyEqual = currentPathSplit.startsWith(nextPathSplit) && (currentPathSplit.length === nextPathSplit.length || currentPathSplit[nextPathSplit.length] === \"/\");\n        if (!pathIsFuzzyEqual) {\n          return false;\n        }\n      }\n      if (activeOptions?.includeSearch ?? true) {\n        const searchTest = deepEqual(s.location.search, next.search, {\n          partial: !activeOptions?.exact,\n          ignoreUndefined: !activeOptions?.explicitUndefined\n        });\n        if (!searchTest) {\n          return false;\n        }\n      }\n      if (activeOptions?.includeHash) {\n        return s.location.hash === next.hash;\n      }\n      return true;\n    }\n  });\n  const doPreload = React.useCallback(() => {\n    router.preloadRoute({ ..._options }).catch((err) => {\n      console.warn(err);\n      console.warn(preloadWarning);\n    });\n  }, [router, _options]);\n  const preloadViewportIoCallback = React.useCallback(\n    (entry) => {\n      if (entry?.isIntersecting) {\n        doPreload();\n      }\n    },\n    [doPreload]\n  );\n  useIntersectionObserver(\n    innerRef,\n    preloadViewportIoCallback,\n    intersectionObserverOptions,\n    { disabled: !!disabled || !(preload === \"viewport\") }\n  );\n  React.useEffect(() => {\n    if (hasRenderFetched.current) {\n      return;\n    }\n    if (!disabled && preload === \"render\") {\n      doPreload();\n      hasRenderFetched.current = true;\n    }\n  }, [disabled, doPreload, preload]);\n  const handleClick = (e) => {\n    const elementTarget = e.currentTarget.target;\n    const effectiveTarget = target !== void 0 ? target : elementTarget;\n    if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!effectiveTarget || effectiveTarget === \"_self\") && e.button === 0) {\n      e.preventDefault();\n      flushSync(() => {\n        setIsTransitioning(true);\n      });\n      const unsub = router.subscribe(\"onResolved\", () => {\n        unsub();\n        setIsTransitioning(false);\n      });\n      router.navigate({\n        ..._options,\n        replace,\n        resetScroll,\n        hashScrollIntoView,\n        startTransition,\n        viewTransition,\n        ignoreBlocker\n      });\n    }\n  };\n  if (externalLink) {\n    return {\n      ...propsSafeToSpread,\n      ref: innerRef,\n      href: externalLink,\n      ...children && { children },\n      ...target && { target },\n      ...disabled && { disabled },\n      ...style && { style },\n      ...className && { className },\n      ...onClick && { onClick },\n      ...onFocus && { onFocus },\n      ...onMouseEnter && { onMouseEnter },\n      ...onMouseLeave && { onMouseLeave },\n      ...onTouchStart && { onTouchStart }\n    };\n  }\n  const handleFocus = (_) => {\n    if (disabled) return;\n    if (preload) {\n      doPreload();\n    }\n  };\n  const handleTouchStart = handleFocus;\n  const handleEnter = (e) => {\n    if (disabled || !preload) return;\n    if (!preloadDelay) {\n      doPreload();\n    } else {\n      const eventTarget = e.target;\n      if (timeoutMap.has(eventTarget)) {\n        return;\n      }\n      const id = setTimeout(() => {\n        timeoutMap.delete(eventTarget);\n        doPreload();\n      }, preloadDelay);\n      timeoutMap.set(eventTarget, id);\n    }\n  };\n  const handleLeave = (e) => {\n    if (disabled || !preload || !preloadDelay) return;\n    const eventTarget = e.target;\n    const id = timeoutMap.get(eventTarget);\n    if (id) {\n      clearTimeout(id);\n      timeoutMap.delete(eventTarget);\n    }\n  };\n  const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? STATIC_ACTIVE_OBJECT : STATIC_EMPTY_OBJECT;\n  const resolvedInactiveProps = isActive ? STATIC_EMPTY_OBJECT : functionalUpdate(inactiveProps, {}) ?? STATIC_EMPTY_OBJECT;\n  const resolvedClassName = [\n    className,\n    resolvedActiveProps.className,\n    resolvedInactiveProps.className\n  ].filter(Boolean).join(\" \");\n  const resolvedStyle = (style || resolvedActiveProps.style || resolvedInactiveProps.style) && {\n    ...style,\n    ...resolvedActiveProps.style,\n    ...resolvedInactiveProps.style\n  };\n  return {\n    ...propsSafeToSpread,\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    href: hrefOption?.href,\n    ref: innerRef,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    disabled: !!disabled,\n    target,\n    ...resolvedStyle && { style: resolvedStyle },\n    ...resolvedClassName && { className: resolvedClassName },\n    ...disabled && STATIC_DISABLED_PROPS,\n    ...isActive && STATIC_ACTIVE_PROPS,\n    ...isTransitioning && STATIC_TRANSITIONING_PROPS\n  };\n}\nconst STATIC_EMPTY_OBJECT = {};\nconst STATIC_ACTIVE_OBJECT = { className: \"active\" };\nconst STATIC_DISABLED_PROPS = { role: \"link\", \"aria-disabled\": true };\nconst STATIC_ACTIVE_PROPS = { \"data-status\": \"active\", \"aria-current\": \"page\" };\nconst STATIC_TRANSITIONING_PROPS = { \"data-transitioning\": \"transitioning\" };\nconst timeoutMap = /* @__PURE__ */ new WeakMap();\nconst intersectionObserverOptions = {\n  rootMargin: \"100px\"\n};\nconst composeHandlers = (handlers) => (e) => {\n  for (const handler of handlers) {\n    if (!handler) continue;\n    if (e.defaultPrevented) return;\n    handler(e);\n  }\n};\nfunction createLink(Comp) {\n  return React.forwardRef(function CreatedLink(props, ref) {\n    return /* @__PURE__ */ jsx(Link, { ...props, _asChild: Comp, ref });\n  });\n}\nconst Link = React.forwardRef(\n  (props, ref) => {\n    const { _asChild, ...rest } = props;\n    const {\n      type: _type,\n      ref: innerRef,\n      ...linkProps\n    } = useLinkProps(rest, ref);\n    const children = typeof rest.children === \"function\" ? rest.children({\n      isActive: linkProps[\"data-status\"] === \"active\"\n    }) : rest.children;\n    if (_asChild === void 0) {\n      delete linkProps.disabled;\n    }\n    return React.createElement(\n      _asChild ? _asChild : \"a\",\n      {\n        ...linkProps,\n        ref: innerRef\n      },\n      children\n    );\n  }\n);\nfunction isCtrlEvent(e) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);\n}\nconst linkOptions = (options) => {\n  return options;\n};\nexport {\n  Link,\n  createLink,\n  linkOptions,\n  useLinkProps\n};\n//# sourceMappingURL=link.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { BaseRouteApi, notFound, BaseRoute, BaseRootRoute } from \"@tanstack/router-core\";\nimport React__default from \"react\";\nimport { useLoaderData } from \"./useLoaderData.js\";\nimport { useLoaderDeps } from \"./useLoaderDeps.js\";\nimport { useParams } from \"./useParams.js\";\nimport { useSearch } from \"./useSearch.js\";\nimport { useNavigate } from \"./useNavigate.js\";\nimport { useMatch } from \"./useMatch.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { Link } from \"./link.js\";\nfunction getRouteApi(id) {\n  return new RouteApi({ id });\n}\nclass RouteApi extends BaseRouteApi {\n  /**\n   * @deprecated Use the `getRouteApi` function instead.\n   */\n  constructor({ id }) {\n    super({ id });\n    this.useMatch = (opts) => {\n      return useMatch({\n        select: opts?.select,\n        from: this.id,\n        structuralSharing: opts?.structuralSharing\n      });\n    };\n    this.useRouteContext = (opts) => {\n      return useMatch({\n        from: this.id,\n        select: (d) => opts?.select ? opts.select(d.context) : d.context\n      });\n    };\n    this.useSearch = (opts) => {\n      return useSearch({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useParams = (opts) => {\n      return useParams({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useLoaderDeps = (opts) => {\n      return useLoaderDeps({ ...opts, from: this.id, strict: false });\n    };\n    this.useLoaderData = (opts) => {\n      return useLoaderData({ ...opts, from: this.id, strict: false });\n    };\n    this.useNavigate = () => {\n      const router = useRouter();\n      return useNavigate({ from: router.routesById[this.id].fullPath });\n    };\n    this.notFound = (opts) => {\n      return notFound({ routeId: this.id, ...opts });\n    };\n    this.Link = React__default.forwardRef((props, ref) => {\n      const router = useRouter();\n      const fullPath = router.routesById[this.id].fullPath;\n      return /* @__PURE__ */ jsx(Link, { ref, from: fullPath, ...props });\n    });\n  }\n}\nclass Route extends BaseRoute {\n  /**\n   * @deprecated Use the `createRoute` function instead.\n   */\n  constructor(options) {\n    super(options);\n    this.useMatch = (opts) => {\n      return useMatch({\n        select: opts?.select,\n        from: this.id,\n        structuralSharing: opts?.structuralSharing\n      });\n    };\n    this.useRouteContext = (opts) => {\n      return useMatch({\n        ...opts,\n        from: this.id,\n        select: (d) => opts?.select ? opts.select(d.context) : d.context\n      });\n    };\n    this.useSearch = (opts) => {\n      return useSearch({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useParams = (opts) => {\n      return useParams({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useLoaderDeps = (opts) => {\n      return useLoaderDeps({ ...opts, from: this.id });\n    };\n    this.useLoaderData = (opts) => {\n      return useLoaderData({ ...opts, from: this.id });\n    };\n    this.useNavigate = () => {\n      return useNavigate({ from: this.fullPath });\n    };\n    this.Link = React__default.forwardRef(\n      (props, ref) => {\n        return /* @__PURE__ */ jsx(Link, { ref, from: this.fullPath, ...props });\n      }\n    );\n    this.$$typeof = Symbol.for(\"react.memo\");\n  }\n}\nfunction createRoute(options) {\n  return new Route(\n    // TODO: Help us TypeChris, you're our only hope!\n    options\n  );\n}\nfunction createRootRouteWithContext() {\n  return (options) => {\n    return createRootRoute(options);\n  };\n}\nconst rootRouteWithContext = createRootRouteWithContext;\nclass RootRoute extends BaseRootRoute {\n  /**\n   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.\n   */\n  constructor(options) {\n    super(options);\n    this.useMatch = (opts) => {\n      return useMatch({\n        select: opts?.select,\n        from: this.id,\n        structuralSharing: opts?.structuralSharing\n      });\n    };\n    this.useRouteContext = (opts) => {\n      return useMatch({\n        ...opts,\n        from: this.id,\n        select: (d) => opts?.select ? opts.select(d.context) : d.context\n      });\n    };\n    this.useSearch = (opts) => {\n      return useSearch({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useParams = (opts) => {\n      return useParams({\n        select: opts?.select,\n        structuralSharing: opts?.structuralSharing,\n        from: this.id\n      });\n    };\n    this.useLoaderDeps = (opts) => {\n      return useLoaderDeps({ ...opts, from: this.id });\n    };\n    this.useLoaderData = (opts) => {\n      return useLoaderData({ ...opts, from: this.id });\n    };\n    this.useNavigate = () => {\n      return useNavigate({ from: this.fullPath });\n    };\n    this.Link = React__default.forwardRef(\n      (props, ref) => {\n        return /* @__PURE__ */ jsx(Link, { ref, from: this.fullPath, ...props });\n      }\n    );\n    this.$$typeof = Symbol.for(\"react.memo\");\n  }\n}\nfunction createRootRoute(options) {\n  return new RootRoute(options);\n}\nfunction createRouteMask(opts) {\n  return opts;\n}\nclass NotFoundRoute extends Route {\n  constructor(options) {\n    super({\n      ...options,\n      id: \"404\"\n    });\n  }\n}\nexport {\n  NotFoundRoute,\n  RootRoute,\n  Route,\n  RouteApi,\n  createRootRoute,\n  createRootRouteWithContext,\n  createRoute,\n  createRouteMask,\n  getRouteApi,\n  rootRouteWithContext\n};\n//# sourceMappingURL=route.js.map\n","import warning from \"tiny-warning\";\nimport { createRoute } from \"./route.js\";\nimport { useMatch } from \"./useMatch.js\";\nimport { useLoaderDeps } from \"./useLoaderDeps.js\";\nimport { useLoaderData } from \"./useLoaderData.js\";\nimport { useSearch } from \"./useSearch.js\";\nimport { useParams } from \"./useParams.js\";\nimport { useNavigate } from \"./useNavigate.js\";\nimport { useRouter } from \"./useRouter.js\";\nfunction createFileRoute(path) {\n  if (typeof path === \"object\") {\n    return new FileRoute(path, {\n      silent: true\n    }).createRoute(path);\n  }\n  return new FileRoute(path, {\n    silent: true\n  }).createRoute;\n}\nclass FileRoute {\n  constructor(path, _opts) {\n    this.path = path;\n    this.createRoute = (options) => {\n      warning(\n        this.silent,\n        \"FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead.\"\n      );\n      const route = createRoute(options);\n      route.isRoot = false;\n      return route;\n    };\n    this.silent = _opts?.silent;\n  }\n}\nfunction FileRouteLoader(_path) {\n  warning(\n    false,\n    `FileRouteLoader is deprecated and will be removed in the next major version. Please place the loader function in the the main route file, inside the \\`createFileRoute('/path/to/file')(options)\\` options`\n  );\n  return (loaderFn) => loaderFn;\n}\nclass LazyRoute {\n  constructor(opts) {\n    this.useMatch = (opts2) => {\n      return useMatch({\n        select: opts2?.select,\n        from: this.options.id,\n        structuralSharing: opts2?.structuralSharing\n      });\n    };\n    this.useRouteContext = (opts2) => {\n      return useMatch({\n        from: this.options.id,\n        select: (d) => opts2?.select ? opts2.select(d.context) : d.context\n      });\n    };\n    this.useSearch = (opts2) => {\n      return useSearch({\n        select: opts2?.select,\n        structuralSharing: opts2?.structuralSharing,\n        from: this.options.id\n      });\n    };\n    this.useParams = (opts2) => {\n      return useParams({\n        select: opts2?.select,\n        structuralSharing: opts2?.structuralSharing,\n        from: this.options.id\n      });\n    };\n    this.useLoaderDeps = (opts2) => {\n      return useLoaderDeps({ ...opts2, from: this.options.id });\n    };\n    this.useLoaderData = (opts2) => {\n      return useLoaderData({ ...opts2, from: this.options.id });\n    };\n    this.useNavigate = () => {\n      const router = useRouter();\n      return useNavigate({ from: router.routesById[this.options.id].fullPath });\n    };\n    this.options = opts;\n    this.$$typeof = Symbol.for(\"react.memo\");\n  }\n}\nfunction createLazyRoute(id) {\n  return (opts) => {\n    return new LazyRoute({\n      id,\n      ...opts\n    });\n  };\n}\nfunction createLazyFileRoute(id) {\n  if (typeof id === \"object\") {\n    return new LazyRoute(id);\n  }\n  return (opts) => new LazyRoute({ id, ...opts });\n}\nexport {\n  FileRoute,\n  FileRouteLoader,\n  LazyRoute,\n  createFileRoute,\n  createLazyFileRoute,\n  createLazyRoute\n};\n//# sourceMappingURL=fileRoute.js.map\n","import * as React from \"react\";\nimport { isModuleNotFoundError } from \"@tanstack/router-core\";\nfunction lazyRouteComponent(importer, exportName) {\n  let loadPromise;\n  let comp;\n  let error;\n  let reload;\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer().then((res) => {\n        loadPromise = void 0;\n        comp = res[exportName ?? \"default\"];\n      }).catch((err) => {\n        error = err;\n        if (isModuleNotFoundError(error)) {\n          if (error instanceof Error && typeof window !== \"undefined\" && typeof sessionStorage !== \"undefined\") {\n            const storageKey = `tanstack_router_reload:${error.message}`;\n            if (!sessionStorage.getItem(storageKey)) {\n              sessionStorage.setItem(storageKey, \"1\");\n              reload = true;\n            }\n          }\n        }\n      });\n    }\n    return loadPromise;\n  };\n  const lazyComp = function Lazy(props) {\n    if (reload) {\n      window.location.reload();\n      throw new Promise(() => {\n      });\n    }\n    if (error) {\n      throw error;\n    }\n    if (!comp) {\n      throw load();\n    }\n    return React.createElement(comp, props);\n  };\n  lazyComp.preload = load;\n  return lazyComp;\n}\nexport {\n  lazyRouteComponent\n};\n//# sourceMappingURL=lazyRouteComponent.js.map\n","import * as React from \"react\";\nimport { trimPathRight, getLocationChangeInfo, handleHashScroll } from \"@tanstack/router-core\";\nimport { usePrevious, useLayoutEffect } from \"./utils.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nfunction Transitioner() {\n  const router = useRouter();\n  const mountLoadForRouter = React.useRef({ router, mounted: false });\n  const [isTransitioning, setIsTransitioning] = React.useState(false);\n  const { hasPendingMatches, isLoading } = useRouterState({\n    select: (s) => ({\n      isLoading: s.isLoading,\n      hasPendingMatches: s.matches.some((d) => d.status === \"pending\")\n    }),\n    structuralSharing: true\n  });\n  const previousIsLoading = usePrevious(isLoading);\n  const isAnyPending = isLoading || isTransitioning || hasPendingMatches;\n  const previousIsAnyPending = usePrevious(isAnyPending);\n  const isPagePending = isLoading || hasPendingMatches;\n  const previousIsPagePending = usePrevious(isPagePending);\n  router.startTransition = (fn) => {\n    setIsTransitioning(true);\n    React.startTransition(() => {\n      fn();\n      setIsTransitioning(false);\n    });\n  };\n  React.useEffect(() => {\n    const unsub = router.history.subscribe(router.load);\n    const nextLocation = router.buildLocation({\n      to: router.latestLocation.pathname,\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n      _includeValidateSearch: true\n    });\n    if (trimPathRight(router.latestLocation.href) !== trimPathRight(nextLocation.href)) {\n      router.commitLocation({ ...nextLocation, replace: true });\n    }\n    return () => {\n      unsub();\n    };\n  }, [router, router.history]);\n  useLayoutEffect(() => {\n    if (\n      // if we are hydrating from SSR, loading is triggered in ssr-client\n      typeof window !== \"undefined\" && router.ssr || mountLoadForRouter.current.router === router && mountLoadForRouter.current.mounted\n    ) {\n      return;\n    }\n    mountLoadForRouter.current = { router, mounted: true };\n    const tryLoad = async () => {\n      try {\n        await router.load();\n      } catch (err) {\n        console.error(err);\n      }\n    };\n    tryLoad();\n  }, [router]);\n  useLayoutEffect(() => {\n    if (previousIsLoading && !isLoading) {\n      router.emit({\n        type: \"onLoad\",\n        // When the new URL has committed, when the new matches have been loaded into state.matches\n        ...getLocationChangeInfo(router.state)\n      });\n    }\n  }, [previousIsLoading, router, isLoading]);\n  useLayoutEffect(() => {\n    if (previousIsPagePending && !isPagePending) {\n      router.emit({\n        type: \"onBeforeRouteMount\",\n        ...getLocationChangeInfo(router.state)\n      });\n    }\n  }, [isPagePending, previousIsPagePending, router]);\n  useLayoutEffect(() => {\n    if (previousIsAnyPending && !isAnyPending) {\n      router.emit({\n        type: \"onResolved\",\n        ...getLocationChangeInfo(router.state)\n      });\n      router.__store.setState((s) => ({\n        ...s,\n        status: \"idle\",\n        resolvedLocation: s.location\n      }));\n      handleHashScroll(router);\n    }\n  }, [isAnyPending, previousIsAnyPending, router]);\n  return null;\n}\nexport {\n  Transitioner\n};\n//# sourceMappingURL=Transitioner.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { isNotFound } from \"@tanstack/router-core\";\nimport { CatchBoundary } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nfunction CatchNotFound(props) {\n  const resetKey = useRouterState({\n    select: (s) => `not-found-${s.location.pathname}-${s.status}`\n  });\n  return /* @__PURE__ */ jsx(\n    CatchBoundary,\n    {\n      getResetKey: () => resetKey,\n      onCatch: (error, errorInfo) => {\n        if (isNotFound(error)) {\n          props.onCatch?.(error, errorInfo);\n        } else {\n          throw error;\n        }\n      },\n      errorComponent: ({ error }) => {\n        if (isNotFound(error)) {\n          return props.fallback?.(error);\n        } else {\n          throw error;\n        }\n      },\n      children: props.children\n    }\n  );\n}\nfunction DefaultGlobalNotFound() {\n  return /* @__PURE__ */ jsx(\"p\", { children: \"Not Found\" });\n}\nexport {\n  CatchNotFound,\n  DefaultGlobalNotFound\n};\n//# sourceMappingURL=not-found.js.map\n","import { jsx, Fragment } from \"react/jsx-runtime\";\nfunction SafeFragment(props) {\n  return /* @__PURE__ */ jsx(Fragment, { children: props.children });\n}\nexport {\n  SafeFragment\n};\n//# sourceMappingURL=SafeFragment.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport warning from \"tiny-warning\";\nimport { DefaultGlobalNotFound } from \"./not-found.js\";\nfunction renderRouteNotFound(router, route, data) {\n  if (!route.options.notFoundComponent) {\n    if (router.options.defaultNotFoundComponent) {\n      return /* @__PURE__ */ jsx(router.options.defaultNotFoundComponent, { data });\n    }\n    if (process.env.NODE_ENV === \"development\") {\n      warning(\n        route.options.notFoundComponent,\n        `A notFoundError was encountered on the route with ID \"${route.id}\", but a notFoundComponent option was not configured, nor was a router level defaultNotFoundComponent configured. Consider configuring at least one of these to avoid TanStack Router's overly generic defaultNotFoundComponent (<div>Not Found<div>)`\n      );\n    }\n    return /* @__PURE__ */ jsx(DefaultGlobalNotFound, {});\n  }\n  return /* @__PURE__ */ jsx(route.options.notFoundComponent, { data });\n}\nexport {\n  renderRouteNotFound\n};\n//# sourceMappingURL=renderRouteNotFound.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { useRouter } from \"./useRouter.js\";\nfunction ScriptOnce({ children }) {\n  const router = useRouter();\n  if (!router.isServer) {\n    return null;\n  }\n  return /* @__PURE__ */ jsx(\n    \"script\",\n    {\n      nonce: router.options.ssr?.nonce,\n      className: \"$tsr\",\n      dangerouslySetInnerHTML: {\n        __html: [children].filter(Boolean).join(\"\\n\") + \";$_TSR.c()\"\n      }\n    }\n  );\n}\nexport {\n  ScriptOnce\n};\n//# sourceMappingURL=ScriptOnce.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { defaultGetScrollRestorationKey, restoreScroll, storageKey } from \"@tanstack/router-core\";\nimport { useRouter } from \"./useRouter.js\";\nimport { ScriptOnce } from \"./ScriptOnce.js\";\nfunction ScrollRestoration() {\n  const router = useRouter();\n  if (!router.isScrollRestoring || !router.isServer) {\n    return null;\n  }\n  if (typeof router.options.scrollRestoration === \"function\") {\n    const shouldRestore = router.options.scrollRestoration({\n      location: router.latestLocation\n    });\n    if (!shouldRestore) {\n      return null;\n    }\n  }\n  const getKey = router.options.getScrollRestorationKey || defaultGetScrollRestorationKey;\n  const userKey = getKey(router.latestLocation);\n  const resolvedKey = userKey !== defaultGetScrollRestorationKey(router.latestLocation) ? userKey : void 0;\n  const restoreScrollOptions = {\n    storageKey,\n    shouldScrollRestoration: true\n  };\n  if (resolvedKey) {\n    restoreScrollOptions.key = resolvedKey;\n  }\n  return /* @__PURE__ */ jsx(\n    ScriptOnce,\n    {\n      children: `(${restoreScroll.toString()})(${JSON.stringify(restoreScrollOptions)})`\n    }\n  );\n}\nexport {\n  ScrollRestoration\n};\n//# sourceMappingURL=scroll-restoration.js.map\n","import { jsxs, jsx, Fragment } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\nimport { isNotFound, rootRouteId, createControlledPromise, isRedirect, getLocationChangeInfo } from \"@tanstack/router-core\";\nimport { CatchBoundary, ErrorComponent } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { CatchNotFound } from \"./not-found.js\";\nimport { matchContext } from \"./matchContext.js\";\nimport { SafeFragment } from \"./SafeFragment.js\";\nimport { renderRouteNotFound } from \"./renderRouteNotFound.js\";\nimport { ScrollRestoration } from \"./scroll-restoration.js\";\nimport { ClientOnly } from \"./ClientOnly.js\";\nconst Match = React.memo(function MatchImpl({\n  matchId\n}) {\n  const router = useRouter();\n  const matchState = useRouterState({\n    select: (s) => {\n      const match = s.matches.find((d) => d.id === matchId);\n      invariant(\n        match,\n        `Could not find match for matchId \"${matchId}\". Please file an issue!`\n      );\n      return {\n        routeId: match.routeId,\n        ssr: match.ssr,\n        _displayPending: match._displayPending\n      };\n    },\n    structuralSharing: true\n  });\n  const route = router.routesById[matchState.routeId];\n  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent;\n  const pendingElement = PendingComponent ? /* @__PURE__ */ jsx(PendingComponent, {}) : null;\n  const routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent;\n  const routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch;\n  const routeNotFoundComponent = route.isRoot ? (\n    // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n    route.options.notFoundComponent ?? router.options.notFoundRoute?.options.component\n  ) : route.options.notFoundComponent;\n  const resolvedNoSsr = matchState.ssr === false || matchState.ssr === \"data-only\";\n  const ResolvedSuspenseBoundary = (\n    // If we're on the root route, allow forcefully wrapping in suspense\n    (!route.isRoot || route.options.wrapInSuspense || resolvedNoSsr) && (route.options.wrapInSuspense ?? PendingComponent ?? (route.options.errorComponent?.preload || resolvedNoSsr)) ? React.Suspense : SafeFragment\n  );\n  const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;\n  const ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment;\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt\n  });\n  const parentRouteId = useRouterState({\n    select: (s) => {\n      const index = s.matches.findIndex((d) => d.id === matchId);\n      return s.matches[index - 1]?.routeId;\n    }\n  });\n  const ShellComponent = route.isRoot ? route.options.shellComponent ?? SafeFragment : SafeFragment;\n  return /* @__PURE__ */ jsxs(ShellComponent, { children: [\n    /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsx(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ jsx(\n      ResolvedCatchBoundary,\n      {\n        getResetKey: () => resetKey,\n        errorComponent: routeErrorComponent || ErrorComponent,\n        onCatch: (error, errorInfo) => {\n          if (isNotFound(error)) throw error;\n          warning(false, `Error in route match: ${matchId}`);\n          routeOnCatch?.(error, errorInfo);\n        },\n        children: /* @__PURE__ */ jsx(\n          ResolvedNotFoundBoundary,\n          {\n            fallback: (error) => {\n              if (!routeNotFoundComponent || error.routeId && error.routeId !== matchState.routeId || !error.routeId && !route.isRoot)\n                throw error;\n              return React.createElement(routeNotFoundComponent, error);\n            },\n            children: resolvedNoSsr || matchState._displayPending ? /* @__PURE__ */ jsx(ClientOnly, { fallback: pendingElement, children: /* @__PURE__ */ jsx(MatchInner, { matchId }) }) : /* @__PURE__ */ jsx(MatchInner, { matchId })\n          }\n        )\n      }\n    ) }) }),\n    parentRouteId === rootRouteId && router.options.scrollRestoration ? /* @__PURE__ */ jsxs(Fragment, { children: [\n      /* @__PURE__ */ jsx(OnRendered, {}),\n      /* @__PURE__ */ jsx(ScrollRestoration, {})\n    ] }) : null\n  ] });\n});\nfunction OnRendered() {\n  const router = useRouter();\n  const prevLocationRef = React.useRef(\n    void 0\n  );\n  return /* @__PURE__ */ jsx(\n    \"script\",\n    {\n      suppressHydrationWarning: true,\n      ref: (el) => {\n        if (el && (prevLocationRef.current === void 0 || prevLocationRef.current.href !== router.latestLocation.href)) {\n          router.emit({\n            type: \"onRendered\",\n            ...getLocationChangeInfo(router.state)\n          });\n          prevLocationRef.current = router.latestLocation;\n        }\n      }\n    },\n    router.latestLocation.state.__TSR_key\n  );\n}\nconst MatchInner = React.memo(function MatchInnerImpl({\n  matchId\n}) {\n  const router = useRouter();\n  const { match, key, routeId } = useRouterState({\n    select: (s) => {\n      const match2 = s.matches.find((d) => d.id === matchId);\n      const routeId2 = match2.routeId;\n      const remountFn = router.routesById[routeId2].options.remountDeps ?? router.options.defaultRemountDeps;\n      const remountDeps = remountFn?.({\n        routeId: routeId2,\n        loaderDeps: match2.loaderDeps,\n        params: match2._strictParams,\n        search: match2._strictSearch\n      });\n      const key2 = remountDeps ? JSON.stringify(remountDeps) : void 0;\n      return {\n        key: key2,\n        routeId: routeId2,\n        match: {\n          id: match2.id,\n          status: match2.status,\n          error: match2.error,\n          _forcePending: match2._forcePending,\n          _displayPending: match2._displayPending\n        }\n      };\n    },\n    structuralSharing: true\n  });\n  const route = router.routesById[routeId];\n  const out = React.useMemo(() => {\n    const Comp = route.options.component ?? router.options.defaultComponent;\n    if (Comp) {\n      return /* @__PURE__ */ jsx(Comp, {}, key);\n    }\n    return /* @__PURE__ */ jsx(Outlet, {});\n  }, [key, route.options.component, router.options.defaultComponent]);\n  if (match._displayPending) {\n    throw router.getMatch(match.id)?._nonReactive.displayPendingPromise;\n  }\n  if (match._forcePending) {\n    throw router.getMatch(match.id)?._nonReactive.minPendingPromise;\n  }\n  if (match.status === \"pending\") {\n    const pendingMinMs = route.options.pendingMinMs ?? router.options.defaultPendingMinMs;\n    if (pendingMinMs) {\n      const routerMatch = router.getMatch(match.id);\n      if (routerMatch && !routerMatch._nonReactive.minPendingPromise) {\n        if (!router.isServer) {\n          const minPendingPromise = createControlledPromise();\n          routerMatch._nonReactive.minPendingPromise = minPendingPromise;\n          setTimeout(() => {\n            minPendingPromise.resolve();\n            routerMatch._nonReactive.minPendingPromise = void 0;\n          }, pendingMinMs);\n        }\n      }\n    }\n    throw router.getMatch(match.id)?._nonReactive.loadPromise;\n  }\n  if (match.status === \"notFound\") {\n    invariant(isNotFound(match.error), \"Expected a notFound error\");\n    return renderRouteNotFound(router, route, match.error);\n  }\n  if (match.status === \"redirected\") {\n    invariant(isRedirect(match.error), \"Expected a redirect error\");\n    throw router.getMatch(match.id)?._nonReactive.loadPromise;\n  }\n  if (match.status === \"error\") {\n    if (router.isServer) {\n      const RouteErrorComponent = (route.options.errorComponent ?? router.options.defaultErrorComponent) || ErrorComponent;\n      return /* @__PURE__ */ jsx(\n        RouteErrorComponent,\n        {\n          error: match.error,\n          reset: void 0,\n          info: {\n            componentStack: \"\"\n          }\n        }\n      );\n    }\n    throw match.error;\n  }\n  return out;\n});\nconst Outlet = React.memo(function OutletImpl() {\n  const router = useRouter();\n  const matchId = React.useContext(matchContext);\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId\n  });\n  const route = router.routesById[routeId];\n  const parentGlobalNotFound = useRouterState({\n    select: (s) => {\n      const matches = s.matches;\n      const parentMatch = matches.find((d) => d.id === matchId);\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId}\"`\n      );\n      return parentMatch.globalNotFound;\n    }\n  });\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = s.matches;\n      const index = matches.findIndex((d) => d.id === matchId);\n      return matches[index + 1]?.id;\n    }\n  });\n  const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */ jsx(router.options.defaultPendingComponent, {}) : null;\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, void 0);\n  }\n  if (!childMatchId) {\n    return null;\n  }\n  const nextMatch = /* @__PURE__ */ jsx(Match, { matchId: childMatchId });\n  if (matchId === rootRouteId) {\n    return /* @__PURE__ */ jsx(React.Suspense, { fallback: pendingElement, children: nextMatch });\n  }\n  return nextMatch;\n});\nexport {\n  Match,\n  MatchInner,\n  Outlet\n};\n//# sourceMappingURL=Match.js.map\n","import { jsxs, jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport warning from \"tiny-warning\";\nimport { rootRouteId } from \"@tanstack/router-core\";\nimport { CatchBoundary, ErrorComponent } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { Transitioner } from \"./Transitioner.js\";\nimport { matchContext } from \"./matchContext.js\";\nimport { Match } from \"./Match.js\";\nimport { SafeFragment } from \"./SafeFragment.js\";\nfunction Matches() {\n  const router = useRouter();\n  const rootRoute = router.routesById[rootRouteId];\n  const PendingComponent = rootRoute.options.pendingComponent ?? router.options.defaultPendingComponent;\n  const pendingElement = PendingComponent ? /* @__PURE__ */ jsx(PendingComponent, {}) : null;\n  const ResolvedSuspense = router.isServer || typeof document !== \"undefined\" && router.ssr ? SafeFragment : React.Suspense;\n  const inner = /* @__PURE__ */ jsxs(ResolvedSuspense, { fallback: pendingElement, children: [\n    !router.isServer && /* @__PURE__ */ jsx(Transitioner, {}),\n    /* @__PURE__ */ jsx(MatchesInner, {})\n  ] });\n  return router.options.InnerWrap ? /* @__PURE__ */ jsx(router.options.InnerWrap, { children: inner }) : inner;\n}\nfunction MatchesInner() {\n  const router = useRouter();\n  const matchId = useRouterState({\n    select: (s) => {\n      return s.matches[0]?.id;\n    }\n  });\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt\n  });\n  const matchComponent = matchId ? /* @__PURE__ */ jsx(Match, { matchId }) : null;\n  return /* @__PURE__ */ jsx(matchContext.Provider, { value: matchId, children: router.options.disableGlobalCatchBoundary ? matchComponent : /* @__PURE__ */ jsx(\n    CatchBoundary,\n    {\n      getResetKey: () => resetKey,\n      errorComponent: ErrorComponent,\n      onCatch: (error) => {\n        warning(\n          false,\n          `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`\n        );\n        warning(false, error.message || error.toString());\n      },\n      children: matchComponent\n    }\n  ) });\n}\nfunction useMatchRoute() {\n  const router = useRouter();\n  useRouterState({\n    select: (s) => [s.location.href, s.resolvedLocation?.href, s.status],\n    structuralSharing: true\n  });\n  return React.useCallback(\n    (opts) => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts;\n      return router.matchRoute(rest, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch\n      });\n    },\n    [router]\n  );\n}\nfunction MatchRoute(props) {\n  const matchRoute = useMatchRoute();\n  const params = matchRoute(props);\n  if (typeof props.children === \"function\") {\n    return props.children(params);\n  }\n  return params ? props.children : null;\n}\nfunction useMatches(opts) {\n  return useRouterState({\n    select: (state) => {\n      const matches = state.matches;\n      return opts?.select ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts?.structuralSharing\n  });\n}\nfunction useParentMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId)\n      );\n      return opts?.select ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts?.structuralSharing\n  });\n}\nfunction useChildMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: (matches) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1\n      );\n      return opts?.select ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts?.structuralSharing\n  });\n}\nexport {\n  MatchRoute,\n  Matches,\n  useChildMatches,\n  useMatchRoute,\n  useMatches,\n  useParentMatches\n};\n//# sourceMappingURL=Matches.js.map\n","import { RouterCore } from \"@tanstack/router-core\";\nimport { createFileRoute, createLazyFileRoute } from \"./fileRoute.js\";\nconst createRouter = (options) => {\n  return new Router(options);\n};\nclass Router extends RouterCore {\n  constructor(options) {\n    super(options);\n  }\n}\nif (typeof globalThis !== \"undefined\") {\n  globalThis.createFileRoute = createFileRoute;\n  globalThis.createLazyFileRoute = createLazyFileRoute;\n} else if (typeof window !== \"undefined\") {\n  window.createFileRoute = createFileRoute;\n  window.createLazyFileRoute = createLazyFileRoute;\n}\nexport {\n  Router,\n  createRouter\n};\n//# sourceMappingURL=router.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport { Matches } from \"./Matches.js\";\nimport { getRouterContext } from \"./routerContext.js\";\nfunction RouterContextProvider({\n  router,\n  children,\n  ...rest\n}) {\n  if (Object.keys(rest).length > 0) {\n    router.update({\n      ...router.options,\n      ...rest,\n      context: {\n        ...router.options.context,\n        ...rest.context\n      }\n    });\n  }\n  const routerContext = getRouterContext();\n  const provider = /* @__PURE__ */ jsx(routerContext.Provider, { value: router, children });\n  if (router.options.Wrap) {\n    return /* @__PURE__ */ jsx(router.options.Wrap, { children: provider });\n  }\n  return provider;\n}\nfunction RouterProvider({ router, ...rest }) {\n  return /* @__PURE__ */ jsx(RouterContextProvider, { router, ...rest, children: /* @__PURE__ */ jsx(Matches, {}) });\n}\nexport {\n  RouterContextProvider,\n  RouterProvider\n};\n//# sourceMappingURL=RouterProvider.js.map\n","import { defaultGetScrollRestorationKey, getCssSelector, scrollRestorationCache, setupScrollRestoration } from \"@tanstack/router-core\";\nimport { useRouter } from \"./useRouter.js\";\nfunction useScrollRestoration() {\n  const router = useRouter();\n  setupScrollRestoration(router, true);\n}\nfunction ScrollRestoration(_props) {\n  useScrollRestoration();\n  if (process.env.NODE_ENV === \"development\") {\n    console.warn(\n      \"The ScrollRestoration component is deprecated. Use createRouter's `scrollRestoration` option instead.\"\n    );\n  }\n  return null;\n}\nfunction useElementScrollRestoration(options) {\n  useScrollRestoration();\n  const router = useRouter();\n  const getKey = options.getKey || defaultGetScrollRestorationKey;\n  let elementSelector = \"\";\n  if (options.id) {\n    elementSelector = `[data-scroll-restoration-id=\"${options.id}\"]`;\n  } else {\n    const element = options.getElement?.();\n    if (!element) {\n      return;\n    }\n    elementSelector = element instanceof Window ? \"window\" : getCssSelector(element);\n  }\n  const restoreKey = getKey(router.latestLocation);\n  const byKey = scrollRestorationCache?.state[restoreKey];\n  return byKey?.[elementSelector];\n}\nexport {\n  ScrollRestoration,\n  useElementScrollRestoration\n};\n//# sourceMappingURL=ScrollRestoration.js.map\n","import * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nfunction _resolveBlockerOpts(opts, condition) {\n  if (opts === void 0) {\n    return {\n      shouldBlockFn: () => true,\n      withResolver: false\n    };\n  }\n  if (\"shouldBlockFn\" in opts) {\n    return opts;\n  }\n  if (typeof opts === \"function\") {\n    const shouldBlock2 = Boolean(condition ?? true);\n    const _customBlockerFn2 = async () => {\n      if (shouldBlock2) return await opts();\n      return false;\n    };\n    return {\n      shouldBlockFn: _customBlockerFn2,\n      enableBeforeUnload: shouldBlock2,\n      withResolver: false\n    };\n  }\n  const shouldBlock = Boolean(opts.condition ?? true);\n  const fn = opts.blockerFn;\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== void 0) {\n      return await fn();\n    }\n    return shouldBlock;\n  };\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === void 0\n  };\n}\nfunction useBlocker(opts, condition) {\n  const {\n    shouldBlockFn,\n    enableBeforeUnload = true,\n    disabled = false,\n    withResolver = false\n  } = _resolveBlockerOpts(opts, condition);\n  const router = useRouter();\n  const { history } = router;\n  const [resolver, setResolver] = React.useState({\n    status: \"idle\",\n    current: void 0,\n    next: void 0,\n    action: void 0,\n    proceed: void 0,\n    reset: void 0\n  });\n  React.useEffect(() => {\n    const blockerFnComposed = async (blockerFnArgs) => {\n      function getLocation(location) {\n        const parsedLocation = router.parseLocation(location);\n        const matchedRoutes = router.getMatchedRoutes(\n          parsedLocation.pathname,\n          void 0\n        );\n        if (matchedRoutes.foundRoute === void 0) {\n          throw new Error(`No route found for location ${location.href}`);\n        }\n        return {\n          routeId: matchedRoutes.foundRoute.id,\n          fullPath: matchedRoutes.foundRoute.fullPath,\n          pathname: parsedLocation.pathname,\n          params: matchedRoutes.routeParams,\n          search: parsedLocation.search\n        };\n      }\n      const current = getLocation(blockerFnArgs.currentLocation);\n      const next = getLocation(blockerFnArgs.nextLocation);\n      const shouldBlock = await shouldBlockFn({\n        action: blockerFnArgs.action,\n        current,\n        next\n      });\n      if (!withResolver) {\n        return shouldBlock;\n      }\n      if (!shouldBlock) {\n        return false;\n      }\n      const promise = new Promise((resolve) => {\n        setResolver({\n          status: \"blocked\",\n          current,\n          next,\n          action: blockerFnArgs.action,\n          proceed: () => resolve(false),\n          reset: () => resolve(true)\n        });\n      });\n      const canNavigateAsync = await promise;\n      setResolver({\n        status: \"idle\",\n        current: void 0,\n        next: void 0,\n        action: void 0,\n        proceed: void 0,\n        reset: void 0\n      });\n      return canNavigateAsync;\n    };\n    return disabled ? void 0 : history.block({ blockerFn: blockerFnComposed, enableBeforeUnload });\n  }, [\n    shouldBlockFn,\n    enableBeforeUnload,\n    disabled,\n    withResolver,\n    history,\n    router\n  ]);\n  return resolver;\n}\nconst _resolvePromptBlockerArgs = (props) => {\n  if (\"shouldBlockFn\" in props) {\n    return { ...props };\n  }\n  const shouldBlock = Boolean(props.condition ?? true);\n  const fn = props.blockerFn;\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== void 0) {\n      return await fn();\n    }\n    return shouldBlock;\n  };\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === void 0\n  };\n};\nfunction Block(opts) {\n  const { children, ...rest } = opts;\n  const args = _resolvePromptBlockerArgs(rest);\n  const resolver = useBlocker(args);\n  return children ? typeof children === \"function\" ? children(resolver) : children : null;\n}\nexport {\n  Block,\n  useBlocker\n};\n//# sourceMappingURL=useBlocker.js.map\n","import { useMatch } from \"./useMatch.js\";\nfunction useRouteContext(opts) {\n  return useMatch({\n    ...opts,\n    select: (match) => opts.select ? opts.select(match.context) : match.context\n  });\n}\nexport {\n  useRouteContext\n};\n//# sourceMappingURL=useRouteContext.js.map\n","import { useRouterState } from \"./useRouterState.js\";\nfunction useLocation(opts) {\n  return useRouterState({\n    select: (state) => opts?.select ? opts.select(state.location) : state.location\n  });\n}\nexport {\n  useLocation\n};\n//# sourceMappingURL=useLocation.js.map\n","import { useRouterState } from \"./useRouterState.js\";\nfunction useCanGoBack() {\n  return useRouterState({ select: (s) => s.location.state.__TSR_index !== 0 });\n}\nexport {\n  useCanGoBack\n};\n//# sourceMappingURL=useCanGoBack.js.map\n","import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nfunction Asset({\n  tag,\n  attrs,\n  children,\n  nonce\n}) {\n  switch (tag) {\n    case \"title\":\n      return /* @__PURE__ */ jsx(\"title\", { ...attrs, suppressHydrationWarning: true, children });\n    case \"meta\":\n      return /* @__PURE__ */ jsx(\"meta\", { ...attrs, suppressHydrationWarning: true });\n    case \"link\":\n      return /* @__PURE__ */ jsx(\"link\", { ...attrs, nonce, suppressHydrationWarning: true });\n    case \"style\":\n      return /* @__PURE__ */ jsx(\n        \"style\",\n        {\n          ...attrs,\n          dangerouslySetInnerHTML: { __html: children },\n          nonce\n        }\n      );\n    case \"script\":\n      return /* @__PURE__ */ jsx(Script, { attrs, children });\n    default:\n      return null;\n  }\n}\nfunction Script({\n  attrs,\n  children\n}) {\n  const router = useRouter();\n  React.useEffect(() => {\n    if (attrs?.src) {\n      const normSrc = (() => {\n        try {\n          const base = document.baseURI || window.location.href;\n          return new URL(attrs.src, base).href;\n        } catch {\n          return attrs.src;\n        }\n      })();\n      const existingScript = Array.from(\n        document.querySelectorAll(\"script[src]\")\n      ).find((el) => el.src === normSrc);\n      if (existingScript) {\n        return;\n      }\n      const script = document.createElement(\"script\");\n      for (const [key, value] of Object.entries(attrs)) {\n        if (key !== \"suppressHydrationWarning\" && value !== void 0 && value !== false) {\n          script.setAttribute(\n            key,\n            typeof value === \"boolean\" ? \"\" : String(value)\n          );\n        }\n      }\n      document.head.appendChild(script);\n      return () => {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n      };\n    }\n    if (typeof children === \"string\") {\n      const typeAttr = typeof attrs?.type === \"string\" ? attrs.type : \"text/javascript\";\n      const nonceAttr = typeof attrs?.nonce === \"string\" ? attrs.nonce : void 0;\n      const existingScript = Array.from(\n        document.querySelectorAll(\"script:not([src])\")\n      ).find((el) => {\n        if (!(el instanceof HTMLScriptElement)) return false;\n        const sType = el.getAttribute(\"type\") ?? \"text/javascript\";\n        const sNonce = el.getAttribute(\"nonce\") ?? void 0;\n        return el.textContent === children && sType === typeAttr && sNonce === nonceAttr;\n      });\n      if (existingScript) {\n        return;\n      }\n      const script = document.createElement(\"script\");\n      script.textContent = children;\n      if (attrs) {\n        for (const [key, value] of Object.entries(attrs)) {\n          if (key !== \"suppressHydrationWarning\" && value !== void 0 && value !== false) {\n            script.setAttribute(\n              key,\n              typeof value === \"boolean\" ? \"\" : String(value)\n            );\n          }\n        }\n      }\n      document.head.appendChild(script);\n      return () => {\n        if (script.parentNode) {\n          script.parentNode.removeChild(script);\n        }\n      };\n    }\n    return void 0;\n  }, [attrs, children]);\n  if (!router.isServer) {\n    return null;\n  }\n  if (attrs?.src && typeof attrs.src === \"string\") {\n    return /* @__PURE__ */ jsx(\"script\", { ...attrs, suppressHydrationWarning: true });\n  }\n  if (typeof children === \"string\") {\n    return /* @__PURE__ */ jsx(\n      \"script\",\n      {\n        ...attrs,\n        dangerouslySetInnerHTML: { __html: children },\n        suppressHydrationWarning: true\n      }\n    );\n  }\n  return null;\n}\nexport {\n  Asset\n};\n//# sourceMappingURL=Asset.js.map\n","import * as React from \"react\";\nimport { createElement } from \"react\";\nimport { Asset } from \"./Asset.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nconst useTags = () => {\n  const router = useRouter();\n  const nonce = router.options.ssr?.nonce;\n  const routeMeta = useRouterState({\n    select: (state) => {\n      return state.matches.map((match) => match.meta).filter(Boolean);\n    }\n  });\n  const meta = React.useMemo(() => {\n    const resultMeta = [];\n    const metaByAttribute = {};\n    let title;\n    for (let i = routeMeta.length - 1; i >= 0; i--) {\n      const metas = routeMeta[i];\n      for (let j = metas.length - 1; j >= 0; j--) {\n        const m = metas[j];\n        if (!m) continue;\n        if (m.title) {\n          if (!title) {\n            title = {\n              tag: \"title\",\n              children: m.title\n            };\n          }\n        } else {\n          const attribute = m.name ?? m.property;\n          if (attribute) {\n            if (metaByAttribute[attribute]) {\n              continue;\n            } else {\n              metaByAttribute[attribute] = true;\n            }\n          }\n          resultMeta.push({\n            tag: \"meta\",\n            attrs: {\n              ...m,\n              nonce\n            }\n          });\n        }\n      }\n    }\n    if (title) {\n      resultMeta.push(title);\n    }\n    if (nonce) {\n      resultMeta.push({\n        tag: \"meta\",\n        attrs: {\n          property: \"csp-nonce\",\n          content: nonce\n        }\n      });\n    }\n    resultMeta.reverse();\n    return resultMeta;\n  }, [routeMeta, nonce]);\n  const links = useRouterState({\n    select: (state) => {\n      const constructed = state.matches.map((match) => match.links).filter(Boolean).flat(1).map((link) => ({\n        tag: \"link\",\n        attrs: {\n          ...link,\n          nonce\n        }\n      }));\n      const manifest = router.ssr?.manifest;\n      const assets = state.matches.map((match) => manifest?.routes[match.routeId]?.assets ?? []).filter(Boolean).flat(1).filter((asset) => asset.tag === \"link\").map(\n        (asset) => ({\n          tag: \"link\",\n          attrs: {\n            ...asset.attrs,\n            suppressHydrationWarning: true,\n            nonce\n          }\n        })\n      );\n      return [...constructed, ...assets];\n    },\n    structuralSharing: true\n  });\n  const preloadMeta = useRouterState({\n    select: (state) => {\n      const preloadMeta2 = [];\n      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(\n        (route) => router.ssr?.manifest?.routes[route.id]?.preloads?.filter(Boolean).forEach((preload) => {\n          preloadMeta2.push({\n            tag: \"link\",\n            attrs: {\n              rel: \"modulepreload\",\n              href: preload,\n              nonce\n            }\n          });\n        })\n      );\n      return preloadMeta2;\n    },\n    structuralSharing: true\n  });\n  const styles = useRouterState({\n    select: (state) => state.matches.map((match) => match.styles).flat(1).filter(Boolean).map(({ children, ...attrs }) => ({\n      tag: \"style\",\n      attrs,\n      children,\n      nonce\n    })),\n    structuralSharing: true\n  });\n  const headScripts = useRouterState({\n    select: (state) => state.matches.map((match) => match.headScripts).flat(1).filter(Boolean).map(({ children, ...script }) => ({\n      tag: \"script\",\n      attrs: {\n        ...script,\n        nonce\n      },\n      children\n    })),\n    structuralSharing: true\n  });\n  return uniqBy(\n    [\n      ...meta,\n      ...preloadMeta,\n      ...links,\n      ...styles,\n      ...headScripts\n    ],\n    (d) => {\n      return JSON.stringify(d);\n    }\n  );\n};\nfunction HeadContent() {\n  const tags = useTags();\n  const router = useRouter();\n  const nonce = router.options.ssr?.nonce;\n  return tags.map((tag) => /* @__PURE__ */ createElement(Asset, { ...tag, key: `tsr-meta-${JSON.stringify(tag)}`, nonce }));\n}\nfunction uniqBy(arr, fn) {\n  const seen = /* @__PURE__ */ new Set();\n  return arr.filter((item) => {\n    const key = fn(item);\n    if (seen.has(key)) {\n      return false;\n    }\n    seen.add(key);\n    return true;\n  });\n}\nexport {\n  HeadContent,\n  useTags\n};\n//# sourceMappingURL=HeadContent.js.map\n","import { jsx, Fragment } from \"react/jsx-runtime\";\nimport { createElement } from \"react\";\nimport { Asset } from \"./Asset.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nconst Scripts = () => {\n  const router = useRouter();\n  const nonce = router.options.ssr?.nonce;\n  const assetScripts = useRouterState({\n    select: (state) => {\n      const assetScripts2 = [];\n      const manifest = router.ssr?.manifest;\n      if (!manifest) {\n        return [];\n      }\n      state.matches.map((match) => router.looseRoutesById[match.routeId]).forEach(\n        (route) => manifest.routes[route.id]?.assets?.filter((d) => d.tag === \"script\").forEach((asset) => {\n          assetScripts2.push({\n            tag: \"script\",\n            attrs: { ...asset.attrs, nonce },\n            children: asset.children\n          });\n        })\n      );\n      return assetScripts2;\n    },\n    structuralSharing: true\n  });\n  const { scripts } = useRouterState({\n    select: (state) => ({\n      scripts: state.matches.map((match) => match.scripts).flat(1).filter(Boolean).map(({ children, ...script }) => ({\n        tag: \"script\",\n        attrs: {\n          ...script,\n          suppressHydrationWarning: true,\n          nonce\n        },\n        children\n      }))\n    }),\n    structuralSharing: true\n  });\n  const allScripts = [...scripts, ...assetScripts];\n  return /* @__PURE__ */ jsx(Fragment, { children: allScripts.map((asset, i) => /* @__PURE__ */ createElement(Asset, { ...asset, key: `tsr-scripts-${asset.tag}-${i}` })) });\n};\nexport {\n  Scripts\n};\n//# sourceMappingURL=Scripts.js.map\n"],"mappings":";;;;;;;AACA,IAAM,mCAAmC,IAAI,SAAS;AACtD,IAAM,mCAAmC,IAAI,SAAS;AACtD,IAAM,gCAAgC,EACpC,SAAS,EAAE,EACZ;AACD,IAAI,eAAe;AACnB,IAAI,eAAe;AACnB,IAAM,mCAAmC,IAAI,KAAK;AAClD,IAAM,uCAAuC,IAAI,KAAK;AACtD,SAAS,kBAAkB,aAAa;CACtC,MAAM,SAAS,MAAM,KAAK,YAAY,CAAC,MAAM,GAAG,MAAM;AACpD,MAAI,aAAa,WAAW,EAAE,QAAQ,KAAK,SAAS,EAAE,CAAE,QAAO;AAC/D,MAAI,aAAa,WAAW,EAAE,QAAQ,KAAK,SAAS,EAAE,CAAE,QAAO;AAC/D,SAAO;GACP;AACF,MAAK,MAAM,WAAW,QAAQ;AAC5B,MAAI,8BAA8B,QAAQ,SAAS,QAAQ,CACzD;AAEF,gCAA8B,QAAQ,KAAK,QAAQ;AACnD,UAAQ,WAAW;EACnB,MAAM,SAAS,iBAAiB,IAAI,QAAQ;AAC5C,MAAI,OACF,MAAK,MAAM,SAAS,QAAQ;GAC1B,MAAM,2BAA2B,iBAAiB,IAAI,MAAM;AAC5D,OAAI,CAAC,yBAA0B;AAC/B,qBAAkB,yBAAyB;;;;AAKnD,SAAS,kBAAkB,OAAO;CAChC,MAAM,QAAQ;EACZ,SAAS,MAAM;EACf,YAAY,MAAM;EACnB;AACD,MAAK,MAAM,YAAY,MAAM,UAC3B,UAAS,MAAM;;AAGnB,SAAS,yBAAyB,SAAS;CACzC,MAAM,QAAQ;EACZ,SAAS,QAAQ;EACjB,YAAY,QAAQ;EACrB;AACD,MAAK,MAAM,YAAY,QAAQ,UAC7B,UAAS,MAAM;;AAGnB,SAAS,QAAQ,OAAO;AACtB,KAAI,eAAe,KAAK,CAAC,qBAAqB,IAAI,MAAM,CACtD,sBAAqB,IAAI,OAAO,MAAM,UAAU;AAElD,kBAAiB,IAAI,MAAM;AAC3B,KAAI,eAAe,EAAG;AACtB,KAAI,aAAc;AAClB,KAAI;AACF,iBAAe;AACf,SAAO,iBAAiB,OAAO,GAAG;GAChC,MAAM,SAAS,MAAM,KAAK,iBAAiB;AAC3C,oBAAiB,OAAO;AACxB,QAAK,MAAM,UAAU,QAAQ;AAE3B,WAAO,YADW,qBAAqB,IAAI,OAAO,IAAI,OAAO;AAE7D,sBAAkB,OAAO;;AAE3B,QAAK,MAAM,UAAU,QAAQ;IAC3B,MAAM,cAAc,iBAAiB,IAAI,OAAO;AAChD,QAAI,CAAC,YAAa;AAClB,kCAA8B,QAAQ,KAAK,OAAO;AAClD,sBAAkB,YAAY;;AAEhC,QAAK,MAAM,UAAU,QAAQ;IAC3B,MAAM,cAAc,iBAAiB,IAAI,OAAO;AAChD,QAAI,CAAC,YAAa;AAClB,SAAK,MAAM,WAAW,YACpB,0BAAyB,QAAQ;;;WAI/B;AACR,iBAAe;AACf,gCAA8B,UAAU,EAAE;AAC1C,uBAAqB,OAAO;;;AAGhC,SAAS,MAAM,IAAI;AACjB;AACA,KAAI;AACF,MAAI;WACI;AACR;AACA,MAAI,iBAAiB,GAAG;GACtB,MAAM,uBAAuB,iBAAiB,QAAQ,CAAC,MAAM,CAAC;AAC9D,OAAI,qBACF,SAAQ,qBAAqB;;;;;;;AChGrC,SAAS,kBAAkB,SAAS;AAClC,QAAO,OAAO,YAAY;;;;;ACC5B,IAAM,QAAN,MAAY;CACV,YAAY,cAAc,SAAS;AACjC,OAAK,4BAA4B,IAAI,KAAK;AAC1C,OAAK,aAAa,aAAa;GAC7B,IAAI,IAAI;AACR,QAAK,UAAU,IAAI,SAAS;GAC5B,MAAM,SAAS,MAAM,KAAK,KAAK,YAAY,OAAO,KAAK,IAAI,GAAG,gBAAgB,OAAO,KAAK,IAAI,GAAG,KAAK,IAAI,UAAU,KAAK;AACzH,gBAAa;AACX,SAAK,UAAU,OAAO,SAAS;AAC/B,aAAgC;;;AAGpC,OAAK,YAAY;AACjB,OAAK,QAAQ;AACb,OAAK,UAAU;;CAEjB,SAAS,SAAS;EAChB,IAAI,IAAI,IAAI;AACZ,OAAK,YAAY,KAAK;AACtB,OAAK,KAAK,KAAK,YAAY,OAAO,KAAK,IAAI,GAAG,SAC5C,MAAK,QAAQ,KAAK,QAAQ,SAAS,KAAK,UAAU,CAAC,QAAQ;WAEvD,kBAAkB,QAAQ,CAC5B,MAAK,QAAQ,QAAQ,KAAK,UAAU;MAEpC,MAAK,QAAQ;AAGjB,GAAC,MAAM,KAAK,KAAK,YAAY,OAAO,KAAK,IAAI,GAAG,aAAa,QAAgB,GAAG,KAAK,GAAG;AACxF,UAAQ,KAAK;;;;;;AC7BjB,IAAM,UAAN,MAAM,QAAQ;CACZ,YAAY,SAAS;AACnB,OAAK,4BAA4B,IAAI,KAAK;AAC1C,OAAK,iBAAiB,EAAE;AACxB,OAAK,oBAAoB,EAAE;AAC3B,OAAK,mBAAmB;GACtB,MAAM,IAAI,KAAK,QAAQ,KAAK;GAC5B,MAAM,cAAc,IAAI,MAAM,EAAE;GAChC,MAAM,cAAc,IAAI,MAAM,EAAE;AAChC,QAAK,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;IAC1B,MAAM,MAAM,KAAK,QAAQ,KAAK;AAC9B,gBAAY,KAAK,IAAI;AACrB,gBAAY,KAAK,IAAI;;AAEvB,QAAK,oBAAoB;AACzB,UAAO;IACL;IACA;IACA,SAAS,KAAK,aAAa,KAAK;IACjC;;AAEH,OAAK,kBAAkB;GACrB,IAAI,IAAI;AACR,QAAK,YAAY,KAAK;GACtB,MAAM,UAAU,KAAK,YAAY;AACjC,QAAK,QAAQ,KAAK,QAAQ,GAAG,QAAQ;AACrC,IAAC,MAAM,KAAK,KAAK,SAAS,aAAa,QAAgB,GAAG,KAAK,GAAG;;AAEpE,OAAK,yCAAyC;AAC5C,QAAK,MAAM,OAAO,KAAK,QAAQ,KAC7B,KAAI,eAAe,QACjB,KAAI,kCAAkC;GAG1C,IAAI,kBAAkB;GACtB,MAAM,oBAAoB,KAAK;GAC/B,MAAM,EAAE,gBAAgB,KAAK,YAAY;AACzC,QAAK,IAAI,IAAI,GAAG,IAAI,YAAY,QAAQ,IACtC,KAAI,YAAY,OAAO,kBAAkB,IAAI;AAC3C,sBAAkB;AAClB;;AAGJ,OAAI,gBACF,MAAK,WAAW;;AAGpB,OAAK,cAAc;AACjB,QAAK,iBAAiB;AACtB,QAAK,kCAAkC;AACvC,gBAAa;AACX,SAAK,qBAAqB;AAC1B,SAAK,MAAM,WAAW,KAAK,eACzB,UAAS;;;AAIf,OAAK,aAAa,aAAa;GAC7B,IAAI,IAAI;AACR,QAAK,UAAU,IAAI,SAAS;GAC5B,MAAM,SAAS,MAAM,KAAK,KAAK,SAAS,gBAAgB,OAAO,KAAK,IAAI,GAAG,KAAK,IAAI,UAAU,KAAK;AACnG,gBAAa;AACX,SAAK,UAAU,OAAO,SAAS;AAC/B,aAAgC;;;AAGpC,OAAK,UAAU;AACf,OAAK,QAAQ,QAAQ,GAAG;GACtB,aAAa,KAAK;GAClB,SAAS,KAAK;GACd,aAAa,KAAK,YAAY,CAAC;GAChC,CAAC;;CAEJ,gBAAgB,OAAO,KAAK,QAAQ,MAAM;AACxC,OAAK,MAAM,OAAO,KAChB,KAAI,eAAe,SAAS;AAC1B,OAAI,iBAAiB;AACrB,QAAK,gBAAgB,IAAI,QAAQ,KAAK;aAC7B,eAAe,OAAO;GAC/B,IAAI,2BAA2B,iBAAiB,IAAI,IAAI;AACxD,OAAI,CAAC,0BAA0B;AAC7B,+CAA2C,IAAI,KAAK;AACpD,qBAAiB,IAAI,KAAK,yBAAyB;;AAErD,4BAAyB,IAAI,KAAK;GAClC,IAAI,gBAAgB,iBAAiB,IAAI,KAAK;AAC9C,OAAI,CAAC,eAAe;AAClB,oCAAgC,IAAI,KAAK;AACzC,qBAAiB,IAAI,MAAM,cAAc;;AAE3C,iBAAc,IAAI,IAAI;;;CAI5B,oBAAoB,OAAO,KAAK,QAAQ,MAAM;AAC5C,OAAK,MAAM,OAAO,KAChB,KAAI,eAAe,QACjB,MAAK,oBAAoB,IAAI,QAAQ,KAAK;WACjC,eAAe,OAAO;GAC/B,MAAM,2BAA2B,iBAAiB,IAAI,IAAI;AAC1D,OAAI,yBACF,0BAAyB,OAAO,KAAK;GAEvC,MAAM,gBAAgB,iBAAiB,IAAI,KAAK;AAChD,OAAI,cACF,eAAc,OAAO,IAAI;;;;;;;AC3GnC,IAAM,gBAAgB;AACtB,IAAM,gBAAgB;AACtB,IAAM,oBAAoB;AAC1B,SAAS,cAAc,MAAM;CAC3B,IAAI,WAAW,KAAK,aAAa;CACjC,MAAM,8BAA8B,IAAI,KAAK;CAC7C,MAAM,UAAU,WAAW;AACzB,aAAW,KAAK,aAAa;AAC7B,cAAY,SAAS,eAAe,WAAW;GAAE;GAAU;GAAQ,CAAC,CAAC;;CAEvE,MAAM,qBAAqB,WAAW;AACpC,MAAI,KAAK,uBAAuB,KAAM,QAAO,OAAO;MAC/C,YAAW,KAAK,aAAa;;CAEpC,MAAM,gBAAgB,OAAO,EAC3B,MACA,aACA,GAAG,iBACC;AAEJ,MADsB,cAAc,iBAAiB,OAClC;AACjB,SAAM;AACN;;EAEF,MAAM,WAAW,KAAK,eAAe,IAAI,EAAE;EAC3C,MAAM,kBAAkB,WAAW,SAAS,UAAU,WAAW,SAAS;AAC1E,MAAI,OAAO,aAAa,eAAe,SAAS,UAAU,gBACxD,MAAK,MAAM,WAAW,UAAU;GAC9B,MAAM,eAAe,UAAU,WAAW,MAAM,WAAW,MAAM;AAMjE,OALkB,MAAM,QAAQ,UAAU;IACxC,iBAAiB;IACjB;IACA,QAAQ,WAAW;IACpB,CAAC,EACa;AACb,SAAK,aAAa;AAClB;;;AAIN,QAAM;;AAER,QAAO;EACL,IAAI,WAAW;AACb,UAAO;;EAET,IAAI,SAAS;AACX,UAAO,KAAK,WAAW;;EAEzB;EACA,YAAY,OAAO;AACjB,eAAY,IAAI,GAAG;AACnB,gBAAa;AACX,gBAAY,OAAO,GAAG;;;EAG1B,OAAO,MAAM,OAAO,iBAAiB;GACnC,MAAM,eAAe,SAAS,MAAM;AACpC,WAAQ,kBAAkB,eAAe,GAAG,MAAM;AAClD,iBAAc;IACZ,YAAY;AACV,UAAK,UAAU,MAAM,MAAM;AAC3B,YAAO,EAAE,MAAM,QAAQ,CAAC;;IAE1B;IACA,MAAM;IACN;IACA;IACD,CAAC;;EAEJ,UAAU,MAAM,OAAO,iBAAiB;GACtC,MAAM,eAAe,SAAS,MAAM;AACpC,WAAQ,kBAAkB,cAAc,MAAM;AAC9C,iBAAc;IACZ,YAAY;AACV,UAAK,aAAa,MAAM,MAAM;AAC9B,YAAO,EAAE,MAAM,WAAW,CAAC;;IAE7B;IACA,MAAM;IACN;IACA;IACD,CAAC;;EAEJ,KAAK,OAAO,iBAAiB;AAC3B,iBAAc;IACZ,YAAY;AACV,UAAK,GAAG,MAAM;AACd,uBAAkB;MAAE,MAAM;MAAM;MAAO,CAAC;;IAE1C;IACA,MAAM;IACP,CAAC;;EAEJ,OAAO,iBAAiB;AACtB,iBAAc;IACZ,YAAY;AACV,UAAK,KAAK,cAAc,iBAAiB,MAAM;AAC/C,uBAAkB,EAAE,MAAM,QAAQ,CAAC;;IAErC;IACA,MAAM;IACP,CAAC;;EAEJ,UAAU,iBAAiB;AACzB,iBAAc;IACZ,YAAY;AACV,UAAK,QAAQ,cAAc,iBAAiB,MAAM;AAClD,uBAAkB,EAAE,MAAM,WAAW,CAAC;;IAExC;IACA,MAAM;IACP,CAAC;;EAEJ,iBAAiB,SAAS,MAAM,mBAAmB;EACnD,aAAa,QAAQ,KAAK,WAAW,IAAI;EACzC,QAAQ,YAAY;AAClB,OAAI,CAAC,KAAK,YAAa,cAAa;GAEpC,MAAM,WAAW,KAAK,eAAe,IAAI,EAAE;AAC3C,QAAK,YAAY,CAAC,GAAG,UAAU,QAAQ,CAAC;AACxC,gBAAa;IACX,MAAM,YAAY,KAAK,eAAe,IAAI,EAAE;AAC5C,SAAK,cAAc,UAAU,QAAQ,MAAM,MAAM,QAAQ,CAAC;;;EAG9D,aAAa,KAAK,SAAS;EAC3B,eAAe,KAAK,WAAW;EAC/B;EACD;;AAEH,SAAS,kBAAkB,OAAO,OAAO;AACvC,KAAI,CAAC,MACH,SAAQ,EAAE;CAEZ,MAAM,MAAM,iBAAiB;AAC7B,QAAO;EACL,GAAG;EACH;EAEA,WAAW;GACV,gBAAgB;EAClB;;AAEH,SAAS,qBAAqB,MAAM;CAClC,MAAM,MAAM,MAAM,WAAW,OAAO,aAAa,cAAc,SAAS,KAAK;CAC7E,MAAM,oBAAoB,IAAI,QAAQ;CACtC,MAAM,uBAAuB,IAAI,QAAQ;CACzC,IAAI,WAAW,EAAE;CACjB,MAAM,qBAAqB;CAC3B,MAAM,gBAAgB,gBAAgB,WAAW;CACjD,MAAM,aAAa,MAAM,gBAAgB,SAAS;CAClD,MAAM,gBAAgB,MAAM,wBAAwB,UAClD,GAAG,IAAI,SAAS,WAAW,IAAI,SAAS,SAAS,IAAI,SAAS,QAC9D,IAAI,QAAQ,MACb;AACD,KAAI,CAAC,IAAI,QAAQ,OAAO,aAAa,CAAC,IAAI,QAAQ,OAAO,KAAK;EAC5D,MAAM,WAAW,iBAAiB;AAClC,MAAI,QAAQ,aACV;IACG,gBAAgB;GACjB,KAAK;GAEL,WAAW;GACZ,EACD,GACD;;CAEH,IAAI,kBAAkB,eAAe;CACrC,IAAI;CACJ,IAAI,cAAc;CAClB,IAAI,gBAAgB;CACpB,IAAI,qBAAqB;CACzB,IAAI,yBAAyB;CAC7B,MAAM,oBAAoB;CAC1B,IAAI;CACJ,IAAI;CACJ,MAAM,cAAc;AAClB,MAAI,CAAC,KACH;AAEF,UAAQ,qBAAqB;AAC7B,GAAC,KAAK,SAAS,IAAI,QAAQ,YAAY,IAAI,QAAQ,cACjD,KAAK,OACL,IACA,KAAK,KACN;AACD,UAAQ,qBAAqB;AAC7B,SAAO,KAAK;AACZ,cAAY,KAAK;AACjB,qBAAmB,KAAK;;CAE1B,MAAM,sBAAsB,MAAM,UAAU,UAAU;EACpD,MAAM,OAAO,WAAW,SAAS;AACjC,MAAI,CAAC,UACH,oBAAmB;AAErB,oBAAkB,UAAU,UAAU,MAAM;AAC5C,SAAO;GACL;GACA;GACA,QAAQ,MAAM,UAAU,SAAS;GAClC;AACD,MAAI,CAAC,UACH,aAAY,QAAQ,SAAS,CAAC,WAAW,OAAO,CAAC;;CAGrD,MAAM,aAAa,SAAS;AAC1B,oBAAkB,eAAe;AACjC,UAAQ,OAAO,EAAE,MAAM,CAAC;;CAE1B,MAAM,iBAAiB,YAAY;AACjC,MAAI,eAAe;AACjB,mBAAgB;AAChB;;EAEF,MAAM,eAAe,eAAe;EACpC,MAAM,QAAQ,aAAa,MAAM,iBAAiB,gBAAgB,MAAM;EACxE,MAAM,YAAY,UAAU;EAC5B,MAAM,SAAS,UAAU;EACzB,MAAM,OAAO,CAAC,aAAa,CAAC,UAAU;AACtC,gBAAc;EACd,MAAM,SAAS,OAAO,OAAO,SAAS,SAAS;EAC/C,MAAM,SAAS,OAAO;GACpB,MAAM;GACN,OAAO;GACR,GAAG,EACF,MAAM,SAAS,SAAS,WACzB;AACD,MAAI,mBACF,sBAAqB;OAChB;GACL,MAAM,YAAY,cAAc;AAChC,OAAI,OAAO,aAAa,eAAe,UAAU,QAC/C;SAAK,MAAM,WAAW,UAMpB,KALkB,MAAM,QAAQ,UAAU;KACxC;KACA;KACA;KACD,CAAC,EACa;AACb,qBAAgB;AAChB,SAAI,QAAQ,GAAG,EAAE;AACjB,aAAQ,OAAO,OAAO;AACtB;;;;AAKR,oBAAkB,eAAe;AACjC,UAAQ,OAAO,OAAO;;CAExB,MAAM,kBAAkB,MAAM;AAC5B,MAAI,wBAAwB;AAC1B,4BAAyB;AACzB;;EAEF,IAAI,cAAc;EAClB,MAAM,YAAY,cAAc;AAChC,MAAI,OAAO,aAAa,eAAe,UAAU,OAC/C,MAAK,MAAM,WAAW,WAAW;GAC/B,MAAM,yBAAyB,QAAQ,sBAAsB;AAC7D,OAAI,2BAA2B,MAAM;AACnC,kBAAc;AACd;;AAEF,OAAI,OAAO,2BAA2B,cAAc,wBAAwB,KAAK,MAAM;AACrF,kBAAc;AACd;;;AAIN,MAAI,aAAa;AACf,KAAE,gBAAgB;AAClB,UAAO,EAAE,cAAc;;;CAI3B,MAAM,UAAU,cAAc;EAC5B;EACA,iBAAiB,IAAI,QAAQ;EAC7B,YAAY,MAAM,UAAU,mBAAmB,QAAQ,MAAM,MAAM;EACnE,eAAe,MAAM,UAAU,mBAAmB,WAAW,MAAM,MAAM;EACzE,OAAO,kBAAkB;AACvB,OAAI,cAAe,sBAAqB;AACxC,4BAAyB;AACzB,UAAO,IAAI,QAAQ,MAAM;;EAE3B,UAAU,kBAAkB;AAC1B,OAAI,cAAe,sBAAqB;AACxC,4BAAyB;AACzB,OAAI,QAAQ,SAAS;;EAEvB,KAAK,MAAM;AACT,iBAAc;AACd,OAAI,QAAQ,GAAG,EAAE;;EAEnB,aAAa,SAAS,WAAW,KAAK;EACtC;EACA,eAAe;AACb,OAAI,QAAQ,YAAY;AACxB,OAAI,QAAQ,eAAe;AAC3B,OAAI,oBAAoB,mBAAmB,gBAAgB,EACzD,SAAS,MACV,CAAC;AACF,OAAI,oBAAoB,eAAe,eAAe;;EAExD,iBAAiB;AACf,OAAI,oBAAoB,oBAAoB,iBAC1C,mBAAkB;;EAGtB,aAAa;EACb,aAAa;EACb,qBAAqB;EACtB,CAAC;AACF,KAAI,iBAAiB,mBAAmB,gBAAgB,EAAE,SAAS,MAAM,CAAC;AAC1E,KAAI,iBAAiB,eAAe,eAAe;AACnD,KAAI,QAAQ,YAAY,SAAS,GAAG,MAAM;EACxC,MAAM,MAAM,kBAAkB,MAAM,IAAI,SAAS,KAAK;AACtD,MAAI,CAAC,QAAQ,mBAAoB,WAAU,OAAO;AAClD,SAAO;;AAET,KAAI,QAAQ,eAAe,SAAS,GAAG,MAAM;EAC3C,MAAM,MAAM,qBAAqB,MAAM,IAAI,SAAS,KAAK;AACzD,MAAI,CAAC,QAAQ,mBAAoB,WAAU,UAAU;AACrD,SAAO;;AAET,QAAO;;AAET,SAAS,kBAAkB,MAAM;CAC/B,MAAM,MAAM,MAAM,WAAW,OAAO,aAAa,cAAc,SAAS,KAAK;AAC7E,QAAO,qBAAqB;EAC1B,QAAQ;EACR,qBAAqB;GACnB,MAAM,YAAY,IAAI,SAAS,KAAK,MAAM,IAAI,CAAC,MAAM,EAAE;GACvD,MAAM,WAAW,UAAU,MAAM;GACjC,MAAM,aAAa,IAAI,SAAS;GAChC,MAAM,cAAc,UAAU,MAAM,EAAE;AAGtC,UAAO,UADU,GAAG,WAAW,aADd,YAAY,WAAW,IAAI,KAAK,IAAI,YAAY,KAAK,IAAI,MAE/C,IAAI,QAAQ,MAAM;;EAE/C,aAAa,SAAS,GAAG,IAAI,SAAS,WAAW,IAAI,SAAS,OAAO,GAAG;EACzE,CAAC;;AAEJ,SAAS,oBAAoB,OAAO,EAClC,gBAAgB,CAAC,IAAI,EACtB,EAAE;CACD,MAAM,UAAU,KAAK;CACrB,IAAI,QAAQ,KAAK,eAAe,KAAK,IAAI,KAAK,IAAI,KAAK,cAAc,EAAE,EAAE,QAAQ,SAAS,EAAE,GAAG,QAAQ,SAAS;CAChH,MAAM,SAAS,QAAQ,KACpB,QAAQ,WAAW,kBAAkB,QAAQ,KAAK,EAAE,CACtD;CACD,MAAM,oBAAoB,UAAU,QAAQ,QAAQ,OAAO,OAAO;AAClE,QAAO,cAAc;EACnB;EACA,iBAAiB,QAAQ;EACzB,YAAY,MAAM,UAAU;AAC1B,OAAI,QAAQ,QAAQ,SAAS,GAAG;AAC9B,YAAQ,OAAO,QAAQ,EAAE;AACzB,WAAO,OAAO,QAAQ,EAAE;;AAE1B,UAAO,KAAK,MAAM;AAClB,WAAQ,KAAK,KAAK;AAClB,WAAQ,KAAK,IAAI,QAAQ,SAAS,GAAG,EAAE;;EAEzC,eAAe,MAAM,UAAU;AAC7B,UAAO,SAAS;AAChB,WAAQ,SAAS;;EAEnB,YAAY;AACV,WAAQ,KAAK,IAAI,QAAQ,GAAG,EAAE;;EAEhC,eAAe;AACb,WAAQ,KAAK,IAAI,QAAQ,GAAG,QAAQ,SAAS,EAAE;;EAEjD,KAAK,MAAM;AACT,WAAQ,KAAK,IAAI,KAAK,IAAI,QAAQ,GAAG,EAAE,EAAE,QAAQ,SAAS,EAAE;;EAE9D,aAAa,SAAS;EACvB,CAAC;;AAEJ,SAAS,UAAU,MAAM,OAAO;CAC9B,MAAM,YAAY,KAAK,QAAQ,IAAI;CACnC,MAAM,cAAc,KAAK,QAAQ,IAAI;CACrC,MAAM,WAAW,iBAAiB;AAClC,QAAO;EACL;EACA,UAAU,KAAK,UACb,GACA,YAAY,IAAI,cAAc,IAAI,KAAK,IAAI,WAAW,YAAY,GAAG,YAAY,cAAc,IAAI,cAAc,KAAK,OACvH;EACD,MAAM,YAAY,KAAK,KAAK,UAAU,UAAU,GAAG;EACnD,QAAQ,cAAc,KAAK,KAAK,MAAM,aAAa,cAAc,KAAK,KAAK,IAAI,UAAU,GAAG;EAC5F,OAAO,SAAS;IAAG,gBAAgB;GAAG,KAAK;GAAU,WAAW;GAAU;EAC3E;;AAEH,SAAS,kBAAkB;AACzB,SAAQ,KAAK,QAAQ,GAAG,GAAG,SAAS,GAAG,CAAC,UAAU,EAAE;;;;;AC7YtD,IAAM,cAAc;AACpB,IAAM,uBAAuB;AAC7B,IAAM,4BAA4B;AAClC,IAAM,4BAA4B;AAClC,IAAM,4BAA4B;AAClC,IAAM,mCAAmC;AACzC,IAAM,2BAA2B;AACjC,IAAM,6BAA6B;AACnC,IAAM,6BAA6B;AACnC,IAAM,iCAAiC;AACvC,IAAM,iCAAiC;AACvC,SAAS,YAAY,SAAS,WAAW;AACvC,KAAI,QAAQ,iBAAiB,QAAQ,cACnC,QAAO,YAAY,2BAA2B,iCAAiC,QAAQ,cAAc,SAAS,iCAAiC,QAAQ,cAAc;AAEvK,KAAI,QAAQ,cACV,QAAO,YAAY,6BAA6B,iCAAiC,QAAQ,cAAc;AAEzG,KAAI,QAAQ,cACV,QAAO,YAAY,6BAA6B,iCAAiC,QAAQ,cAAc;AAEzG,QAAO;;AAET,SAAS,WAAW,QAAQ;CAC1B,MAAM,eAAe,EAAE;AACvB,QAAO,SAAS,GAAG,MAAM;AACvB,MAAI,EAAE,UAAU,CAAC,EAAE,KACjB;EAEF,MAAM,UAAU,aAAa,EAAE,SAAS;EACxC,IAAI,SAAS,cAAc,QAAQ;EACnC,IAAI,OAAO;AACX,SAAO,OAAO,SAAS,OAAO,KAAK,OAAO,OAAO,UAAU,IACzD;AAEF,MAAI,OAAO,EAAG,UAAS,OAAO,MAAM,KAAK;EACzC,IAAI,qBAAqB;EACzB,IAAI,iBAAiB;EACrB,MAAM,SAAS,OAAO,KAAK,SAAS,UAAU;AAC5C,OAAI,QAAQ,UAAU,IACpB,QAAO;AAET,OAAI,QAAQ,SAAS,sBACnB,QAAO;GAET,IAAI,YAAY,KAAK;AACrB,OAAI,QAAQ,SAAS,mBACnB,aAAY;YACH,QAAQ,SAAS,6BAA6B;AACvD,gBAAY;AACZ;SAEA,aAAY;AAEd,QAAK,IAAI,KAAK,QAAQ,GAAG,KAAK,OAAO,QAAQ,MAAM;IACjD,MAAM,cAAc,OAAO;AAC3B,QAAI,YAAY,SAAS,yBAAyB,YAAY,UAAU,KAAK;AAC3E,sBAAiB;AACjB,YAAO,YACL,SACA,YAAY,iCACb;;;AAGL,UAAO,YAAY,SAAS,UAAU;IACtC;AACF,eAAa,KAAK;GAChB,OAAO;GACP;GACA;GACA,OAAO;GACP;GACA;GACA;GACD,CAAC;GACF;AA8BF,QA7BmB,aAAa,MAAM,GAAG,MAAM;EAC7C,MAAM,YAAY,KAAK,IAAI,EAAE,OAAO,QAAQ,EAAE,OAAO,OAAO;AAC5D,OAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAC7B,KAAI,EAAE,OAAO,OAAO,EAAE,OAAO,GAC3B,QAAO,EAAE,OAAO,KAAK,EAAE,OAAO;AAGlC,MAAI,EAAE,OAAO,WAAW,EAAE,OAAO,QAAQ;AACvC,OAAI,EAAE,uBAAuB,EAAE,oBAC7B;QAAI,EAAE,mBAAmB,EAAE,eACzB,QAAO,EAAE,qBAAqB,EAAE;aACvB,EAAE,kBAAkB,CAAC,EAAE,eAChC,QAAO;aACE,CAAC,EAAE,kBAAkB,EAAE,eAChC,QAAO;;AAGX,UAAO,EAAE,OAAO,SAAS,EAAE,OAAO;;AAEpC,OAAK,IAAI,IAAI,GAAG,IAAI,WAAW,IAC7B,KAAI,EAAE,OAAO,GAAG,UAAU,EAAE,OAAO,GAAG,MACpC,QAAO,EAAE,OAAO,GAAG,QAAQ,EAAE,OAAO,GAAG,QAAQ,IAAI;AAGvD,SAAO,EAAE,QAAQ,EAAE;GACnB,CAAC,KAAK,GAAG,MAAM;AACf,IAAE,MAAM,OAAO;AACf,SAAO,EAAE;GACT;;AAGJ,SAAS,iBAAiB,EACxB,WACA,aACC;CACD,MAAM,aAAa,EAAE;CACrB,MAAM,eAAe,EAAE;CACvB,MAAM,iBAAiB,gBAAgB;AACrC,cAAY,SAAS,YAAY,MAAM;AACrC,eAAY,YAAY,EAAE;GAC1B,MAAM,gBAAgB,WAAW,WAAW;AAC5C,aACE,CAAC,eACD,mCAAmC,OAAO,WAAW,GAAG,GACzD;AACD,cAAW,WAAW,MAAM;AAC5B,OAAI,CAAC,WAAW,UAAU,WAAW,MAAM;IACzC,MAAM,kBAAkB,cAAc,WAAW,SAAS;AAC1D,QAAI,CAAC,aAAa,oBAAoB,WAAW,SAAS,SAAS,IAAI,CACrE,cAAa,mBAAmB;;GAGpC,MAAM,WAAW,WAAW;AAC5B,OAAI,UAAU,OACZ,eAAc,SAAS;IAEzB;;AAEJ,eAAc,CAAC,UAAU,CAAC;AAE1B,QAAO;EAAE;EAAY;EAAc,YADhB,WAAW,OAAO,OAAO,WAAW,CAAC;EACT;;;;;AC1IjD,SAAS,SAAS,UAAU,EAAE,EAAE;AAC9B,SAAQ,aAAa;AACrB,KAAI,QAAQ,MAAO,OAAM;AACzB,QAAO;;AAET,SAAS,WAAW,KAAK;AACvB,QAAO,CAAC,CAAC,KAAK;;;;;ACLhB,SAAS,wBAAwB;AAC/B,KAAI;AACF,MAAI,OAAO,WAAW,eAAe,OAAO,OAAO,mBAAmB,SACpE,QAAO,OAAO;SAEV;;AAIV,IAAM,aAAa;AACnB,IAAM,YAAY,IAAI,SAAS;CAC7B,IAAI;AACJ,SAAQ,GAAG,SAAS;AAClB,MAAI,CAAC,QACH,WAAU,iBAAiB;AACzB,MAAG,GAAG,KAAK;AACX,aAAU;KACT,KAAK;;;AAId,SAAS,+BAA+B;CACtC,MAAM,qBAAqB,uBAAuB;AAClD,KAAI,CAAC,mBACH,QAAO;CAET,MAAM,iBAAiB,mBAAmB,QAAQ,WAAW;CAC7D,IAAI,QAAQ,iBAAiB,KAAK,MAAM,eAAe,GAAG,EAAE;AAC5D,QAAO;EACL;EAIA,MAAM,aAAa,QAAQ,iBAAiB,SAAS,MAAM,IAAI,OAAO,mBAAmB,QAAQ,YAAY,KAAK,UAAU,MAAM,CAAC;EACpI;;AAEH,IAAM,yBAAyB,8BAA8B;AAC7D,IAAM,kCAAkC,aAAa;AACnD,QAAO,SAAS,MAAM,aAAa,SAAS;;AAE9C,SAAS,eAAe,IAAI;CAC1B,MAAM,OAAO,EAAE;CACf,IAAI;AACJ,QAAO,SAAS,GAAG,YAAY;AAC7B,OAAK,KACH,GAAG,GAAG,QAAQ,aAAa,MAAM,UAAU,QAAQ,KAAK,OAAO,UAAU,GAAG,GAAG,EAAE,GAClF;AACD,OAAK;;AAEP,QAAO,GAAG,KAAK,SAAS,CAAC,KAAK,MAAM,GAAG,aAAa;;AAEtD,IAAI,eAAe;AACnB,SAAS,cAAc,EACrB,YAAY,aACZ,KACA,UACA,yBACA,sBACA,YACC;CACD,IAAI;AACJ,KAAI;AACF,UAAQ,KAAK,MAAM,eAAe,QAAQ,YAAY,IAAI,KAAK;UACxD,OAAO;AACd,UAAQ,MAAM,MAAM;AACpB;;CAEF,MAAM,cAAc,OAAO,OAAO,QAAQ,OAAO;CACjD,MAAM,iBAAiB,MAAM;AAC7B,gBAAe;AACf,SAAQ;AACN,MAAI,2BAA2B,kBAAkB,OAAO,KAAK,eAAe,CAAC,SAAS,GAAG;AACvF,QAAK,MAAM,mBAAmB,gBAAgB;IAC5C,MAAM,QAAQ,eAAe;AAC7B,QAAI,oBAAoB,SACtB,QAAO,SAAS;KACd,KAAK,MAAM;KACX,MAAM,MAAM;KACZ;KACD,CAAC;aACO,iBAAiB;KAC1B,MAAM,UAAU,SAAS,cAAc,gBAAgB;AACvD,SAAI,SAAS;AACX,cAAQ,aAAa,MAAM;AAC3B,cAAQ,YAAY,MAAM;;;;AAIhC,SAAM;;EAER,MAAM,QAAQ,YAAY,OAAO,UAAU,KAAK,MAAM,KAAK,EAAE,CAAC;AAC9D,MAAI,MAAM;GACR,MAAM,4BAA4B,OAAO,QAAQ,OAAO,+BAA+B;AACvF,OAAI,2BAA2B;IAC7B,MAAM,KAAK,SAAS,eAAe,KAAK;AACxC,QAAI,GACF,IAAG,eAAe,0BAA0B;;AAGhD,SAAM;;EAER,MAAM,gBAAgB;GAAE,KAAK;GAAG,MAAM;GAAG;GAAU;AACnD,SAAO,SAAS,cAAc;AAC9B,MAAI,qBACF,MAAK,MAAM,YAAY,sBAAsB;AAC3C,OAAI,aAAa,SAAU;GAC3B,MAAM,UAAU,OAAO,aAAa,aAAa,UAAU,GAAG,SAAS,cAAc,SAAS;AAC9F,OAAI,QAAS,SAAQ,SAAS,cAAc;;;AAIlD,gBAAe;;AAEjB,SAAS,uBAAuB,QAAQ,OAAO;AAC7C,KAAI,CAAC,0BAA0B,CAAC,OAAO,SACrC;AAGF,KADgC,SAAS,OAAO,QAAQ,qBAAqB,MAE3E,QAAO,oBAAoB;AAE7B,KAAI,OAAO,YAAY,OAAO,4BAA4B,CAAC,uBACzD;AAEF,QAAO,2BAA2B;AAClC,gBAAe;CACf,MAAM,SAAS,OAAO,QAAQ,2BAA2B;AACzD,QAAO,QAAQ,oBAAoB;CACnC,MAAM,YAAY,UAAU;AAC1B,MAAI,gBAAgB,CAAC,OAAO,kBAC1B;EAEF,IAAI,kBAAkB;AACtB,MAAI,MAAM,WAAW,YAAY,MAAM,WAAW,OAChD,mBAAkB;OACb;GACL,MAAM,SAAS,MAAM,OAAO,aAC1B,6BACD;AACD,OAAI,OACF,mBAAkB,gCAAgC,OAAO;OAEzD,mBAAkB,eAAe,MAAM,OAAO;;EAGlD,MAAM,aAAa,OAAO,OAAO,MAAM,SAAS;AAChD,yBAAuB,KAAK,UAAU;GACpC,MAAM,WAAW,MAAM,gBAAgB,EAAE;GACzC,MAAM,eAAe,SAAS,qBAAqB,EAAE;AACrD,OAAI,oBAAoB,UAAU;AAChC,iBAAa,UAAU,OAAO,WAAW;AACzC,iBAAa,UAAU,OAAO,WAAW;cAChC,iBAAiB;IAC1B,MAAM,UAAU,SAAS,cAAc,gBAAgB;AACvD,QAAI,SAAS;AACX,kBAAa,UAAU,QAAQ,cAAc;AAC7C,kBAAa,UAAU,QAAQ,aAAa;;;AAGhD,UAAO;IACP;;AAEJ,KAAI,OAAO,aAAa,YACtB,UAAS,iBAAiB,UAAU,SAAS,UAAU,IAAI,EAAE,KAAK;AAEpE,QAAO,UAAU,eAAe,UAAU;EACxC,MAAM,WAAW,OAAO,MAAM,WAAW;AACzC,MAAI,CAAC,OAAO,iBAAiB;AAC3B,UAAO,kBAAkB;AACzB;;AAEF,MAAI,OAAO,OAAO,QAAQ,sBAAsB,YAI9C;OAAI,CAHkB,OAAO,QAAQ,kBAAkB,EACrD,UAAU,OAAO,gBAClB,CAAC,CAEA;;AAGJ,gBAAc;GACZ;GACA,KAAK;GACL,UAAU,OAAO,QAAQ;GACzB,yBAAyB,OAAO;GAChC,sBAAsB,OAAO,QAAQ;GACrC,UAAU,OAAO,QAAQ;GAC1B,CAAC;AACF,MAAI,OAAO,kBACT,wBAAuB,KAAK,UAAU;AACpC,SAAM,cAAc,EAAE;AACtB,UAAO;IACP;GAEJ;;AAEJ,SAAS,iBAAiB,QAAQ;AAChC,KAAI,OAAO,aAAa,eAAe,SAAS,eAAe;EAC7D,MAAM,4BAA4B,OAAO,MAAM,SAAS,MAAM,+BAA+B;AAC7F,MAAI,6BAA6B,OAAO,MAAM,SAAS,SAAS,IAAI;GAClE,MAAM,KAAK,SAAS,eAAe,OAAO,MAAM,SAAS,KAAK;AAC9D,OAAI,GACF,IAAG,eAAe,0BAA0B;;;;;;;AC1MpD,SAAS,OAAO,KAAK,YAAY,QAAQ;CACvC,MAAM,SAAS,IAAI,iBAAiB;AACpC,MAAK,MAAM,OAAO,KAAK;EACrB,MAAM,MAAM,IAAI;AAChB,MAAI,QAAQ,KAAK,EACf,QAAO,IAAI,KAAK,UAAU,IAAI,CAAC;;AAGnC,QAAO,OAAO,UAAU;;AAE1B,SAAS,QAAQ,KAAK;AACpB,KAAI,CAAC,IAAK,QAAO;AACjB,KAAI,QAAQ,QAAS,QAAO;AAC5B,KAAI,QAAQ,OAAQ,QAAO;AAC3B,QAAO,CAAC,MAAM,MAAM,KAAK,CAAC,MAAM,OAAO,MAAM,CAAC,MAAM;;AAEtD,SAAS,OAAO,KAAK;CACnB,MAAM,eAAe,IAAI,gBAAgB,IAAI;CAC7C,MAAM,SAAS,EAAE;AACjB,MAAK,MAAM,CAAC,KAAK,UAAU,aAAa,SAAS,EAAE;EACjD,MAAM,gBAAgB,OAAO;AAC7B,MAAI,iBAAiB,KACnB,QAAO,OAAO,QAAQ,MAAM;WACnB,MAAM,QAAQ,cAAc,CACrC,eAAc,KAAK,QAAQ,MAAM,CAAC;MAElC,QAAO,OAAO,CAAC,eAAe,QAAQ,MAAM,CAAC;;AAGjD,QAAO;;;;;AC5BT,IAAM,qBAAqB,gBAAgB,KAAK,MAAM;AACtD,IAAM,yBAAyB,oBAC7B,KAAK,WACL,KAAK,MACN;AACD,SAAS,gBAAgB,QAAQ;AAC/B,SAAQ,cAAc;AACpB,MAAI,UAAU,OAAO,IACnB,aAAY,UAAU,UAAU,EAAE;EAEpC,MAAM,QAAQ,OAAO,UAAU;AAC/B,OAAK,MAAM,OAAO,OAAO;GACvB,MAAM,QAAQ,MAAM;AACpB,OAAI,OAAO,UAAU,SACnB,KAAI;AACF,UAAM,OAAO,OAAO,MAAM;YACnB,MAAM;;AAInB,SAAO;;;AAGX,SAAS,oBAAoB,WAAW,QAAQ;CAC9C,MAAM,YAAY,OAAO,WAAW;CACpC,SAAS,eAAe,KAAK;AAC3B,MAAI,OAAO,QAAQ,YAAY,QAAQ,KACrC,KAAI;AACF,UAAO,UAAU,IAAI;WACd,MAAM;WAEN,aAAa,OAAO,QAAQ,SACrC,KAAI;AACF,UAAO,IAAI;AACX,UAAO,UAAU,IAAI;WACd,MAAM;AAGjB,SAAO;;AAET,SAAQ,WAAW;EACjB,MAAM,YAAY,OAAO,QAAQ,eAAe;AAChD,SAAO,YAAY,IAAI,cAAc;;;;;;AC3CzC,SAAS,SAAS,MAAM;AACtB,MAAK,aAAa,KAAK,cAAc,KAAK,QAAQ;AAClD,KAAI,CAAC,KAAK,kBAAkB,OAAO,KAAK,SAAS,SAC/C,KAAI;AACF,MAAI,IAAI,KAAK,KAAK;AAClB,OAAK,iBAAiB;SAChB;CAGV,MAAM,UAAU,IAAI,QAAQ,KAAK,QAAQ;AACzC,KAAI,KAAK,QAAQ,QAAQ,IAAI,WAAW,KAAK,KAC3C,SAAQ,IAAI,YAAY,KAAK,KAAK;CAEpC,MAAM,WAAW,IAAI,SAAS,MAAM;EAClC,QAAQ,KAAK;EACb;EACD,CAAC;AACF,UAAS,UAAU;AACnB,KAAI,KAAK,MACP,OAAM;AAER,QAAO;;AAET,SAAS,WAAW,KAAK;AACvB,QAAO,eAAe,YAAY,CAAC,CAAC,IAAI;;;;;ACxB1C,SAAS,eAAe,KAAK;CAC3B,MAAM,wBAAwB,IAAI,KAAK;CACvC,IAAI;CACJ,IAAI;CACJ,MAAM,SAAS,UAAU;AACvB,MAAI,CAAC,MAAM,KAAM;AACjB,MAAI,CAAC,MAAM,MAAM;AACf,SAAM,KAAK,OAAO,KAAK;AACvB,YAAS,MAAM;AACf,SAAM,OAAO,KAAK;AAClB,OAAI,QAAQ;AACV,UAAM,OAAO;AACb,WAAO,OAAO;;SAEX;AACL,SAAM,KAAK,OAAO,MAAM;AACxB,SAAM,KAAK,OAAO,MAAM;AACxB,SAAM,OAAO,KAAK;AAClB,OAAI,QAAQ;AACV,WAAO,OAAO;AACd,UAAM,OAAO;;;AAGjB,WAAS;;AAEX,QAAO;EACL,IAAI,KAAK;GACP,MAAM,QAAQ,MAAM,IAAI,IAAI;AAC5B,OAAI,CAAC,MAAO,QAAO,KAAK;AACxB,SAAM,MAAM;AACZ,UAAO,MAAM;;EAEf,IAAI,KAAK,OAAO;AACd,OAAI,MAAM,QAAQ,OAAO,QAAQ;IAC/B,MAAM,WAAW;AACjB,UAAM,OAAO,SAAS,IAAI;AAC1B,QAAI,SAAS,MAAM;AACjB,cAAS,SAAS;AAClB,cAAS,KAAK,OAAO,KAAK;;AAE5B,QAAI,aAAa,OACf,UAAS,KAAK;;GAGlB,MAAM,WAAW,MAAM,IAAI,IAAI;AAC/B,OAAI,UAAU;AACZ,aAAS,QAAQ;AACjB,UAAM,SAAS;UACV;IACL,MAAM,QAAQ;KAAE;KAAK;KAAO,MAAM;KAAQ;AAC1C,QAAI,OAAQ,QAAO,OAAO;AAC1B,aAAS;AACT,QAAI,CAAC,OAAQ,UAAS;AACtB,UAAM,IAAI,KAAK,MAAM;;;EAG1B;;;;;AClDH,IAAM,kBAAkB,UAAU;AAChC,KAAI,CAAC,MAAM,UAAU;AACnB,QAAM,WAAW;AACjB,SAAO,MAAM,WAAW;;;AAG5B,IAAM,kBAAkB,OAAO,YAAY;AACzC,QAAO,CAAC,EAAE,MAAM,WAAW,CAAC,MAAM,OAAO,MAAM,QAAQ,MAAM,MAAM,EAAE,OAAO,QAAQ;;AAEtF,IAAM,mBAAmB,OAAO,QAAQ;CACtC,MAAM,cAAc,MAAM,OAAO,WAAW,IAAI,WAAW,OAAO,MAAM,OAAO;AAC/E,KAAI,CAAC,YAAY,QAAQ,qBAAqB,MAAM,OAAO,SAAS,yBAClE,aAAY,QAAQ,oBAAoB,MAAM,OAAO,QAAQ;AAE/D,WACE,YAAY,QAAQ,mBACpB,gIACD;CACD,MAAM,gBAAgB,MAAM,QAAQ,MAAM,MAAM,EAAE,YAAY,YAAY,GAAG;AAC7E,WAAU,eAAe,qCAAqC,YAAY,GAAG;AAC7E,OAAM,YAAY,cAAc,KAAK,UAAU;EAC7C,GAAG;EACH,QAAQ;EACR,OAAO;EACP,YAAY;EACb,EAAE;AACH,KAAI,IAAI,eAAe,iBAAiB,YAAY,aAAa;AAC/D,MAAI,UAAU,YAAY,YAAY;AACtC,kBAAgB,OAAO,IAAI;;;AAG/B,IAAM,6BAA6B,OAAO,OAAO,QAAQ;AACvD,KAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,IAAI,CAAE;AAC1C,KAAI,WAAW,IAAI,IAAI,IAAI,mBAAmB,CAAC,IAAI,QAAQ,eACzD,OAAM;AAER,KAAI,OAAO;AACT,QAAM,aAAa,mBAAmB,SAAS;AAC/C,QAAM,aAAa,eAAe,SAAS;AAC3C,QAAM,aAAa,oBAAoB,KAAK;AAC5C,QAAM,aAAa,gBAAgB,KAAK;EACxC,MAAM,SAAS,WAAW,IAAI,GAAG,eAAe;AAChD,QAAM,YAAY,MAAM,KAAK,UAAU;GACrC,GAAG;GACH;GACA,YAAY;GACZ,OAAO;GACR,EAAE;AACH,MAAI,WAAW,IAAI,IAAI,CAAC,IAAI,QAC1B,KAAI,UAAU,MAAM;AAEtB,QAAM,aAAa,aAAa,SAAS;;AAE3C,KAAI,WAAW,IAAI,EAAE;AACnB,QAAM,WAAW;AACjB,MAAI,QAAQ,gBAAgB,MAAM;AAClC,MAAI,kBAAkB;AACtB,QAAM,MAAM,OAAO,gBAAgB,IAAI;AACvC,QAAM;QACD;AACL,kBAAgB,OAAO,IAAI;AAC3B,QAAM;;;AAGV,IAAM,oBAAoB,OAAO,YAAY;CAC3C,MAAM,QAAQ,MAAM,OAAO,SAAS,QAAQ;AAC5C,KAAI,CAAC,MAAM,OAAO,YAAY,MAAM,aAAa,WAC/C,QAAO;AAET,KAAI,MAAM,OAAO,YAAY,MAAM,QAAQ,MACzC,QAAO;AAET,QAAO;;AAET,IAAM,qBAAqB,OAAO,OAAO,KAAK,eAAe;CAC3D,MAAM,EAAE,IAAI,SAAS,YAAY,MAAM,QAAQ;CAC/C,MAAM,QAAQ,MAAM,OAAO,gBAAgB;AAC3C,KAAI,eAAe,QACjB,OAAM;AAER,KAAI,aAAa;AACjB,OAAM,uBAAuB;AAC7B,2BAA0B,OAAO,MAAM,OAAO,SAAS,QAAQ,EAAE,IAAI;AACrE,KAAI;AACF,QAAM,QAAQ,UAAU,IAAI;UACrB,iBAAiB;AACxB,QAAM;AACN,4BAA0B,OAAO,MAAM,OAAO,SAAS,QAAQ,EAAE,IAAI;;AAEvE,OAAM,YAAY,UAAU,SAAS;AACnC,OAAK,aAAa,mBAAmB,SAAS;AAC9C,OAAK,aAAa,oBAAoB,KAAK;AAC3C,OAAK,aAAa,aAAa,SAAS;AACxC,SAAO;GACL,GAAG;GACH,OAAO;GACP,QAAQ;GACR,YAAY;GACZ,WAAW,KAAK,KAAK;GACrB,iBAAiB,IAAI,iBAAiB;GACvC;GACD;;AAEJ,IAAM,mBAAmB,OAAO,SAAS,OAAO,UAAU;CACxD,MAAM,gBAAgB,MAAM,OAAO,SAAS,QAAQ;CACpD,MAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;CAChD,MAAM,cAAc,gBAAgB,MAAM,OAAO,SAAS,cAAc,GAAG,KAAK;AAChF,KAAI,MAAM,OAAO,SAAS,EAAE;AAC1B,gBAAc,MAAM,YAAY;AAChC;;AAEF,KAAI,aAAa,QAAQ,OAAO;AAC9B,gBAAc,MAAM;AACpB;;CAEF,MAAM,kBAAkB,aAAa;AACnC,MAAI,aAAa,QAAQ,aAAa,QAAQ,YAC5C,QAAO;AAET,SAAO;;CAET,MAAM,aAAa,MAAM,OAAO,QAAQ,cAAc;AACtD,KAAI,MAAM,QAAQ,QAAQ,KAAK,GAAG;AAChC,gBAAc,MAAM,eAAe,WAAW;AAC9C;;AAEF,KAAI,OAAO,MAAM,QAAQ,QAAQ,YAAY;AAC3C,gBAAc,MAAM,eAAe,MAAM,QAAQ,IAAI;AACrD;;CAEF,MAAM,EAAE,QAAQ,WAAW;CAC3B,MAAM,eAAe;EACnB,QAAQ,UAAU,QAAQ,cAAc,YAAY;EACpD,QAAQ,UAAU,QAAQ,cAAc,YAAY;EACpD,UAAU,MAAM;EAChB,SAAS,MAAM,QAAQ,KAAK,WAAW;GACrC,OAAO,MAAM;GACb,UAAU,MAAM;GAChB,UAAU,MAAM;GAChB,YAAY,MAAM;GAClB,IAAI,MAAM;GACV,SAAS,MAAM;GACf,QAAQ,UAAU,MAAM,QAAQ,MAAM,YAAY;GAClD,QAAQ,UAAU,MAAM,QAAQ,MAAM,YAAY;GAClD,KAAK,MAAM;GACZ,EAAE;EACJ;CACD,MAAM,UAAU,MAAM,QAAQ,IAAI,aAAa;AAC/C,KAAI,UAAU,QAAQ,CACpB,QAAO,QAAQ,MAAM,QAAQ;AAC3B,gBAAc,MAAM,eAAe,OAAO,WAAW;GACrD;AAEJ,eAAc,MAAM,eAAe,WAAW,WAAW;;AAG3D,IAAM,uBAAuB,OAAO,SAAS,OAAO,UAAU;AAC5D,KAAI,MAAM,aAAa,mBAAmB,KAAK,EAAG;CAClD,MAAM,YAAY,MAAM,QAAQ,aAAa,MAAM,OAAO,QAAQ;AAElE,KADsB,CAAC,EAAE,MAAM,WAAW,CAAC,MAAM,OAAO,YAAY,CAAC,eAAe,OAAO,QAAQ,KAAK,MAAM,QAAQ,UAAU,MAAM,QAAQ,cAAc,kBAAkB,MAAM,KAAK,OAAO,cAAc,YAAY,cAAc,aAAa,MAAM,QAAQ,oBAAoB,MAAM,OAAO,SAAS,2BAC1R;EACjB,MAAM,iBAAiB,iBAAiB;AACtC,kBAAe,MAAM;KACpB,UAAU;AACb,QAAM,aAAa,iBAAiB;;;AAGxC,IAAM,sBAAsB,OAAO,SAAS,UAAU;CACpD,MAAM,gBAAgB,MAAM,OAAO,SAAS,QAAQ;AACpD,KAAI,CAAC,cAAc,aAAa,qBAAqB,CAAC,cAAc,aAAa,cAC/E;AACF,qBAAoB,OAAO,SAAS,OAAO,cAAc;CACzD,MAAM,aAAa;EACjB,MAAM,QAAQ,MAAM,OAAO,SAAS,QAAQ;AAC5C,MAAI,MAAM,YAAY,MAAM,WAAW,gBAAgB,MAAM,WAAW,YACtE,2BAA0B,OAAO,OAAO,MAAM,MAAM;;AAGxD,QAAO,cAAc,aAAa,oBAAoB,cAAc,aAAa,kBAAkB,KAAK,KAAK,GAAG,MAAM;;AAExH,IAAM,qBAAqB,OAAO,SAAS,OAAO,UAAU;CAC1D,MAAM,QAAQ,MAAM,OAAO,SAAS,QAAQ;CAC5C,MAAM,kBAAkB,MAAM,aAAa;AAC3C,OAAM,aAAa,cAAc,8BAA8B;AAC7D,mBAAiB,SAAS;GAC1B;CACF,MAAM,EAAE,aAAa,gBAAgB;AACrC,KAAI,YACF,mBAAkB,OAAO,OAAO,aAAa,eAAe;AAE9D,KAAI,YACF,mBAAkB,OAAO,OAAO,aAAa,kBAAkB;AAEjE,qBAAoB,OAAO,SAAS,OAAO,MAAM;CACjD,MAAM,kBAAkB,IAAI,iBAAiB;CAC7C,MAAM,gBAAgB,MAAM,QAAQ,QAAQ,IAAI;CAGhD,MAAM,UAAU;EAAE,IAFE,gBAAgB,MAAM,OAAO,SAAS,cAAc,GAAG,KAAK,IACxC,WAAW,MAAM,OAAO,QAAQ,WAAW,KAAK;EAC/C,GAAG,MAAM;EAAgB;CAClE,IAAI,YAAY;CAChB,MAAM,gBAAgB;AACpB,MAAI,UAAW;AACf,cAAY;AACZ,QAAM,YAAY,UAAU,UAAU;GACpC,GAAG;GACH,YAAY;GACZ,YAAY,KAAK,aAAa;GAC9B;GACA;GACD,EAAE;;CAEL,MAAM,gBAAgB;AACpB,QAAM,aAAa,mBAAmB,SAAS;AAC/C,QAAM,aAAa,oBAAoB,KAAK;AAC5C,QAAM,YAAY,UAAU,UAAU;GACpC,GAAG;GACH,YAAY;GACb,EAAE;;AAEL,KAAI,CAAC,MAAM,QAAQ,YAAY;AAC7B,cAAY;AACV,YAAS;AACT,YAAS;IACT;AACF;;AAEF,OAAM,aAAa,oBAAoB,yBAAyB;CAChE,MAAM,EAAE,QAAQ,QAAQ,UAAU;CAClC,MAAM,UAAU,eAAe,OAAO,QAAQ;CAC9C,MAAM,sBAAsB;EAC1B;EACA;EACA;EACA;EACA;EACA,UAAU,MAAM;EAChB,WAAW,SAAS,MAAM,OAAO,SAAS;GACxC,GAAG;GACH,eAAe,MAAM;GACtB,CAAC;EACF,eAAe,MAAM,OAAO;EAC5B,OAAO,UAAU,YAAY;EAC7B,SAAS,MAAM;EACf,GAAG,MAAM,OAAO,QAAQ;EACzB;CACD,MAAM,iBAAiB,uBAAuB;AAC5C,MAAI,uBAAuB,KAAK,GAAG;AACjC,eAAY;AACV,aAAS;AACT,aAAS;KACT;AACF;;AAEF,MAAI,WAAW,mBAAmB,IAAI,WAAW,mBAAmB,EAAE;AACpE,YAAS;AACT,qBAAkB,OAAO,OAAO,oBAAoB,cAAc;;AAEpE,cAAY;AACV,YAAS;AACT,SAAM,YAAY,UAAU,UAAU;IACpC,GAAG;IACH,qBAAqB;IACrB,SAAS;KACP,GAAG,KAAK;KACR,GAAG;KACJ;IACF,EAAE;AACH,YAAS;IACT;;CAEJ,IAAI;AACJ,KAAI;AACF,sBAAoB,MAAM,QAAQ,WAAW,oBAAoB;AACjE,MAAI,UAAU,kBAAkB,EAAE;AAChC,YAAS;AACT,UAAO,kBAAkB,OAAO,QAAQ;AACtC,sBAAkB,OAAO,OAAO,KAAK,cAAc;KACnD,CAAC,KAAK,cAAc;;UAEjB,KAAK;AACZ,WAAS;AACT,oBAAkB,OAAO,OAAO,KAAK,cAAc;;AAErD,eAAc,kBAAkB;;AAGlC,IAAM,oBAAoB,OAAO,UAAU;CACzC,MAAM,EAAE,IAAI,SAAS,YAAY,MAAM,QAAQ;CAC/C,MAAM,QAAQ,MAAM,OAAO,gBAAgB;CAC3C,MAAM,kBAAkB;AACtB,MAAI,MAAM,OAAO,UAAU;GACzB,MAAM,eAAe,gBAAgB,OAAO,SAAS,OAAO,MAAM;AAClE,OAAI,UAAU,aAAa,CAAE,QAAO,aAAa,KAAK,eAAe;;AAEvE,SAAO,gBAAgB;;CAEzB,MAAM,gBAAgB,kBAAkB,OAAO,SAAS,OAAO,MAAM;CACrE,MAAM,uBAAuB;AAC3B,MAAI,iBAAiB,OAAO,QAAQ,CAAE;EACtC,MAAM,SAAS,mBAAmB,OAAO,SAAS,MAAM;AACxD,SAAO,UAAU,OAAO,GAAG,OAAO,KAAK,QAAQ,GAAG,SAAS;;AAE7D,QAAO,WAAW;;AAEpB,IAAM,eAAe,OAAO,SAAS,UAAU;CAC7C,MAAM,QAAQ,MAAM,OAAO,SAAS,QAAQ;AAC5C,KAAI,CAAC,MACH;AAEF,KAAI,CAAC,MAAM,QAAQ,QAAQ,CAAC,MAAM,QAAQ,WAAW,CAAC,MAAM,QAAQ,QAClE;CAEF,MAAM,eAAe;EACnB,SAAS,MAAM;EACf;EACA,QAAQ,MAAM;EACd,YAAY,MAAM;EACnB;AACD,QAAO,QAAQ,IAAI;EACjB,MAAM,QAAQ,OAAO,aAAa;EAClC,MAAM,QAAQ,UAAU,aAAa;EACrC,MAAM,QAAQ,UAAU,aAAa;EACtC,CAAC,CAAC,MAAM,CAAC,eAAe,SAAS,aAAa;AAK7C,SAAO;GACL,MALW,eAAe;GAM1B,OALY,eAAe;GAM3B,aALkB,eAAe;GAMjC;GACA;GACA,QAPa,eAAe;GAQ7B;GACD;;AAEJ,IAAM,oBAAoB,OAAO,SAAS,OAAO,UAAU;CACzD,MAAM,qBAAqB,MAAM,cAAc,QAAQ;CACvD,MAAM,EAAE,QAAQ,YAAY,iBAAiB,SAAS,UAAU,MAAM,OAAO,SAAS,QAAQ;CAC9F,MAAM,UAAU,eAAe,OAAO,QAAQ;AAC9C,QAAO;EACL;EACA,MAAM;EACN,SAAS,CAAC,CAAC;EACX;EACA;EACA;EACA,UAAU,MAAM;EAChB,WAAW,SAAS,MAAM,OAAO,SAAS;GACxC,GAAG;GACH,eAAe,MAAM;GACtB,CAAC;EACF,OAAO,UAAU,YAAY;EAC7B;EACA,GAAG,MAAM,OAAO,QAAQ;EACzB;;AAEH,IAAM,YAAY,OAAO,OAAO,SAAS,OAAO,UAAU;AACxD,KAAI;EACF,MAAM,QAAQ,MAAM,OAAO,SAAS,QAAQ;AAC5C,MAAI;AACF,OAAI,CAAC,MAAM,OAAO,YAAY,MAAM,QAAQ,KAC1C,gBAAe,MAAM;GAEvB,MAAM,eAAe,MAAM,QAAQ,SACjC,iBAAiB,OAAO,SAAS,OAAO,MAAM,CAC/C;GACD,MAAM,wBAAwB,MAAM,QAAQ,UAAU,UAAU,aAAa;AAE7E,OAD0B,CAAC,EAAE,yBAAyB,MAAM,gBAAgB,MAAM,sBAAsB,MAAM,QAAQ,QAAQ,MAAM,QAAQ,WAAW,MAAM,QAAQ,WAAW,MAAM,aAAa,mBAEjM,OAAM,YAAY,UAAU,UAAU;IACpC,GAAG;IACH,YAAY;IACb,EAAE;AAEL,OAAI,MAAM,QAAQ,QAAQ;IACxB,MAAM,aAAa,wBAAwB,MAAM,eAAe;AAChE,8BACE,OACA,MAAM,OAAO,SAAS,QAAQ,EAC9B,WACD;AACD,QAAI,eAAe,KAAK,EACtB,OAAM,YAAY,UAAU,UAAU;KACpC,GAAG;KACH;KACD,EAAE;;AAGP,OAAI,MAAM,aAAc,OAAM,MAAM;GACpC,MAAM,aAAa,YAAY,OAAO,SAAS,MAAM;GACrD,MAAM,OAAO,aAAa,MAAM,aAAa,KAAK;GAClD,MAAM,iBAAiB,MAAM,aAAa;AAC1C,OAAI,eAAgB,OAAM;AAC1B,OAAI,MAAM,mBAAoB,OAAM,MAAM;AAC1C,SAAM,YAAY,UAAU,UAAU;IACpC,GAAG;IACH,OAAO,KAAK;IACZ,QAAQ;IACR,YAAY;IACZ,WAAW,KAAK,KAAK;IACrB,GAAG;IACJ,EAAE;WACI,GAAG;GACV,IAAI,QAAQ;GACZ,MAAM,iBAAiB,MAAM,aAAa;AAC1C,OAAI,eAAgB,OAAM;AAC1B,OAAI,WAAW,EAAE,CACf,OAAM,MAAM,QAAQ,mBAAmB,WAAW;AAEpD,6BAA0B,OAAO,MAAM,OAAO,SAAS,QAAQ,EAAE,EAAE;AACnE,OAAI;AACF,UAAM,QAAQ,UAAU,EAAE;YACnB,cAAc;AACrB,YAAQ;AACR,8BACE,OACA,MAAM,OAAO,SAAS,QAAQ,EAC9B,aACD;;GAEH,MAAM,aAAa,YAAY,OAAO,SAAS,MAAM;GACrD,MAAM,OAAO,aAAa,MAAM,aAAa,KAAK;AAClD,SAAM,YAAY,UAAU,UAAU;IACpC,GAAG;IACH;IACA,QAAQ;IACR,YAAY;IACZ,GAAG;IACJ,EAAE;;UAEE,KAAK;EACZ,MAAM,QAAQ,MAAM,OAAO,SAAS,QAAQ;AAC5C,MAAI,OAAO;GACT,MAAM,aAAa,YAAY,OAAO,SAAS,MAAM;AACrD,OAAI,YAAY;IACd,MAAM,OAAO,MAAM;AACnB,UAAM,YAAY,UAAU,UAAU;KACpC,GAAG;KACH,GAAG;KACJ,EAAE;;AAEL,SAAM,aAAa,gBAAgB,KAAK;;AAE1C,4BAA0B,OAAO,OAAO,IAAI;;;AAGhD,IAAM,iBAAiB,OAAO,OAAO,UAAU;CAC7C,MAAM,EAAE,IAAI,SAAS,YAAY,MAAM,QAAQ;CAC/C,IAAI,uBAAuB;CAC3B,IAAI,uBAAuB;CAC3B,MAAM,QAAQ,MAAM,OAAO,gBAAgB;AAC3C,KAAI,iBAAiB,OAAO,QAAQ,EAClC;MAAI,MAAM,OAAO,UAAU;GACzB,MAAM,aAAa,YAAY,OAAO,SAAS,MAAM;AACrD,OAAI,YAAY;IACd,MAAM,OAAO,MAAM;AACnB,UAAM,YAAY,UAAU,UAAU;KACpC,GAAG;KACH,GAAG;KACJ,EAAE;;AAEL,UAAO,MAAM,OAAO,SAAS,QAAQ;;QAElC;EACL,MAAM,YAAY,MAAM,OAAO,SAAS,QAAQ;AAChD,MAAI,UAAU,aAAa,eAAe;AACxC,OAAI,UAAU,WAAW,aAAa,CAAC,MAAM,QAAQ,CAAC,UAAU,QAC9D,QAAO;AAET,SAAM,UAAU,aAAa;GAC7B,MAAM,SAAS,MAAM,OAAO,SAAS,QAAQ;AAC7C,OAAI,OAAO,MACT,2BAA0B,OAAO,QAAQ,OAAO,MAAM;SAEnD;GACL,MAAM,MAAM,KAAK,KAAK,GAAG,UAAU;GACnC,MAAM,UAAU,eAAe,OAAO,QAAQ;GAC9C,MAAM,WAAW,UAAU,MAAM,QAAQ,oBAAoB,MAAM,OAAO,QAAQ,2BAA2B,MAAM,MAAM,QAAQ,aAAa,MAAM,OAAO,QAAQ,oBAAoB;GACvL,MAAM,qBAAqB,MAAM,QAAQ;GACzC,MAAM,eAAe,OAAO,uBAAuB,aAAa,mBAAmB,iBAAiB,OAAO,SAAS,OAAO,MAAM,CAAC,GAAG;GACrI,MAAM,cAAc,CAAC,CAAC,WAAW,CAAC,MAAM,OAAO,MAAM,QAAQ,MAAM,MAAM,EAAE,OAAO,QAAQ;GAC1F,MAAM,SAAS,MAAM,OAAO,SAAS,QAAQ;AAC7C,UAAO,aAAa,gBAAgB,yBAAyB;AAC7D,OAAI,gBAAgB,OAAO,QACzB,OAAM,YAAY,UAAU,UAAU;IACpC,GAAG;IACH,SAAS;IACV,EAAE;GAEL,MAAM,EAAE,QAAQ,YAAY;AAC5B,0BAAuB,WAAW,cAAc,YAAY,gBAAgB,MAAM;AAClF,OAAI,WAAW,MAAM,QAAQ,YAAY;YAChC,wBAAwB,CAAC,MAAM,MAAM;AAC5C,2BAAuB;AACvB,KAAC,YAAY;AACX,SAAI;AACF,YAAM,UAAU,OAAO,SAAS,OAAO,MAAM;MAC7C,MAAM,SAAS,MAAM,OAAO,SAAS,QAAQ;AAC7C,aAAO,aAAa,eAAe,SAAS;AAC5C,aAAO,aAAa,aAAa,SAAS;AAC1C,aAAO,aAAa,gBAAgB,KAAK;cAClC,KAAK;AACZ,UAAI,WAAW,IAAI,CACjB,OAAM,MAAM,OAAO,SAAS,IAAI,QAAQ;;QAG1C;cACK,WAAW,aAAa,wBAAwB,MAAM,KAC/D,OAAM,UAAU,OAAO,SAAS,OAAO,MAAM;QACxC;IACL,MAAM,aAAa,YAAY,OAAO,SAAS,MAAM;AACrD,QAAI,YAAY;KACd,MAAM,OAAO,MAAM;AACnB,WAAM,YAAY,UAAU,UAAU;MACpC,GAAG;MACH,GAAG;MACJ,EAAE;;;;;CAKX,MAAM,QAAQ,MAAM,OAAO,SAAS,QAAQ;AAC5C,KAAI,CAAC,sBAAsB;AACzB,QAAM,aAAa,eAAe,SAAS;AAC3C,QAAM,aAAa,aAAa,SAAS;;AAE3C,cAAa,MAAM,aAAa,eAAe;AAC/C,OAAM,aAAa,iBAAiB,KAAK;AACzC,KAAI,CAAC,qBAAsB,OAAM,aAAa,gBAAgB,KAAK;AACnE,OAAM,aAAa,aAAa,KAAK;CACrC,MAAM,iBAAiB,uBAAuB,MAAM,aAAa;AACjE,KAAI,mBAAmB,MAAM,cAAc,MAAM,YAAY,OAAO;AAClE,QAAM,YAAY,UAAU,UAAU;GACpC,GAAG;GACH,YAAY;GACZ,SAAS;GACV,EAAE;AACH,SAAO,MAAM,OAAO,SAAS,QAAQ;OAErC,QAAO;;AAGX,eAAe,YAAY,KAAK;CAC9B,MAAM,QAAQ,OAAO,OAAO,KAAK,EAC/B,eAAe,EAAE,EAClB,CAAC;AACF,KAAI,CAAC,MAAM,OAAO,YAAY,MAAM,OAAO,MAAM,QAAQ,MAAM,MAAM,EAAE,cAAc,CACnF,gBAAe,MAAM;AAEvB,KAAI;AACF,OAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,QAAQ,KAAK;GAC7C,MAAM,aAAa,iBAAiB,OAAO,EAAE;AAC7C,OAAI,UAAU,WAAW,CAAE,OAAM;;EAEnC,MAAM,MAAM,MAAM,sBAAsB,MAAM,QAAQ;AACtD,OAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IACvB,OAAM,cAAc,KAAK,eAAe,OAAO,EAAE,CAAC;AAEpD,QAAM,QAAQ,IAAI,MAAM,cAAc;EACtC,MAAM,eAAe,eAAe,MAAM;AAC1C,MAAI,UAAU,aAAa,CAAE,OAAM;UAC5B,KAAK;AACZ,MAAI,WAAW,IAAI,IAAI,CAAC,MAAM,SAAS;GACrC,MAAM,eAAe,eAAe,MAAM;AAC1C,OAAI,UAAU,aAAa,CAAE,OAAM;AACnC,SAAM;;AAER,MAAI,WAAW,IAAI,CACjB,OAAM;;AAGV,QAAO,MAAM;;AAEf,eAAe,eAAe,OAAO;AACnC,KAAI,CAAC,MAAM,eAAe,MAAM,iBAAiB,KAAK,EACpD,KAAI,MAAM,OACR,OAAM,eAAe,MAAM,QAAQ,CAAC,MAAM,cAAc;EACtD,MAAM,EAAE,IAAI,IAAK,GAAG,YAAY,UAAU;AAC1C,SAAO,OAAO,MAAM,SAAS,QAAQ;AACrC,QAAM,cAAc;AACpB,QAAM,eAAe,KAAK;GAC1B;KAEF,OAAM,cAAc;AAGxB,KAAI,CAAC,MAAM,qBAAqB,MAAM,uBAAuB,KAAK,GAAG;EACnE,MAAM,uBAAuB;GAC3B,MAAM,WAAW,EAAE;AACnB,QAAK,MAAM,QAAQ,gBAAgB;IACjC,MAAM,UAAU,MAAM,QAAQ,OAAO;AACrC,QAAI,QAAS,UAAS,KAAK,SAAS,CAAC;;AAEvC,OAAI,SAAS,OACX,QAAO,QAAQ,IAAI,SAAS,CAAC,WAAW;AACtC,UAAM,oBAAoB;AAC1B,UAAM,qBAAqB,KAAK;KAChC;AACJ,SAAM,oBAAoB;AAC1B,SAAM,qBAAqB,KAAK;;AAGlC,QAAM,qBAAqB,MAAM,eAAe,MAAM,aAAa,KAAK,eAAe,GAAG,gBAAgB;;AAE5G,QAAO,MAAM;;AAEf,SAAS,UAAU,OAAO,OAAO;AAC/B,KAAI,MACF,QAAO;EAAE,QAAQ;EAAS;EAAO;AAEnC,QAAO;EAAE,QAAQ;EAAW;EAAO;;AAErC,SAAS,kBAAkB,OAAO;AAChC,MAAK,MAAM,iBAAiB,eAC1B,KAAI,MAAM,QAAQ,gBAAgB,QAChC,QAAO;AAGX,QAAO;;AAET,IAAM,iBAAiB;CACrB;CACA;CACA;CACA;CACD;;;;ACxnBD,SAAS,gBAAgB,UAAU;AACjC,QAAO;EACL,QAAQ,EAAE,UAAU;AAClB,QAAK,MAAM,WAAW,SACpB,OAAM,oBAAoB,SAAS,IAAI;AAEzC,UAAO;;EAET,SAAS,EAAE,UAAU;AACnB,QAAK,IAAI,IAAI,SAAS,SAAS,GAAG,KAAK,GAAG,IACxC,OAAM,qBAAqB,SAAS,IAAI,IAAI;AAE9C,UAAO;;EAEV;;AAEH,SAAS,gBAAgB,MAAM;CAC7B,MAAM,kBAAkB,SAAS,KAAK,SAAS;CAC/C,MAAM,qBAAqB,IAAI;CAC/B,MAAM,8BAA8B,GAAG,mBAAmB;CAC1D,MAAM,gBAAgB,KAAK,gBAAgB,qBAAqB,mBAAmB,aAAa;CAChG,MAAM,yBAAyB,KAAK,gBAAgB,8BAA8B,4BAA4B,aAAa;AAC3H,QAAO;EACL,QAAQ,EAAE,UAAU;GAClB,MAAM,WAAW,KAAK,gBAAgB,IAAI,WAAW,IAAI,SAAS,aAAa;AAC/E,OAAI,aAAa,cACf,KAAI,WAAW;YACN,SAAS,WAAW,uBAAuB,CACpD,KAAI,WAAW,IAAI,SAAS,MAAM,mBAAmB,OAAO;AAE9D,UAAO;;EAET,SAAS,EAAE,UAAU;AACnB,OAAI,WAAW,UAAU;IAAC;IAAK;IAAiB,IAAI;IAAS,CAAC;AAC9D,UAAO;;EAEV;;AAEH,SAAS,oBAAoB,SAAS,KAAK;CACzC,MAAM,MAAM,SAAS,QAAQ,EAAE,KAAK,CAAC;AACrC,KAAI,KACF;MAAI,OAAO,QAAQ,SACjB,QAAO,IAAI,IAAI,IAAI;WACV,eAAe,IACxB,QAAO;;AAGX,QAAO;;AAET,SAAS,qBAAqB,SAAS,KAAK;CAC1C,MAAM,MAAM,SAAS,SAAS,EAAE,KAAK,CAAC;AACtC,KAAI,KACF;MAAI,OAAO,QAAQ,SACjB,QAAO,IAAI,IAAI,IAAI;WACV,eAAe,IACxB,QAAO;;AAGX,QAAO;;;;;AC9CT,SAAS,sBAAsB,KAAK;AAClC,KAAI,eAAe,OAAO;EACxB,MAAM,MAAM;GACV,MAAM,IAAI;GACV,SAAS,IAAI;GACd;AAEC,MAAI,QAAQ,IAAI;AAElB,SAAO;;AAET,QAAO,EACL,MAAM,KACP;;AAOH,SAAS,sBAAsB,aAAa;CAC1C,MAAM,eAAe,YAAY;CACjC,MAAM,aAAa,YAAY;AAI/B,QAAO;EAAE;EAAc;EAAY,aAHf,cAAc,aAAa,WAAW;EAGV,aAF5B,cAAc,SAAS,WAAW;EAEO,aADzC,cAAc,SAAS,WAAW;EACoB;;AAE5E,IAAM,aAAN,MAAiB;;;;CAIf,YAAY,SAAS;AACnB,OAAK,kBAAkB,GAAG,KAAK,MAC7B,KAAK,QAAQ,GAAG,IACjB;AACD,OAAK,kBAAkB;AACvB,OAAK,uBAAuB,KAAK;AACjC,OAAK,iCAAiC,KAAK;AAC3C,OAAK,8BAA8B,IAAI,KAAK;AAC5C,OAAK,oBAAoB;AACzB,OAAK,2BAA2B;AAChC,OAAK,mBAAmB,OAAO,IAAI;AACnC,OAAK,UAAU,eAAe;AAC5B,OAAI,WAAW,cACb,SAAQ,KACN,gNACD;GAEH,MAAM,cAAc,KAAK;GACzB,MAAM,eAAe,KAAK,YAAY,aAAa,YAAY;GAC/D,MAAM,mBAAmB,KAAK,aAAa,KAAK;GAChD,MAAM,oBAAoB,aAAa;AACvC,QAAK,UAAU;IACb,GAAG;IACH,GAAG;IACJ;AACD,QAAK,WAAW,KAAK,QAAQ,YAAY,OAAO,aAAa;AAC7D,QAAK,0BAA0B,KAAK,QAAQ,8BAA8B,IAAI,IAC5E,KAAK,QAAQ,4BAA4B,KAAK,SAAS,CACrD,mBAAmB,KAAK,EACxB,KACD,CAAC,CACH,GAAG,KAAK;AACT,OAAI,CAAC,KAAK,WAAW,KAAK,QAAQ,WAAW,KAAK,QAAQ,YAAY,KAAK,QACzE,KAAI,CAAC,KAAK,QAAQ,SAChB;QAAI,CAAC,KAAK,SACR,MAAK,UAAU,sBAAsB;SAGvC,MAAK,UAAU,KAAK,QAAQ;AAGhC,QAAK,SAAS,KAAK,QAAQ;AAC3B,OAAI,CAAC,KAAK,OACR,KAAI,CAAC,KAAK,YAAY,QAAQ,UAAU,OAAO,WAAW,OACxD,MAAK,SAAS,OAAO;OAErB,MAAK,SAAS;AAGlB,OAAI,KAAK,QACP,MAAK,sBAAsB;AAE7B,OAAI,KAAK,QAAQ,cAAc,KAAK,WAAW;AAC7C,SAAK,YAAY,KAAK,QAAQ;AAC9B,SAAK,gBAAgB;;AAEvB,OAAI,CAAC,KAAK,WAAW,KAAK,gBAAgB;AACxC,SAAK,UAAU,IAAI,MAAM,sBAAsB,KAAK,eAAe,EAAE,EACnE,gBAAgB;AACd,UAAK,QAAQ,QAAQ;MACnB,GAAG,KAAK;MACR,eAAe,KAAK,MAAM,cAAc,QACrC,MAAM,CAAC,CAAC,aAAa,CAAC,SAAS,EAAE,OAAO,CAC1C;MACF;OAEJ,CAAC;AACF,2BAAuB,KAAK;;GAE9B,IAAI,sBAAsB;GAC1B,MAAM,eAAe,KAAK,QAAQ,YAAY;GAC9C,MAAM,oBAAoB,KAAK,QAAQ;AAGvC,OAFwB,oBAAoB,iBAAiB,gBACtC,sBAAsB,mBACN;AACrC,SAAK,WAAW;IAChB,MAAM,WAAW,EAAE;AACnB,QAAI,SAAS,aAAa,KAAK,GAC7B,UAAS,KACP,gBAAgB,EACd,UAAU,cACX,CAAC,CACH;AAEH,QAAI,kBACF,UAAS,KAAK,kBAAkB;AAElC,SAAK,UAAU,SAAS,WAAW,IAAI,KAAK,IAAI,SAAS,WAAW,IAAI,SAAS,KAAK,gBAAgB,SAAS;AAC/G,QAAI,KAAK,QACP,MAAK,sBAAsB;AAE7B,0BAAsB;;AAExB,OAAI,uBAAuB,KAAK,QAC9B,MAAK,QAAQ,QAAQ;IACnB,GAAG,KAAK;IACR,UAAU,KAAK;IAChB;AAEH,OAAI,OAAO,WAAW,eAAe,SAAS,UAAU,OAAO,OAAO,KAAK,aAAa,WACtF,MAAK,iCAAiC,OAAO,IAAI,SAC/C,2CACD;;AAGL,OAAK,6BAA6B;AAChC,QAAK,iBAAiB,KAAK,cACzB,KAAK,QAAQ,UACb,KAAK,eACN;;AAEH,OAAK,uBAAuB;GAC1B,MAAM,EAAE,YAAY,cAAc,eAAe,iBAAiB;IAChE,WAAW,KAAK;IAChB,YAAY,OAAO,MAAM;AACvB,WAAM,KAAK,EACT,eAAe,GAChB,CAAC;;IAEL,CAAC;AACF,QAAK,aAAa;AAClB,QAAK,eAAe;AACpB,QAAK,aAAa;GAClB,MAAM,gBAAgB,KAAK,QAAQ;AACnC,OAAI,eAAe;AACjB,kBAAc,KAAK,EACjB,eAAe,aAChB,CAAC;AACF,SAAK,WAAW,cAAc,MAAM;;;AAGxC,OAAK,aAAa,WAAW,OAAO;GAClC,MAAM,WAAW;IACf;IACA;IACD;AACD,QAAK,YAAY,IAAI,SAAS;AAC9B,gBAAa;AACX,SAAK,YAAY,OAAO,SAAS;;;AAGrC,OAAK,QAAQ,gBAAgB;AAC3B,QAAK,YAAY,SAAS,aAAa;AACrC,QAAI,SAAS,cAAc,YAAY,KACrC,UAAS,GAAG,YAAY;KAE1B;;AAEJ,OAAK,iBAAiB,iBAAiB,qBAAqB;GAC1D,MAAM,SAAS,EACb,MACA,YACI;IACJ,MAAM,UAAU,IAAI,IAAI,MAAM,KAAK,OAAO;IAC1C,MAAM,MAAM,oBAAoB,KAAK,SAAS,QAAQ;IACtD,MAAM,eAAe,KAAK,QAAQ,YAAY,IAAI,OAAO;IACzD,MAAM,YAAY,KAAK,QAAQ,gBAAgB,aAAa;AAC5D,QAAI,SAAS;IACb,MAAM,WAAW,IAAI,KAAK,QAAQ,IAAI,QAAQ,GAAG;IACjD,MAAM,EAAE,UAAU,SAAS;AAC3B,WAAO;KACL,MAAM;KACN,YAAY;KACZ,KAAK,IAAI;KACT;KACA;KACA,QAAQ,iBAAiB,kBAAkB,QAAQ,aAAa;KAChE,MAAM,KAAK,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM;KACtC,OAAO,iBAAiB,kBAAkB,OAAO,MAAM;KACxD;;GAEH,MAAM,WAAW,MAAM,gBAAgB;GACvC,MAAM,EAAE,gBAAgB,cAAc,SAAS;AAC/C,OAAI,mBAAmB,CAAC,aAAa,cAAc,KAAK,kBAAkB;IACxE,MAAM,qBAAqB,MAAM,eAAe;AAChD,uBAAmB,MAAM,MAAM,SAAS,MAAM;AAC9C,uBAAmB,MAAM,YAAY,SAAS,MAAM;AACpD,WAAO,mBAAmB,MAAM;AAChC,WAAO;KACL,GAAG;KACH,gBAAgB;KACjB;;AAEH,UAAO;;AAET,OAAK,uBAAuB,MAAM,SAAS;AAOzC,UANqB,YAAY;IAC/B,MAAM;IACN,IAAI,UAAU,KAAK;IACnB,eAAe,KAAK,QAAQ;IAC5B,YAAY,KAAK;IAClB,CAAC;;AAGJ,OAAK,eAAe,gBAAgB,sBAAsB,SAAS;AACjE,OAAI,OAAO,mBAAmB,SAC5B,QAAO,KAAK,oBACV;IACE,UAAU;IACV,QAAQ;IACT,EACD,KACD;AAEH,UAAO,KAAK,oBAAoB,gBAAgB,qBAAqB;;AAEvE,OAAK,qBAAqB,eAAe,IAAI;AAC7C,OAAK,oBAAoB,UAAU,kBAAkB;AACnD,UAAO,iBAAiB;IACtB;IACA;IACA,eAAe,KAAK,QAAQ;IAC5B,cAAc,KAAK;IACnB,YAAY,KAAK;IACjB,YAAY,KAAK;IACjB,YAAY,KAAK;IAClB,CAAC;;AAEJ,OAAK,eAAe,OAAO;GACzB,MAAM,QAAQ,KAAK,SAAS,GAAG;AAC/B,OAAI,CAAC,MAAO;AACZ,SAAM,gBAAgB,OAAO;AAC7B,gBAAa,MAAM,aAAa,eAAe;AAC/C,SAAM,aAAa,iBAAiB,KAAK;;AAE3C,OAAK,sBAAsB;AACzB,QAAK,MAAM,gBAAgB,SAAS,UAAU;AAC5C,SAAK,YAAY,MAAM,GAAG;KAC1B;;AAEJ,OAAK,iBAAiB,SAAS;GAC7B,MAAM,SAAS,OAAO,EAAE,KAAK;IAC3B,MAAM,kBAAkB,KAAK,iBAAiB,KAAK;IACnD,MAAM,4BAA4B,KAAK,YAAY,iBAAiB,EAClE,gBAAgB,MACjB,CAAC;IACF,MAAM,YAAY,KAAK,0BAA0B;AACjD,QAAI,KAAK,QAAiD,KAAK,aAAa;KAC1E,MAAM,iBAAiB,KAAK,iBAC1B,KAAK,MACL,KAAK,EACN,CAAC;KACF,MAAM,cAAc,SAAS,4BAA4B,MAAM;AAC7D,aAAO,aAAa,EAAE,UAAU,KAAK,KAAK;OAC1C;KACF,MAAM,iBAAiB,SAAS,iBAAiB,MAAM;AACrD,aAAO,aAAa,EAAE,UAAU,UAAU,SAAS;OACnD;AACF,SAAI,CAAC,eAAe,CAAC,eACnB,SAAQ,KAAK,kCAAkC,KAAK,OAAO;;IAG/D,MAAM,oBAAoB,KAAK,mBAAmB,SAAS,gBAAgB,WAAW,KAAK,QAAQ,UAAU;IAC7G,MAAM,WAAW,KAAK,oBAAoB,mBAAmB,IAAI;IACjE,MAAM,aAAa,UAAU;IAC7B,MAAM,aAAa,EAAE,GAAG,UAAU,QAAQ;IAC1C,MAAM,SAAS,KAAK,KAAK,KAAK,oBAAoB,UAAU,GAAG,KAAK,KAAK,GAAG,KAAK,oBAAoB,UAAU,IAAI;IACnH,MAAM,aAAa,KAAK,WAAW,SAAS,KAAK,WAAW,OAAO,EAAE,IAAI,KAAK,UAAU,UAAU,OAAO,aAAa,OAAO,OAC3H,YACA,iBAAiB,KAAK,QAAQ,WAAW,CAC1C;IACD,MAAM,qBAAqB,gBAAgB;KACzC,MAAM;KACN,QAAQ;KACR,YAAY,KAAK;KAClB,CAAC,CAAC;IACH,MAAM,aAAa,KAAK,YAAY,oBAAoB,KAAK,GAAG,EAC9D,gBAAgB,MACjB,CAAC,CAAC,KAAK,MAAM,KAAK,gBAAgB,EAAE,SAAS;AAC9C,QAAI,OAAO,KAAK,WAAW,CAAC,SAAS,EACnC,MAAK,MAAM,SAAS,YAAY;KAC9B,MAAM,KAAK,MAAM,QAAQ,QAAQ,aAAa,MAAM,QAAQ;AAC5D,SAAI,GACF,QAAO,OAAO,YAAY,GAAG,WAAW,CAAC;;IAI/C,MAAM,eAAe,gBAAgB;KAGnC,MAAM;KACN,QAAQ;KACR,gBAAgB;KAChB,aAAa,KAAK;KAClB,eAAe,KAAK;KACpB,YAAY,KAAK;KAClB,CAAC,CAAC;IACH,IAAI,aAAa;AACjB,QAAI,KAAK,0BAA0B,KAAK,QAAQ,QAAQ,QAAQ;KAC9D,MAAM,kBAAkB,EAAE;AAC1B,gBAAW,SAAS,UAAU;AAC5B,UAAI,MAAM,QAAQ,eAChB,KAAI;AACF,cAAO,OACL,iBACA,eAAe,MAAM,QAAQ,gBAAgB;QAC3C,GAAG;QACH,GAAG;QACJ,CAAC,CACH;cACK;OAGV;AACF,kBAAa;;AAEf,iBAAa,sBAAsB;KACjC,QAAQ;KACR;KACA;KACA,wBAAwB,KAAK;KAC9B,CAAC;AACF,iBAAa,iBAAiB,YAAY,WAAW;IACrD,MAAM,YAAY,KAAK,QAAQ,gBAAgB,WAAW;IAC1D,MAAM,OAAO,KAAK,SAAS,OAAO,gBAAgB,OAAO,KAAK,OAAO,iBAAiB,KAAK,MAAM,gBAAgB,KAAK,GAAG,KAAK;IAC9H,MAAM,UAAU,OAAO,IAAI,SAAS;IACpC,IAAI,YAAY,KAAK,UAAU,OAAO,gBAAgB,QAAQ,KAAK,QAAQ,iBAAiB,KAAK,OAAO,gBAAgB,MAAM,GAAG,EAAE;AACnI,gBAAY,iBAAiB,gBAAgB,OAAO,UAAU;IAC9D,MAAM,WAAW,GAAG,eAAe,YAAY;IAC/C,MAAM,MAAM,IAAI,IAAI,UAAU,KAAK,OAAO;IAC1C,MAAM,eAAe,qBAAqB,KAAK,SAAS,IAAI;AAC5D,WAAO;KACL,YAAY,aAAa,WAAW,aAAa,SAAS,aAAa;KACvE,MAAM;KACN,KAAK,aAAa;KAClB,UAAU;KACV,QAAQ;KACR;KACA,OAAO;KACP,MAAM,QAAQ;KACd,gBAAgB,KAAK;KACtB;;GAEH,MAAM,oBAAoB,OAAO,EAAE,EAAE,eAAe;IAClD,MAAM,OAAO,MAAM,KAAK;IACxB,IAAI,aAAa,aAAa,MAAM,WAAW,GAAG,KAAK;AACvD,QAAI,CAAC,YAAY;KACf,IAAI,SAAS,EAAE;KACf,MAAM,YAAY,KAAK,QAAQ,YAAY,MAAM,MAAM;MACrD,MAAM,QAAQ,cACZ,KAAK,UACL;OACE,IAAI,EAAE;OACN,eAAe;OACf,OAAO;OACR,EACD,KAAK,mBACN;AACD,UAAI,OAAO;AACT,gBAAS;AACT,cAAO;;AAET,aAAO;OACP;AACF,SAAI,WAAW;MACb,MAAM,EAAE,MAAM,MAAO,GAAG,cAAc;AACtC,mBAAa;OACX,MAAM,KAAK;OACX,GAAG;OACH;OACD;AACD,mBAAa,MAAM,WAAW;;;AAGlC,QAAI,WACF,MAAK,iBAAiB;AAExB,WAAO;;AAET,OAAI,KAAK,KACP,QAAO,iBAAiB,MAAM;IAC5B,MAAM,KAAK;IACX,GAAG,KAAK;IACT,CAAC;AAEJ,UAAO,iBAAiB,KAAK;;AAE/B,OAAK,kBAAkB,EACrB,gBACA,cACA,GAAG,WACC;GACJ,MAAM,oBAAoB;IACxB,MAAM,eAAe;KACnB;KAEA;KACA;KACA;KACD;AACD,iBAAa,SAAS,SAAS;AAC7B,UAAK,MAAM,QAAQ,KAAK,eAAe,MAAM;MAC7C;IACF,MAAM,UAAU,UAAU,KAAK,OAAO,KAAK,eAAe,MAAM;AAChE,iBAAa,SAAS,SAAS;AAC7B,YAAO,KAAK,MAAM;MAClB;AACF,WAAO;;GAET,MAAM,YAAY,cAAc,KAAK,eAAe,KAAK,KAAK,cAAc,KAAK,KAAK;GACtF,MAAM,wBAAwB,KAAK;AACnC,QAAK,wBAAwB,8BAA8B;AACzD,2BAAuB,SAAS;KAChC;AACF,OAAI,aAAa,aAAa,CAC5B,MAAK,MAAM;QACN;IACL,IAAI,EAAE,gBAAgB,mBAAoB,GAAG,gBAAgB;AAC7D,QAAI,gBAAgB;AAClB,mBAAc;MACZ,GAAG;MACH,OAAO;OACL,GAAG,eAAe;OAClB,WAAW,KAAK;OAChB,gBAAgB;QACd,GAAG;QACH,QAAQ,YAAY;QACpB,OAAO;SACL,GAAG,YAAY;SACf,WAAW,KAAK;SAChB,gBAAgB,KAAK;SACrB,WAAW,KAAK;SAChB,KAAK,KAAK;SAEX;QACF;OACF;MACF;AACD,SAAI,YAAY,kBAAkB,KAAK,QAAQ,kBAAkB,MAC/D,aAAY,MAAM,YAAY,KAAK;;AAGvC,gBAAY,MAAM,8BAA8B,sBAAsB,KAAK,QAAQ,6BAA6B;AAChH,SAAK,uBAAuB;AAC5B,SAAK,QAAQ,KAAK,UAAU,YAAY,QACtC,YAAY,YACZ,YAAY,OACZ,EAAE,eAAe,CAClB;;AAEH,QAAK,kBAAkB,KAAK,eAAe;AAC3C,OAAI,CAAC,KAAK,QAAQ,YAAY,KAC5B,MAAK,MAAM;AAEb,UAAO,KAAK;;AAEd,OAAK,0BAA0B,EAC7B,SACA,aACA,oBACA,gBACA,eACA,KACA,GAAG,SACD,EAAE,KAAK;AACT,OAAI,MAAM;IACR,MAAM,eAAe,KAAK,QAAQ,SAAS,MAAM;IACjD,MAAM,SAAS,UAAU,MAAM,EAC7B,aAAa,UAAU,eAAe,eAAe,GACtD,CAAC;AACF,SAAK,KAAK,OAAO;AACjB,SAAK,SAAS,KAAK,QAAQ,YAAY,OAAO,OAAO;AACrD,SAAK,OAAO,OAAO,KAAK,MAAM,EAAE;;GAElC,MAAM,WAAW,KAAK,cAAc;IAClC,GAAG;IACH,wBAAwB;IACzB,CAAC;AACF,UAAO,KAAK,eAAe;IACzB,GAAG;IACH;IACA;IACA;IACA;IACA;IACD,CAAC;;AAEJ,OAAK,YAAY,EAAE,IAAI,gBAAgB,KAAM,GAAG,WAAW;AACzD,OAAI,CAAC,kBAAkB,KACrB,KAAI;AACF,QAAI,IAAI,GAAG,OAAO;AAClB,qBAAiB;WACX;AAGV,OAAI,gBAAgB;AAClB,QAAI,CAAC,KAEH,QADiB,KAAK,cAAc;KAAE;KAAI,GAAG;KAAM,CAAC,CACpC;AAElB,QAAI,KAAK,QACP,QAAO,SAAS,QAAQ,KAAK;QAE7B,QAAO,SAAS,OAAO;AAEzB,WAAO,QAAQ,SAAS;;AAE1B,UAAO,KAAK,uBAAuB;IACjC,GAAG;IACH;IACA;IACA,aAAa;IACd,CAAC;;AAEJ,OAAK,mBAAmB;AACtB,QAAK,eAAe;AACpB,QAAK,sBAAsB;AAC3B,OAAI,KAAK,UAAU;IACjB,MAAM,eAAe,KAAK,cAAc;KACtC,IAAI,KAAK,eAAe;KACxB,QAAQ;KACR,QAAQ;KACR,MAAM;KACN,OAAO;KACP,wBAAwB;KACzB,CAAC;IACF,MAAM,gBAAgB,QAAQ;AAC5B,SAAI;AACF,aAAO,UAAU,UAAU,IAAI,CAAC;aAC1B;AACN,aAAO;;;AAGX,QAAI,SAAS,aAAa,KAAK,eAAe,KAAK,CAAC,KAAK,SAAS,aAAa,aAAa,KAAK,CAAC,EAAE;KAClG,IAAI,OAAO,aAAa;AACxB,SAAI,KAAK,UAAU,KAAK,WAAW,KAAK,OAAO,CAC7C,QAAO,KAAK,QAAQ,KAAK,QAAQ,GAAG,IAAI;AAE1C,WAAM,SAAS,EAAE,MAAM,CAAC;;;GAG5B,MAAM,iBAAiB,KAAK,YAAY,KAAK,eAAe;AAC5D,QAAK,QAAQ,UAAU,OAAO;IAC5B,GAAG;IACH,QAAQ;IACR,YAAY;IACZ,WAAW;IACX,UAAU,KAAK;IACf;IAEA,eAAe,EAAE,cAAc,QAC5B,MAAM,CAAC,eAAe,MAAM,MAAM,EAAE,OAAO,EAAE,GAAG,CAClD;IACF,EAAE;;AAEL,OAAK,OAAO,OAAO,SAAS;GAC1B,IAAI;GACJ,IAAIA;GACJ,IAAI;AACJ,iBAAc,IAAI,SAAS,YAAY;AACrC,SAAK,gBAAgB,YAAY;AAC/B,SAAI;AACF,WAAK,YAAY;MACjB,MAAM,OAAO,KAAK;MAClB,MAAM,eAAe,KAAK,MAAM;AAChC,UAAI,CAAC,KAAK,MAAM,SACd,MAAK,KAAK;OACR,MAAM;OACN,GAAG,sBAAsB;QACvB,kBAAkB;QAClB,UAAU;QACX,CAAC;OACH,CAAC;AAEJ,WAAK,KAAK;OACR,MAAM;OACN,GAAG,sBAAsB;QACvB,kBAAkB;QAClB,UAAU;QACX,CAAC;OACH,CAAC;AACF,YAAM,YAAY;OAChB,QAAQ;OACR,MAAM,MAAM;OACZ,SAAS,KAAK,MAAM;OACpB,UAAU;OACV,aAAa,KAAK;OAElB,SAAS,YAAY;AACnB,aAAK,oBAAoB,YAAY;SACnC,IAAI;SACJ,IAAI;SACJ,IAAI;AACJ,qBAAY;AACV,eAAK,QAAQ,UAAU,MAAM;WAC3B,MAAM,kBAAkB,EAAE;WAC1B,MAAM,aAAa,EAAE,kBAAkB,EAAE;AACzC,4BAAiB,gBAAgB,QAC9B,UAAU,CAAC,WAAW,MAAM,MAAM,EAAE,OAAO,MAAM,GAAG,CACtD;AACD,6BAAkB,WAAW,QAC1B,UAAU,CAAC,gBAAgB,MAAM,MAAM,EAAE,OAAO,MAAM,GAAG,CAC3D;AACD,4BAAiB,gBAAgB,QAC9B,UAAU,WAAW,MAAM,MAAM,EAAE,OAAO,MAAM,GAAG,CACrD;AACD,kBAAO;YACL,GAAG;YACH,WAAW;YACX,UAAU,KAAK,KAAK;YACpB,SAAS;YACT,gBAAgB,KAAK;YACrB,eAAe,CACb,GAAG,EAAE,eACL,GAAG,eAAe,QAAQ,MAAM,EAAE,WAAW,QAAQ,CACtD;YACF;YACD;AACF,eAAK,mBAAmB;WACxB;AACF;UACE,CAAC,gBAAgB,UAAU;UAC3B,CAAC,iBAAiB,UAAU;UAC5B,CAAC,gBAAgB,SAAS;UAC3B,CAAC,SAAS,CAAC,SAAS,UAAU;AAC7B,kBAAQ,SAAS,UAAU;AACzB,gBAAK,gBAAgB,MAAM,SAAS,QAAQ,QAAQ,MAAM;YAC1D;WACF;UACF;;OAEL,CAAC;cACK,KAAK;AACZ,UAAI,WAAW,IAAI,EAAE;AACnB,mBAAY;AACZ,WAAI,CAAC,KAAK,SACR,MAAK,SAAS;QACZ,GAAG,UAAU;QACb,SAAS;QACT,eAAe;QAChB,CAAC;iBAEK,WAAW,IAAI,CACxB,cAAW;AAEb,WAAK,QAAQ,UAAU,OAAO;OAC5B,GAAG;OACH,YAAY,YAAY,UAAU,SAASA,aAAW,MAAM,EAAE,QAAQ,MAAM,MAAM,EAAE,WAAW,QAAQ,GAAG,MAAM;OAChH,UAAU;OACX,EAAE;;AAEL,SAAI,KAAK,sBAAsB,aAAa;AAC1C,WAAK,uBAAuB,SAAS;AACrC,WAAK,oBAAoB,KAAK;AAC9B,WAAK,wBAAwB,KAAK;;AAEpC,cAAS;MACT;KACF;AACF,QAAK,oBAAoB;AACzB,SAAM;AACN,UAAO,KAAK,qBAAqB,gBAAgB,KAAK,kBACpD,OAAM,KAAK;GAEb,IAAI,gBAAgB,KAAK;AACzB,OAAI,KAAK,kBAAkB,CACzB,iBAAgB;YACP,KAAK,QAAQ,MAAM,QAAQ,MAAM,MAAM,EAAE,WAAW,QAAQ,CACrE,iBAAgB;AAElB,OAAI,kBAAkB,KAAK,EACzB,MAAK,QAAQ,UAAU,OAAO;IAC5B,GAAG;IACH,YAAY;IACb,EAAE;;AAGP,OAAK,uBAAuB,OAAO;GACjC,MAAM,uBAAuB,KAAK,wBAAwB,KAAK,QAAQ;AACvE,UAAO,KAAK;AACZ,OAAI,wBAAwB,OAAO,aAAa,eAAe,yBAAyB,YAAY,OAAO,SAAS,wBAAwB,YAAY;IACtJ,IAAI;AACJ,QAAI,OAAO,yBAAyB,YAAY,KAAK,gCAAgC;KACnF,MAAM,OAAO,KAAK;KAClB,MAAM,eAAe,KAAK,MAAM;KAChC,MAAM,8BAA8B,OAAO,qBAAqB,UAAU,aAAa,qBAAqB,MAC1G,sBAAsB;MACpB,kBAAkB;MAClB,UAAU;MACX,CAAC,CACH,GAAG,qBAAqB;AACzB,SAAI,gCAAgC,OAAO;AACzC,UAAI;AACJ;;AAEF,iCAA4B;MAC1B,QAAQ;MACR,OAAO;MACR;UAED,6BAA4B;AAE9B,aAAS,oBAAoB,0BAA0B;SAEvD,KAAI;;AAGR,OAAK,eAAe,IAAI,YAAY;GAClC,MAAM,aAAa,KAAK,MAAM,gBAAgB,MAAM,MAAM,EAAE,OAAO,GAAG,GAAG,mBAAmB,KAAK,MAAM,QAAQ,MAAM,MAAM,EAAE,OAAO,GAAG,GAAG,YAAY,KAAK,MAAM,cAAc,MAAM,MAAM,EAAE,OAAO,GAAG,GAAG,kBAAkB;AAC5N,OAAI,WACF,MAAK,QAAQ,UAAU,OAAO;IAC5B,GAAG;KACF,aAAa,EAAE,aAAa,KAAK,MAAM,EAAE,OAAO,KAAK,QAAQ,EAAE,GAAG,EAAE;IACtE,EAAE;;AAGP,OAAK,YAAY,YAAY;GAC3B,MAAM,UAAU,MAAM,EAAE,OAAO;AAC/B,UAAO,KAAK,MAAM,cAAc,KAAK,OAAO,IAAI,KAAK,MAAM,gBAAgB,KAAK,OAAO,IAAI,KAAK,MAAM,QAAQ,KAAK,OAAO;;AAE5H,OAAK,cAAc,SAAS;GAC1B,MAAM,cAAc,MAAM;AACxB,QAAI,MAAM,SAAS,EAAE,IAAI,KACvB,QAAO;KACL,GAAG;KACH,SAAS;KACT,GAAG,MAAM,gBAAgB,EAAE,WAAW,UAAU;MAAE,QAAQ;MAAW,OAAO,KAAK;MAAG,GAAG,KAAK;KAC7F;AAEH,WAAO;;AAET,QAAK,QAAQ,UAAU,OAAO;IAC5B,GAAG;IACH,SAAS,EAAE,QAAQ,IAAI,WAAW;IAClC,eAAe,EAAE,cAAc,IAAI,WAAW;IAC9C,gBAAgB,EAAE,gBAAgB,IAAI,WAAW;IAClD,EAAE;AACH,QAAK,uBAAuB;AAC5B,UAAO,KAAK,KAAK,EAAE,MAAM,MAAM,MAAM,CAAC;;AAExC,OAAK,mBAAmB,cAAc;AACpC,OAAI,CAAC,UAAU,QAAQ,MAAM;IAC3B,MAAM,WAAW,KAAK,cAAc,UAAU,QAAQ;IACtD,IAAI,OAAO,SAAS;AACpB,QAAI,KAAK,UAAU,KAAK,WAAW,KAAK,OAAO,CAC7C,QAAO,KAAK,QAAQ,KAAK,QAAQ,GAAG,IAAI;AAE1C,cAAU,QAAQ,OAAO,SAAS;AAClC,cAAU,QAAQ,IAAI,YAAY,KAAK;;AAEzC,OAAI,CAAC,UAAU,QAAQ,IAAI,WAAW,CACpC,WAAU,QAAQ,IAAI,YAAY,UAAU,QAAQ,KAAK;AAE3D,UAAO;;AAET,OAAK,cAAc,SAAS;GAC1B,MAAM,SAAS,MAAM;AACrB,OAAI,WAAW,KAAK,EAClB,MAAK,QAAQ,UAAU,MAAM;AAC3B,WAAO;KACL,GAAG;KACH,eAAe,EAAE,cAAc,QAC5B,MAAM,CAAC,OAAO,EAAE,CAClB;KACF;KACD;OAEF,MAAK,QAAQ,UAAU,MAAM;AAC3B,WAAO;KACL,GAAG;KACH,eAAe,EAAE;KAClB;KACD;;AAGN,OAAK,0BAA0B;GAC7B,MAAM,UAAU,MAAM;IACpB,MAAM,QAAQ,KAAK,gBAAgB,EAAE;AACrC,QAAI,CAAC,MAAM,QAAQ,OACjB,QAAO;IAET,MAAM,UAAU,EAAE,UAAU,MAAM,QAAQ,iBAAiB,KAAK,QAAQ,uBAAuB,MAAM,QAAQ,UAAU,KAAK,QAAQ,kBAAkB,MAAS;AAE/J,QADgB,EAAE,WAAW,QAChB,QAAO;AAEpB,WADmB,KAAK,KAAK,GAAG,EAAE,aAAa;;AAGjD,QAAK,WAAW,EAAE,QAAQ,CAAC;;AAE7B,OAAK,iBAAiB;AACtB,OAAK,eAAe,OAAO,SAAS;GAClC,MAAM,OAAO,KAAK,cAAc,KAAK;GACrC,IAAI,UAAU,KAAK,YAAY,MAAM;IACnC,cAAc;IACd,SAAS;IACT,MAAM;IACP,CAAC;GACF,MAAM,iBAAiB,IAAI,IACzB,CAAC,GAAG,KAAK,MAAM,SAAS,GAAG,KAAK,MAAM,kBAAkB,EAAE,CAAC,CAAC,KACzD,MAAM,EAAE,GACV,CACF;GACD,MAAM,iCAAiC,IAAI,IAAI,CAC7C,GAAG,gBACH,GAAG,KAAK,MAAM,cAAc,KAAK,MAAM,EAAE,GAAG,CAC7C,CAAC;AACF,eAAY;AACV,YAAQ,SAAS,UAAU;AACzB,SAAI,CAAC,eAAe,IAAI,MAAM,GAAG,CAC/B,MAAK,QAAQ,UAAU,OAAO;MAC5B,GAAG;MACH,eAAe,CAAC,GAAG,EAAE,eAAe,MAAM;MAC3C,EAAE;MAEL;KACF;AACF,OAAI;AACF,cAAU,MAAM,YAAY;KAC1B,QAAQ;KACR;KACA,UAAU;KACV,SAAS;KACT,cAAc,IAAI,YAAY;AAC5B,UAAI,eAAe,IAAI,GAAG,CACxB,WAAU,QAAQ,KAAK,MAAM,EAAE,OAAO,KAAK,QAAQ,EAAE,GAAG,EAAE;UAE1D,MAAK,YAAY,IAAI,QAAQ;;KAGlC,CAAC;AACF,WAAO;YACA,KAAK;AACZ,QAAI,WAAW,IAAI,EAAE;AACnB,SAAI,IAAI,QAAQ,eACd;AAEF,YAAO,MAAM,KAAK,aAAa;MAC7B,GAAG,IAAI;MACP,eAAe;MAChB,CAAC;;AAEJ,QAAI,CAAC,WAAW,IAAI,CAClB,SAAQ,MAAM,IAAI;AAEpB;;;AAGJ,OAAK,cAAc,UAAU,SAAS;GACpC,MAAM,gBAAgB;IACpB,GAAG;IACH,IAAI,SAAS,KAAK,KAAK,oBACrB,SAAS,QAAQ,IACjB,SAAS,GACV,GAAG,KAAK;IACT,QAAQ,SAAS,UAAU,EAAE;IAC7B,aAAa;IACd;GACD,MAAM,OAAO,KAAK,cAAc,cAAc;AAC9C,OAAI,MAAM,WAAW,KAAK,MAAM,WAAW,UACzC,QAAO;GAGT,MAAM,gBADU,MAAM,YAAY,KAAK,IAAI,CAAC,KAAK,MAAM,YAAY,KAAK,WACzC,KAAK,iBAAiB,KAAK,MAAM,oBAAoB,KAAK,MAAM;GAC/F,MAAM,QAAQ,cACZ,aAAa,UACb;IACE,GAAG;IACH,IAAI,KAAK;IACV,EACD,KAAK,mBACN;AACD,OAAI,CAAC,MACH,QAAO;AAET,OAAI,SAAS,QACX;QAAI,CAAC,UAAU,OAAO,SAAS,QAAQ,EAAE,SAAS,MAAM,CAAC,CACvD,QAAO;;AAGX,OAAI,UAAU,MAAM,iBAAiB,MACnC,QAAO,UAAU,aAAa,QAAQ,KAAK,QAAQ,EAAE,SAAS,MAAM,CAAC,GAAG,QAAQ;AAElF,UAAO;;AAET,OAAK,yBAAyB;AAC5B,UAAO,KAAK,QAAQ,MAAM,QAAQ,MAC/B,MAAM,EAAE,WAAW,cAAc,EAAE,eACrC;;AAEH,OAAK,OAAO;GACV,qBAAqB;GACrB,kBAAkB;GAClB,qBAAqB;GACrB,SAAS,KAAK;GACd,GAAG;GACH,eAAe,QAAQ,iBAAiB;GACxC,cAAc,QAAQ,gBAAgB;GACtC,iBAAiB,QAAQ,mBAAmB;GAC5C,aAAa,QAAQ,eAAe;GACrC,CAAC;AACF,MAAI,OAAO,aAAa,YACtB,MAAK,iBAAiB;;CAG1B,UAAU;AACR,SAAO,CAAC,CAAC,KAAK,QAAQ;;CAExB,iBAAiB;AACf,SAAO,CAAC,CAAC,KAAK,QAAQ;;CAExB,IAAI,QAAQ;AACV,SAAO,KAAK,QAAQ;;CAEtB,IAAI,kBAAkB;AACpB,SAAO,KAAK;;CAEd,oBAAoB,MAAM,MAAM;EAC9B,MAAM,EAAE,YAAY,eAAe,gBAAgB,KAAK,iBACtD,KAAK,UACL,MAAM,MAAM,GACb;EACD,IAAI,mBAAmB;AACvB,MAEE,aAAa,WAAW,SAAS,OAAO,YAAY,QAElD,cAAc,KAAK,SAAS,CAG9B,KAAI,KAAK,QAAQ,cACf,eAAc,KAAK,KAAK,QAAQ,cAAc;MAE9C,oBAAmB;EAGvB,MAAM,+BAA+B;AACnC,OAAI,CAAC,iBACH;AAEF,OAAI,KAAK,QAAQ,iBAAiB,OAChC,MAAK,IAAI,IAAI,cAAc,SAAS,GAAG,KAAK,GAAG,KAAK;IAClD,MAAM,QAAQ,cAAc;AAC5B,QAAI,MAAM,SACR,QAAO,MAAM;;AAInB,UAAO;MACL;EACJ,MAAM,UAAU,EAAE;EAClB,MAAM,oBAAoB,gBAAgB;AAGxC,UADsB,CADA,aAAa,KACI,KAAK,QAAQ,WAAW,KAAK,IAAI,YAAY,WAAW,KAAK,QAAQ,WAAW,KAAK;;AAG9H,gBAAc,SAAS,OAAO,UAAU;GACtC,MAAM,cAAc,QAAQ,QAAQ;GACpC,MAAM,CAAC,gBAAgB,mBAAmB,sBAAsB;IAC9D,MAAM,eAAe,aAAa,UAAU,KAAK;IACjD,MAAM,qBAAqB,aAAa,iBAAiB,KAAK;AAC9D,QAAI;KACF,MAAM,eAAe,eAAe,MAAM,QAAQ,gBAAgB,EAAE,GAAG,cAAc,CAAC,IAAI,KAAK;AAC/F,YAAO;MACL;OACE,GAAG;OACH,GAAG;OACJ;MACD;OAAE,GAAG;OAAoB,GAAG;OAAc;MAC1C,KAAK;MACN;aACM,KAAK;KACZ,IAAI,mBAAmB;AACvB,SAAI,EAAE,eAAe,kBACnB,oBAAmB,IAAI,iBAAiB,IAAI,SAAS,EACnD,OAAO,KACR,CAAC;AAEJ,SAAI,MAAM,aACR,OAAM;AAER,YAAO;MAAC;MAAc,EAAE;MAAE;MAAiB;;OAE3C;GACJ,MAAM,aAAa,MAAM,QAAQ,aAAa,EAC5C,QAAQ,gBACT,CAAC,IAAI;GACN,MAAM,iBAAiB,aAAa,KAAK,UAAU,WAAW,GAAG;GACjE,MAAM,EAAE,kBAAkB,eAAe,gBAAgB;IACvD,MAAM,MAAM;IACZ,QAAQ;IACR,eAAe,KAAK;IACrB,CAAC;GACF,MAAM,UAAU,gBAAgB;IAC9B,MAAM,MAAM;IACZ,QAAQ;IACR,gBAAgB;IAChB,eAAe,KAAK;IACpB,YAAY,KAAK;IAClB,CAAC,CAAC,mBAAmB;GACtB,MAAM,gBAAgB,KAAK,SAAS,QAAQ;GAC5C,MAAM,gBAAgB,KAAK,MAAM,QAAQ,MACtC,MAAM,EAAE,YAAY,MAAM,GAC5B;GACD,MAAM,eAAe,eAAe,iBAAiB;GACrD,IAAI,cAAc,KAAK;AACvB,OAAI,CAAC,eAAe;IAClB,MAAM,oBAAoB,MAAM,QAAQ,QAAQ,SAAS,MAAM,QAAQ;AACvE,QAAI,kBACF,KAAI;AACF,YAAO,OACL,cACA,kBAAkB,aAAa,CAChC;aACM,KAAK;AACZ,mBAAc,IAAI,eAAe,IAAI,SAAS,EAC5C,OAAO,KACR,CAAC;AACF,SAAI,MAAM,aACR,OAAM;;;AAKd,UAAO,OAAO,aAAa,aAAa;GACxC,MAAM,QAAQ,gBAAgB,SAAS;GACvC,IAAI;AACJ,OAAI,cACF,SAAQ;IACN,GAAG;IACH;IACA,QAAQ,gBAAgB,iBAAiB,cAAc,QAAQ,YAAY,GAAG;IAC9E,eAAe;IACf,QAAQ,gBAAgB,iBAAiB,cAAc,QAAQ,eAAe,GAAG,iBAAiB,cAAc,QAAQ,eAAe;IACvI,eAAe;IAChB;QACI;IACL,MAAM,SAAS,MAAM,QAAQ,UAAU,MAAM,QAAQ,cAAc,MAAM,UAAU,kBAAkB,MAAM,GAAG,YAAY;AAC1H,YAAQ;KACN,IAAI;KACJ;KACA,SAAS,MAAM;KACf,QAAQ,gBAAgB,iBAAiB,cAAc,QAAQ,YAAY,GAAG;KAC9E,eAAe;KACf,UAAU;KACV,WAAW,KAAK,KAAK;KACrB,QAAQ,gBAAgB,iBAAiB,cAAc,QAAQ,eAAe,GAAG;KACjF,eAAe;KACf,aAAa,KAAK;KAClB;KACA,YAAY;KACZ,OAAO,KAAK;KACZ;KACA,gBAAgB,KAAK;KACrB,cAAc,EACZ,aAAa,yBAAyB,EACvC;KACD,qBAAqB,KAAK;KAC1B,SAAS,EAAE;KACX,iBAAiB,IAAI,iBAAiB;KACtC,YAAY;KACZ;KACA,YAAY,gBAAgB,iBAAiB,cAAc,YAAY,WAAW,GAAG;KACrF,SAAS;KACT,SAAS;KACT,OAAO,KAAK;KACZ,SAAS,KAAK;KACd,aAAa,KAAK;KAClB,MAAM,KAAK;KACX,YAAY,MAAM,QAAQ,cAAc,EAAE;KAC1C,UAAU,MAAM;KACjB;;AAEH,OAAI,CAAC,MAAM,QACT,OAAM,iBAAiB,0BAA0B,MAAM;AAEzD,SAAM,cAAc;AAEpB,SAAM,UAAU;IACd,GAFoB,iBAAiB,YAAY;IAGjD,GAAG,MAAM;IACT,GAAG,MAAM;IACV;AACD,WAAQ,KAAK,MAAM;IACnB;AACF,UAAQ,SAAS,OAAO,UAAU;GAChC,MAAM,QAAQ,KAAK,gBAAgB,MAAM;AAEzC,OAAI,CADkB,KAAK,SAAS,MAAM,GAAG,IACvB,MAAM,mBAAmB,MAAM;IACnD,MAAM,cAAc,QAAQ,QAAQ;IACpC,MAAM,gBAAgB,iBAAiB,YAAY;AACnD,QAAI,MAAM,QAAQ,SAAS;KACzB,MAAM,mBAAmB;MACvB,MAAM,MAAM;MACZ,QAAQ,MAAM;MACd,SAAS,iBAAiB,EAAE;MAC5B,UAAU;MACV,WAAW,UAAU,KAAK,SAAS;OAAE,GAAG;OAAO,eAAe;OAAM,CAAC;MACrE,eAAe,KAAK;MACpB,OAAO,MAAM;MACb,iBAAiB,MAAM;MACvB,SAAS,CAAC,CAAC,MAAM;MACjB;MACD;AACD,WAAM,iBAAiB,MAAM,QAAQ,QAAQ,iBAAiB,IAAI,KAAK;;AAEzE,UAAM,UAAU;KACd,GAAG;KACH,GAAG,MAAM;KACT,GAAG,MAAM;KACV;;IAEH;AACF,SAAO;;;AAGX,IAAM,mBAAN,cAA+B,MAAM;AAErC,IAAM,iBAAN,cAA6B,MAAM;AAEnC,IAAM,aAAa,QAAQ,IAAI,SAAS,IAAI,IAAI,IAAI,SAAS,IAAI,IAAI,MAAM,GAAG,GAAG,GAAG;AACpF,SAAS,aAAa,GAAG,GAAG;AAC1B,QAAO,UAAU,EAAE,KAAK,UAAU,EAAE;;AAEtC,SAAS,OAAO,IAAI,KAAK;AACvB,QAAO,OAAO,GAAG,SAAS;AAExB,UADiB,MAAM,IAAI,EACX,OAAO,WAAW,GAAG,KAAK;;;AAG9C,SAAS,sBAAsB,UAAU;AACvC,QAAO;EACL,UAAU;EACV,WAAW;EACX,iBAAiB;EACjB,QAAQ;EACR,kBAAkB,KAAK;EACvB;EACA,SAAS,EAAE;EACX,gBAAgB,EAAE;EAClB,eAAe,EAAE;EACjB,YAAY;EACb;;AAEH,SAAS,eAAe,iBAAiB,OAAO;AAC9C,KAAI,mBAAmB,KAAM,QAAO,EAAE;AACtC,KAAI,eAAe,iBAAiB;EAClC,MAAM,SAAS,gBAAgB,aAAa,SAAS,MAAM;AAC3D,MAAI,kBAAkB,QACpB,OAAM,IAAI,iBAAiB,iCAAiC;AAC9D,MAAI,OAAO,OACT,OAAM,IAAI,iBAAiB,KAAK,UAAU,OAAO,QAAQ,KAAK,GAAG,EAAE,EAAE,EACnE,OAAO,QACR,CAAC;AACJ,SAAO,OAAO;;AAEhB,KAAI,WAAW,gBACb,QAAO,gBAAgB,MAAM,MAAM;AAErC,KAAI,OAAO,oBAAoB,WAC7B,QAAO,gBAAgB,MAAM;AAE/B,QAAO,EAAE;;AAEX,SAAS,iBAAiB,EACxB,UACA,eACA,eACA,cACA,YACA,YACA,cACC;CACD,IAAI,cAAc,EAAE;CACpB,MAAM,cAAc,cAAc,SAAS;CAC3C,MAAM,oBAAoB,UAAU;AAWlC,SAVe,cACb,aACA;GACE,IAAI,MAAM;GACV,eAAe,MAAM,SAAS,iBAAiB;GAE/C,OAAO;GACR,EACD,WACD;;CAGH,IAAI,aAAa,kBAAkB,KAAK,IAAI,aAAa,iBAAiB,KAAK;AAC/E,KAAI,WACF,eAAc,iBAAiB,WAAW;MACrC;EACL,IAAI,aAAa,KAAK;AACtB,OAAK,MAAM,SAAS,YAAY;GAC9B,MAAM,gBAAgB,iBAAiB,MAAM;AAC7C,OAAI,cACF,KAAI,MAAM,SAAS,OAAO,cAAc,OACtC;QAAI,CAAC,WACH,cAAa;KAAE,YAAY;KAAO,aAAa;KAAe;UAE3D;AACL,iBAAa;AACb,kBAAc;AACd;;;AAIN,MAAI,CAAC,cAAc,YAAY;AAC7B,gBAAa,WAAW;AACxB,iBAAc,WAAW;;;CAG7B,IAAI,cAAc,cAAc,WAAW;CAC3C,MAAM,gBAAgB,CAAC,YAAY;AACnC,QAAO,YAAY,aAAa;AAC9B,gBAAc,YAAY;AAC1B,gBAAc,KAAK,YAAY;;AAEjC,eAAc,SAAS;AACvB,QAAO;EAAE;EAAe;EAAa;EAAY;;AAEnD,SAAS,sBAAsB,EAC7B,QACA,MACA,YACA,0BACC;CACD,MAAM,iBAAiB,WAAW,QAC/B,KAAK,UAAU;EACd,MAAM,cAAc,EAAE;AACtB,MAAI,YAAY,MAAM,SACpB;OAAI,MAAM,QAAQ,QAAQ,YACxB,aAAY,KAAK,GAAG,MAAM,QAAQ,OAAO,YAAY;aAE9C,MAAM,QAAQ,oBAAoB,MAAM,QAAQ,mBAAmB;GAC5E,MAAM,oBAAoB,EACxB,QAAQ,SACR,WACI;IACJ,IAAI,aAAa;AACjB,QAAI,sBAAsB,MAAM,WAAW,MAAM,QAAQ,iBACvD,cAAa,MAAM,QAAQ,iBAAiB,QACzC,MAAM,UAAU,MAAM,KAAK,EAC5B,QACD;IAEH,MAAM,SAAS,KAAK,WAAW;AAC/B,QAAI,uBAAuB,MAAM,WAAW,MAAM,QAAQ,kBACxD,QAAO,MAAM,QAAQ,kBAAkB,QACpC,MAAM,UAAU,MAAM,KAAK,EAC5B,OACD;AAEH,WAAO;;AAET,eAAY,KAAK,iBAAiB;;AAEpC,MAAI,0BAA0B,MAAM,QAAQ,gBAAgB;GAC1D,MAAM,YAAY,EAAE,QAAQ,SAAS,WAAW;IAC9C,MAAM,SAAS,KAAK,QAAQ;AAC5B,QAAI;AAKF,YAJwB;MACtB,GAAG;MACH,GAAG,eAAe,MAAM,QAAQ,gBAAgB,OAAO,IAAI,KAAK;MACjE;YAEK;AACN,YAAO;;;AAGX,eAAY,KAAK,SAAS;;AAE5B,SAAO,IAAI,OAAO,YAAY;IAEhC,EAAE,CACH,IAAI,EAAE;CACP,MAAM,SAAS,EAAE,QAAQ,cAAc;AACrC,MAAI,CAAC,KAAK,OACR,QAAO,EAAE;AAEX,MAAI,KAAK,WAAW,KAClB,QAAO;AAET,SAAO,iBAAiB,KAAK,QAAQ,QAAQ;;AAE/C,gBAAe,KAAK,MAAM;CAC1B,MAAM,aAAa,OAAO,kBAAkB;AAC1C,MAAI,SAAS,eAAe,OAC1B,QAAO;EAET,MAAM,aAAa,eAAe;EAClC,MAAM,QAAQ,cAAc;AAC1B,UAAO,UAAU,QAAQ,GAAG,UAAU;;AAExC,SAAO,WAAW;GAAE,QAAQ;GAAe;GAAM,CAAC;;AAEpD,QAAO,UAAU,GAAG,OAAO;;;;;ACjzC7B,IAAM,uBAAuB,OAAO,IAAI,uBAAuB;AAC/D,SAAS,MAAM,UAAU,SAAS;CAChC,MAAM,UAAU;AAChB,KAAI,QAAQ,sBACV,QAAO;AAET,SAAQ,wBAAwB,EAAE,QAAQ,WAAW;AACrD,SAAQ,MAAM,SAAS;AACrB,UAAQ,sBAAsB,SAAS;AACvC,UAAQ,sBAAsB,OAAO;GACrC,CAAC,OAAO,UAAU;AAClB,UAAQ,sBAAsB,SAAS;AACvC,UAAQ,sBAAsB,QAAQ;GACpC,OAAO,SAAS,kBAAkB,uBAAuB,MAAM;GAC/D,iBAAiB;GAClB;GACD;AACF,QAAO;;;;;AClBT,IAAM,iBAAiB;;;;ACAvB,IAAM,WAAW,OAAO,SAAS;CAC/B,MAAM,QAAQ,KAAK,MAAM,IAAI;CAC7B,IAAI;CACJ,IAAI,IAAI;CACR,IAAI,QAAQ;AACZ,SAAQ,OAAO,MAAM,SAAS,QAAQ,SAAS,KAC7C,SAAQ,MAAM;AAEhB,QAAO,SAAS;;;;;ACJlB,IAAM,YAAN,MAAgB;CACd,YAAY,SAAS;AACnB,OAAK,QAAQ,SAAS;AACpB,QAAK,gBAAgB,KAAK;GAC1B,MAAM,WAAW,KAAK;GACtB,MAAM,SAAS,CAAC,UAAU,QAAQ,CAAC,UAAU;AAC7C,QAAK,cAAc,KAAK,QAAQ,kBAAkB;AAClD,OAAI,OACF,MAAK,QAAQ;YACJ,CAAC,KAAK,YACf,WACE,OACA,8GACD;GAEH,IAAI,OAAO,SAAS,cAAc,UAAU;AAC5C,OAAI,QAAQ,SAAS,IACnB,QAAO,aAAa,KAAK;GAE3B,MAAM,WAAW,UAAU,MAAM;GACjC,IAAI,KAAK,SAAS,cAAc,UAAU,CACxC,KAAK,YAAY,OAAO,cAAc,KAAK,KAAK,YAAY,IAC5D,SACD,CAAC;AACF,OAAI,SAAS,YACX,QAAO;AAET,OAAI,OAAO,YACT,MAAK,UAAU,CAAC,KAAK,GAAG,CAAC;GAE3B,MAAM,WAAW,OAAO,cAAc,MAAM,UAAU,CAAC,KAAK,YAAY,UAAU,KAAK,CAAC;AACxF,QAAK,QAAQ;AACb,QAAK,MAAM;AACX,QAAK,YAAY;AACjB,QAAK,MAAM;;AAEb,OAAK,SAAS,UAAU;AACtB,QAAK,QAAQ,MAAM;AACnB,QAAK,MAAM,MAAM;AACjB,QAAK,YAAY,MAAM;AACvB,QAAK,MAAM,MAAM;AACjB,QAAK,QAAQ,iBAAiB,MAAM,QAAQ;AAC5C,QAAK,WAAW,MAAM;;AAExB,OAAK,eAAe,aAAa;AAC/B,UAAO,KAAK,iBAAiB,SAAS;;AAExC,OAAK,oBAAoB,aAAa;AACpC,OAAI,MAAM,QAAQ,SAAS,CACzB,MAAK,WAAW;AAElB,OAAI,OAAO,aAAa,YAAY,aAAa,KAC/C,MAAK,WAAW,OAAO,OAAO,SAAS;AAEzC,UAAO;;AAET,OAAK,sBAAsB;AACzB,UAAO;;AAET,OAAK,gBAAgB,aAAa;AAChC,UAAO,OAAO,KAAK,SAAS,SAAS;AACrC,UAAO;;AAET,OAAK,UAAU,aAAa;AAC1B,UAAO,OAAO,KAAK,SAAS,SAAS;AACrC,UAAO;;AAET,OAAK,QAAQ,aAAW;AACtB,QAAK,SAASC;AACd,UAAO;;AAET,OAAK,UAAU,WAAW,EAAE;AAC5B,OAAK,SAAS,CAAC,SAAS;AACxB,MAAI,SAAS,MAAM,SAAS,KAC1B,OAAM,IAAI,MAAM,sDAAsD;;CAG1E,IAAI,KAAK;AACP,SAAO,KAAK;;CAEd,IAAI,KAAK;AACP,SAAO,KAAK;;CAEd,IAAI,OAAO;AACT,SAAO,KAAK;;CAEd,IAAI,WAAW;AACb,SAAO,KAAK;;;AAGhB,IAAM,eAAN,MAAmB;CACjB,YAAY,EAAE,MAAM;AAClB,OAAK,YAAY,SAAS;AACxB,UAAO,SAAS;IAAE,SAAS,KAAK;IAAI,GAAG;IAAM,CAAC;;AAEhD,OAAK,KAAK;;;AAGd,IAAM,gBAAN,cAA4B,UAAU;CACpC,YAAY,SAAS;AACnB,QAAM,QAAQ;;;;;;ACxGlB,IAAM,sBAAsB,YAAY;AACtC,QAAO;EACL,uBAAuB,QAAQ;EAC/B,YAAY,QAAQ;EACrB;;;;;ACHH,SAAS,mBAAmB,MAAM;AAChC,SAAQ,EAAE,QAAQ,WAAW;EAC3B,MAAM,SAAS,KAAK,OAAO;AAC3B,MAAI,SAAS,KACX,QAAO;GAAE,GAAG;GAAQ,GAAG;GAAQ;AAEjC,OAAK,SAAS,QAAQ;AACpB,OAAI,EAAE,OAAO,QACX,QAAO,OAAO,OAAO;IAEvB;AACF,SAAO;;;AAGX,SAAS,kBAAkB,OAAO;AAChC,SAAQ,EAAE,QAAQ,WAAW;AAC3B,MAAI,UAAU,KACZ,QAAO,EAAE;EAEX,MAAM,SAAS,KAAK,OAAO;AAC3B,MAAI,MAAM,QAAQ,MAAM,CACtB,OAAM,SAAS,QAAQ;AACrB,UAAO,OAAO;IACd;MAEF,QAAO,QAAQ,MAAM,CAAC,SACnB,CAAC,KAAK,WAAW;AAChB,OAAI,UAAU,OAAO,MAAM,MAAM,CAC/B,QAAO,OAAO;IAGnB;AAEH,SAAO;;;;;;ACwDX,IAAI,iBAAiB;AACrB,IAAI,4BAA4B;AAChC,IAAI,mBAAmB,QAAQ;AAmB/B,IAAI,gCAAgC,IAAI,KAAK;AAoB7C,IAAI,OAAO,eAAe,YACxB,QAAO,eAAe,YAAY,gBAAgB;CAChD,OAAO;CACP,cAAc;CACd,UAAU;CACV,YAAY;CACb,CAAC;SACO,OAAO,WAAW,YAC3B,QAAO,eAAe,QAAQ,gBAAgB;CAC5C,OAAO;CACP,cAAc;CACd,UAAU;CACV,YAAY;CACb,CAAC;SACO,OAAO,SAAS,YACzB,QAAO,eAAe,MAAM,gBAAgB;CAC1C,OAAO;CACP,cAAc;CACd,UAAU;CACV,YAAY;CACb,CAAC;SACO,OAAO,WAAW,YAC3B,QAAO,eAAe,QAAQ,gBAAgB;CAC5C,OAAO;CACP,cAAc;CACd,UAAU;CACV,YAAY;CACb,CAAC;AA2CJ,IAAI,iBAAiB;EAClB,OAAO,gBAAgB;EACvB,OAAO,cAAc;EACrB,OAAO,qBAAqB;EAC5B,OAAO,WAAW;EAClB,OAAO,QAAQ;EACf,OAAO,WAAW;EAClB,OAAO,UAAU;EACjB,OAAO,SAAS;EAChB,OAAO,UAAU;EACjB,OAAO,QAAQ;EACf,OAAO,cAAc;EACrB,OAAO,cAAc;EACrB,OAAO,cAAc;CACvB;AA0BD,IAAI,eAAe;EAChB,IAAe;EACf,IAAgB;EAChB,IAAoB,KAAK;EACzB,IAAe;EACf,IAAkB;EAClB,IAAc,OAAO;EACrB,IAAiB,OAAO;EACxB,IAAc;CAChB;AAuiBD,IAAI,EAAE,UAAU,mBAAmB,OAAO;AA4vF1C,IAAI,kBAAkB;AACtB,IAAI,sBAAsB,gBAAgB;AAC1C,IAAI,YAAY;AAChB,IAAI,gBAAgB,UAAU;;;;AC9hH9B,SAAS,2BAA2B,MAAM;AACxC,QAAO;;;;;;;ACAT,SAAS,WAAW,EAClB,SAAS,YACR;CACD,MAAM,UAAU,MAAM,SAAS;AAC/B,KAAI,QAAQ,sBAAsB,WAAW,UAC3C,OAAM;AAER,KAAI,QAAQ,sBAAsB,WAAW,QAC3C,OAAM,QAAQ,sBAAsB;AAEtC,QAAO,CAAC,QAAQ,sBAAsB,MAAM,QAAQ;;AAEtD,SAAS,MAAM,OAAO;CACpB,MAAM,QAAwB,4CAAI,YAAY,EAAE,GAAG,OAAO,CAAC;AAC3D,KAAI,MAAM,SACR,QAAuB,yDAAU,UAAU;EAAE,UAAU,MAAM;EAAU,UAAU;EAAO,CAAC;AAE3F,QAAO;;AAET,SAAS,WAAW,OAAO;CACzB,MAAM,CAAC,QAAQ,WAAW,MAAM;AAChC,QAAO,MAAM,SAAS,KAAK;;;;;ACtB7B,SAAS,cAAc,OAAO;CAC5B,MAAM,iBAAiB,MAAM,kBAAkB;AAC/C,QAAuB,4CACrB,mBACA;EACE,aAAa,MAAM;EACnB,SAAS,MAAM;EACf,WAAW,EAAE,OAAO,YAAY;AAC9B,OAAI,MACF,qBAAa,cAAc,gBAAgB;IACzC;IACA;IACD,CAAC;AAEJ,UAAO,MAAM;;EAEhB,CACF;;AAEH,IAAM,oBAAN,2BAAsC,UAAU;CAC9C,cAAc;AACZ,QAAM,GAAG,UAAU;AACnB,OAAK,QAAQ,EAAE,OAAO,MAAM;;CAE9B,OAAO,yBAAyB,OAAO;AACrC,SAAO,EAAE,UAAU,MAAM,aAAa,EAAE;;CAE1C,OAAO,yBAAyB,OAAO;AACrC,SAAO,EAAE,OAAO;;CAElB,QAAQ;AACN,OAAK,SAAS,EAAE,OAAO,MAAM,CAAC;;CAEhC,mBAAmB,WAAW,WAAW;AACvC,MAAI,UAAU,SAAS,UAAU,aAAa,KAAK,MAAM,SACvD,MAAK,OAAO;;CAGhB,kBAAkB,OAAO,WAAW;AAClC,MAAI,KAAK,MAAM,QACb,MAAK,MAAM,QAAQ,OAAO,UAAU;;CAGxC,SAAS;AACP,SAAO,KAAK,MAAM,SAAS;GACzB,OAAO,KAAK,MAAM,aAAa,KAAK,MAAM,aAAa,GAAG,OAAO,KAAK,MAAM;GAC5E,aAAa;AACX,SAAK,OAAO;;GAEf,CAAC;;;AAGN,SAAS,eAAe,EAAE,SAAS;CACjC,MAAM,CAAC,MAAM,wBAAiB,SAAS,KAAsC;AAC7E,QAAuB,6CAAK,OAAO;EAAE,OAAO;GAAE,SAAS;GAAS,UAAU;GAAQ;EAAE,UAAU;GAC5E,6CAAK,OAAO;IAAE,OAAO;KAAE,SAAS;KAAQ,YAAY;KAAU,KAAK;KAAS;IAAE,UAAU,CACtF,4CAAI,UAAU;KAAE,OAAO,EAAE,UAAU,QAAQ;KAAE,UAAU;KAAyB,CAAC,EACjF,4CACd,UACA;KACE,OAAO;MACL,YAAY;MACZ,UAAU;MACV,QAAQ;MACR,SAAS;MACT,YAAY;MACZ,cAAc;MACf;KACD,eAAe,SAAS,MAAM,CAAC,EAAE;KACjC,UAAU,OAAO,eAAe;KACjC,CACF,CACF;IAAE,CAAC;GACY,4CAAI,OAAO,EAAE,OAAO,EAAE,QAAQ,UAAU,EAAE,CAAC;GAC3D,OAAuB,4CAAI,OAAO,EAAE,UAA0B,4CAC5D,OACA;IACE,OAAO;KACL,UAAU;KACV,QAAQ;KACR,cAAc;KACd,SAAS;KACT,OAAO;KACP,UAAU;KACX;IACD,UAAU,MAAM,UAA0B,4CAAI,QAAQ,EAAE,UAAU,MAAM,SAAS,CAAC,GAAG;IACtF,CACF,EAAE,CAAC,GAAG;GACR;EAAE,CAAC;;;;;ACxFN,SAAS,WAAW,EAAE,UAAU,WAAW,QAAQ;AACjD,QAAO,aAAa,GAAmB,yDAAmB,UAAU,EAAE,UAAU,CAAC,GAAmB,yDAAmB,UAAU,EAAE,UAAU,UAAU,CAAC;;AAE1J,SAAS,cAAc;AACrB,qBAAsB,qBACpB,iBACM,YACA,MACP;;AAEH,SAAS,YAAY;AACnB,cAAa;;;;;ACbf,IAAI,eAAe;AACnB,SAAS,QAAQ,WAAW,SAAS;AACnC,KAAI,CAAC,cAAc;AACjB,MAAI,UACF;EAGF,IAAI,OAAO,cAAc;AAEzB,MAAI,OAAO,YAAY,YACrB,SAAQ,KAAK,KAAK;AAGpB,MAAI;AACF,SAAM,MAAM,KAAK;WACV,GAAG;;;AAIhB,+BAAe;;;;;ACRf,EACG,WAAY;EACX,SAAS,GAAG,GAAG,GAAG;AAChB,UAAQ,MAAM,MAAM,MAAM,KAAK,IAAI,MAAM,IAAI,MAAQ,MAAM,KAAK,MAAM;;EAExE,SAAS,uBAAuB,aAAW,aAAa;AACtD,wBACE,KAAK,MAAM,MAAM,oBACf,oBAAoB,CAAC,GACvB,QAAQ,MACN,iMACD;GACH,IAAI,QAAQ,aAAa;AACzB,OAAI,CAAC,4BAA4B;IAC/B,IAAI,cAAc,aAAa;AAC/B,aAAS,OAAO,YAAY,KACzB,QAAQ,MACP,uEACD,EACA,6BAA6B,CAAC;;AAEnC,iBAAc,SAAS,EACrB,MAAM;IAAS;IAAoB;IAAa,EACjD,CAAC;GACF,IAAI,OAAO,YAAY,GAAG,MACxB,cAAc,YAAY;AAC5B,qBACE,WAAY;AACV,SAAK,QAAQ;AACb,SAAK,cAAc;AACnB,2BAAuB,KAAK,IAAI,YAAY,EAAQ,MAAM,CAAC;MAE7D;IAACC;IAAW;IAAO;IAAY,CAChC;AACD,aACE,WAAY;AACV,2BAAuB,KAAK,IAAI,YAAY,EAAQ,MAAM,CAAC;AAC3D,WAAOA,YAAU,WAAY;AAC3B,4BAAuB,KAAK,IAAI,YAAY,EAAQ,MAAM,CAAC;MAC3D;MAEJ,CAACA,YAAU,CACZ;AACD,iBAAc,MAAM;AACpB,UAAO;;EAET,SAAS,uBAAuB,MAAM;GACpC,IAAI,oBAAoB,KAAK;AAC7B,UAAO,KAAK;AACZ,OAAI;IACF,IAAI,YAAY,mBAAmB;AACnC,WAAO,CAAC,SAAS,MAAM,UAAU;YAC1B,OAAO;AACd,WAAO,CAAC;;;EAGZ,SAAS,uBAAuB,aAAW,aAAa;AACtD,UAAO,aAAa;;AAEtB,kBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,+BACxC,+BAA+B,4BAA4B,OAAO,CAAC;EACrE,IAAI,yBACF,WAAW,eAAe,OAAO,OAAO,KAAK,OAAO,KAAK,IACzD,WAAW,MAAM,UACjB,YAAY,MAAM,WAClBC,oBAAkB,MAAM,iBACxB,gBAAgB,MAAM,eACtB,oBAAoB,CAAC,GACrB,6BAA6B,CAAC,GAC9B,OACE,gBAAgB,OAAO,UACvB,gBAAgB,OAAO,OAAO,YAC9B,gBAAgB,OAAO,OAAO,SAAS,gBACnC,yBACA;AACR,UAAQ,uBACN,KAAK,MAAM,MAAM,uBAAuB,MAAM,uBAAuB;AACvE,kBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,8BACxC,+BAA+B,2BAA2B,OAAO,CAAC;KAClE;;;;;;ACzFJ,QAAO;;;;;;ACMT,EACG,WAAY;EACX,SAAS,GAAG,GAAG,GAAG;AAChB,UAAQ,MAAM,MAAM,MAAM,KAAK,IAAI,MAAM,IAAI,MAAQ,MAAM,KAAK,MAAM;;AAExE,kBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,+BACxC,+BAA+B,4BAA4B,OAAO,CAAC;EACrE,IAAI,yBACF,uBACA,WAAW,eAAe,OAAO,OAAO,KAAK,OAAO,KAAK,IACzD,uBAAuB,KAAK,sBAC5BC,WAAS,MAAM,QACf,YAAY,MAAM,WAClB,UAAU,MAAM,SAChB,gBAAgB,MAAM;AACxB,UAAQ,mCAAmC,SACzC,aACA,aACA,mBACA,UACA,SACA;GACA,IAAI,UAAUA,SAAO,KAAK;AAC1B,OAAI,SAAS,QAAQ,SAAS;IAC5B,IAAI,OAAO;KAAE,UAAU,CAAC;KAAG,OAAO;KAAM;AACxC,YAAQ,UAAU;SACb,QAAO,QAAQ;AACtB,aAAU,QACR,WAAY;IACV,SAAS,iBAAiB,cAAc;AACtC,SAAI,CAAC,SAAS;AACZ,gBAAU,CAAC;AACX,yBAAmB;AACnB,qBAAe,SAAS,aAAa;AACrC,UAAI,KAAK,MAAM,WAAW,KAAK,UAAU;OACvC,IAAI,mBAAmB,KAAK;AAC5B,WAAI,QAAQ,kBAAkB,aAAa,CACzC,QAAQ,oBAAoB;;AAEhC,aAAQ,oBAAoB;;AAE9B,wBAAmB;AACnB,SAAI,SAAS,kBAAkB,aAAa,CAC1C,QAAO;KACT,IAAI,gBAAgB,SAAS,aAAa;AAC1C,SAAI,KAAK,MAAM,WAAW,QAAQ,kBAAkB,cAAc,CAChE,QAAQ,mBAAmB,cAAe;AAC5C,wBAAmB;AACnB,YAAQ,oBAAoB;;IAE9B,IAAI,UAAU,CAAC,GACb,kBACA,mBACA,yBACE,KAAK,MAAM,oBAAoB,OAAO;AAC1C,WAAO,CACL,WAAY;AACV,YAAO,iBAAiB,aAAa,CAAC;OAExC,SAAS,yBACL,KAAK,IACL,WAAY;AACV,YAAO,iBAAiB,wBAAwB,CAAC;MAExD;MAEH;IAAC;IAAa;IAAmB;IAAU;IAAQ,CACpD;GACD,IAAI,QAAQ,qBAAqBC,aAAW,QAAQ,IAAI,QAAQ,GAAG;AACnE,aACE,WAAY;AACV,SAAK,WAAW,CAAC;AACjB,SAAK,QAAQ;MAEf,CAAC,MAAM,CACR;AACD,iBAAc,MAAM;AACpB,UAAO;;AAET,kBAAgB,OAAO,kCACrB,eACE,OAAO,+BAA+B,8BACxC,+BAA+B,2BAA2B,OAAO,CAAC;KAClE;;;;;;AC3FJ,QAAO;;;;;;ACHT,SAAS,SAAS,OAAO,YAAY,MAAM,GAAG;AAQ5C,mEANE,MAAM,iBACA,MAAM,aACN,MAAM,OACZ,UACA,QACD;;AAGH,SAAS,QAAQ,MAAM,MAAM;AAC3B,KAAI,OAAO,GAAG,MAAM,KAAK,CACvB,QAAO;AAET,KAAI,OAAO,SAAS,YAAY,SAAS,QAAQ,OAAO,SAAS,YAAY,SAAS,KACpF,QAAO;AAET,KAAI,gBAAgB,OAAO,gBAAgB,KAAK;AAC9C,MAAI,KAAK,SAAS,KAAK,KAAM,QAAO;AACpC,OAAK,MAAM,CAAC,GAAG,MAAM,KACnB,KAAI,CAAC,KAAK,IAAI,EAAE,IAAI,CAAC,OAAO,GAAG,GAAG,KAAK,IAAI,EAAE,CAAC,CAAE,QAAO;AAEzD,SAAO;;AAET,KAAI,gBAAgB,OAAO,gBAAgB,KAAK;AAC9C,MAAI,KAAK,SAAS,KAAK,KAAM,QAAO;AACpC,OAAK,MAAM,KAAK,KACd,KAAI,CAAC,KAAK,IAAI,EAAE,CAAE,QAAO;AAE3B,SAAO;;AAET,KAAI,gBAAgB,QAAQ,gBAAgB,MAAM;AAChD,MAAI,KAAK,SAAS,KAAK,KAAK,SAAS,CAAE,QAAO;AAC9C,SAAO;;CAET,MAAM,QAAQ,WAAW,KAAK;AAC9B,KAAI,MAAM,WAAW,WAAW,KAAK,CAAC,OACpC,QAAO;AAET,MAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,IAChC,KAAI,CAAC,OAAO,UAAU,eAAe,KAAK,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,KAAK,MAAM,KAAK,KAAK,MAAM,IAAI,CACrG,QAAO;AAGX,QAAO;;AAET,SAAS,WAAW,KAAK;AACvB,QAAO,OAAO,KAAK,IAAI,CAAC,OACtB,OAAO,sBAAsB,IAAI,CAClC;;;;;AClDH,IAAM,6BAAsB,cAAc,KAAK;AAC/C,SAAS,mBAAmB;AAC1B,KAAI,OAAO,aAAa,YACtB,QAAO;AAET,KAAI,OAAO,uBACT,QAAO,OAAO;AAEhB,QAAO,yBAAyB;AAChC,QAAO;;;;;ACPT,SAAS,UAAU,MAAM;CACvB,MAAM,qBAAc,WAAW,kBAAkB,CAAC;AAClD,0BACE,GAAG,MAAM,QAAQ,SAAS,CAAC,QAC3B,8DACD;AACD,QAAO;;;;;ACLT,SAAS,eAAe,MAAM;CAC5B,MAAM,gBAAgB,UAAU,EAC9B,MAAM,MAAM,WAAW,KAAK,GAC7B,CAAC;CACF,MAAM,SAAS,MAAM,UAAU;CAC/B,MAAM,0CAAwB,KAAK,EAAE;AACrC,QAAO,SAAS,OAAO,UAAU,UAAU;AACzC,MAAI,MAAM,QAAQ;AAChB,OAAI,KAAK,qBAAqB,OAAO,QAAQ,0BAA0B;IACrE,MAAM,WAAW,iBACf,eAAe,SACf,KAAK,OAAO,MAAM,CACnB;AACD,mBAAe,UAAU;AACzB,WAAO;;AAET,UAAO,KAAK,OAAO,MAAM;;AAE3B,SAAO;GACP;;;;;ACtBJ,IAAM,4BAAqB,cAAc,KAAK,EAAE;AAChD,IAAM,iCAA0B,cAC9B,KAAK,EACN;;;;ACAD,SAAS,SAAS,MAAM;CACtB,MAAM,8BAAuB,WAC3B,KAAK,OAAO,oBAAoB,aACjC;AAiBD,QAhBuB,eAAe;EACpC,SAAS,UAAU;GACjB,MAAM,QAAQ,MAAM,QAAQ,MACzB,MAAM,KAAK,OAAO,KAAK,SAAS,EAAE,UAAU,EAAE,OAAO,eACvD;AACD,aACE,GAAG,KAAK,eAAe,SAAS,CAAC,QACjC,kBAAkB,KAAK,OAAO,yBAAyB,KAAK,KAAK,KAAK,qBACvE;AACD,OAAI,UAAU,KAAK,EACjB;AAEF,UAAO,KAAK,SAAS,KAAK,OAAO,MAAM,GAAG;;EAE5C,mBAAmB,KAAK;EACzB,CAAC;;;;;ACtBJ,SAAS,cAAc,MAAM;AAC3B,QAAO,SAAS;EACd,MAAM,KAAK;EACX,QAAQ,KAAK;EACb,mBAAmB,KAAK;EACxB,SAAS,MAAM;AACb,UAAO,KAAK,SAAS,KAAK,OAAO,EAAE,WAAW,GAAG,EAAE;;EAEtD,CAAC;;;;;ACRJ,SAAS,cAAc,MAAM;CAC3B,MAAM,EAAE,OAAQ,GAAG,SAAS;AAC5B,QAAO,SAAS;EACd,GAAG;EACH,SAAS,MAAM;AACb,UAAO,SAAS,OAAO,EAAE,WAAW,GAAG,EAAE;;EAE5C,CAAC;;;;;ACPJ,SAAS,UAAU,MAAM;AACvB,QAAO,SAAS;EACd,MAAM,KAAK;EACX,aAAa,KAAK;EAClB,mBAAmB,KAAK;EACxB,QAAQ,KAAK;EACb,SAAS,UAAU;GACjB,MAAM,SAAS,KAAK,WAAW,QAAQ,MAAM,SAAS,MAAM;AAC5D,UAAO,KAAK,SAAS,KAAK,OAAO,OAAO,GAAG;;EAE9C,CAAC;;;;;ACVJ,SAAS,UAAU,MAAM;AACvB,QAAO,SAAS;EACd,MAAM,KAAK;EACX,QAAQ,KAAK;EACb,aAAa,KAAK;EAClB,mBAAmB,KAAK;EACxB,SAAS,UAAU;AACjB,UAAO,KAAK,SAAS,KAAK,OAAO,MAAM,OAAO,GAAG,MAAM;;EAE1D,CAAC;;;;;ACRJ,SAAS,YAAY,cAAc;CACjC,MAAM,SAAS,WAAW;AAC1B,qBAAa,aACV,YAAY;AACX,SAAO,OAAO,SAAS;GACrB,GAAG;GACH,MAAM,QAAQ,QAAQ,cAAc;GACrC,CAAC;IAEJ,CAAC,cAAc,MAAM,OAAO,CAC7B;;AAEH,SAAS,SAAS,OAAO;CACvB,MAAM,SAAS,WAAW;CAC1B,MAAM,WAAW,aAAa;CAC9B,MAAM,gCAAyB,OAAO,KAAK;AAC3C,cAAM,gBAAgB;AACpB,MAAI,iBAAiB,YAAY,OAAO;AACtC,YAAS,MAAM;AACf,oBAAiB,UAAU;;IAE5B;EAAC;EAAQ;EAAO;EAAS,CAAC;AAC7B,QAAO;;;;;ACvBT,SAAS,kBAAkB,IAAI;CAC7B,MAAM,qBAAc,OAAO,GAAG;AAC9B,OAAM,UAAU;AAEhB,qBADkB,QAAQ,GAAG,SAAS,MAAM,QAAQ,GAAG,KAAK,CAAC,CAClD;;AAEb,IAAM,kBAAkB,OAAO,WAAW,2BAAoB,+BAAwB;AACtF,SAAS,YAAY,OAAO;CAC1B,MAAM,mBAAY,OAAO;EACvB;EACA,MAAM;EACP,CAAC;CACF,MAAM,UAAU,IAAI,QAAQ;AAC5B,KAAI,UAAU,QACZ,KAAI,UAAU;EACZ;EACA,MAAM;EACP;AAEH,QAAO,IAAI,QAAQ;;AAErB,SAAS,wBAAwB,KAAK,UAAU,gCAA8B,EAAE,EAAE,UAAU,EAAE,EAAE;AAC9F,cAAM,gBAAgB;AACpB,MAAI,CAAC,IAAI,WAAW,QAAQ,YAAY,OAAO,yBAAyB,WACtE;EAEF,MAAM,WAAW,IAAI,sBAAsB,CAAC,WAAW;AACrD,YAAS,MAAM;KACdC,8BAA4B;AAC/B,WAAS,QAAQ,IAAI,QAAQ;AAC7B,eAAa;AACX,YAAS,YAAY;;IAEtB;EAAC;EAAUA;EAA6B,QAAQ;EAAU;EAAI,CAAC;;AAEpE,SAAS,gBAAgB,KAAK;CAC5B,MAAM,wBAAiB,OAAO,KAAK;AACnC,cAAM,oBAAoB,WAAW,SAAS,SAAS,EAAE,CAAC;AAC1D,QAAO;;;;;;AChCT,SAAS,aAAa,SAAS,cAAc;CAC3C,MAAM,SAAS,WAAW;CAC1B,MAAM,CAAC,iBAAiB,mCAA4B,SAAS,MAAM;CACnE,MAAM,gCAAyB,OAAO,MAAM;CAC5C,MAAM,WAAW,gBAAgB,aAAa;CAC9C,MAAM,EAEJ,aACA,eACA,eACA,IACA,SAAS,aACT,cAAc,kBACd,oBACA,SACA,iBACA,aACA,gBAEA,UACA,QACA,UACA,OACA,WACA,SACA,SACA,cACA,cACA,cACA,eAEA,QAAQ,SACR,QAAQ,SACR,MAAM,OACN,OAAO,QACP,MAAM,OACN,gBAAgB,iBAChB,gBAAgB,iBAChB,MAAM,OACN,cACA,GAAG,sBACD;CACJ,MAAM,gBAAgB,eAAe;EACnC,SAAS,MAAM,EAAE,SAAS;EAC1B,mBAAmB;EACpB,CAAC;CACF,MAAM,OAAO,QAAQ;CACrB,MAAM,wBAAiB,cACf;AACJ,SAAO;GAAE,GAAG;GAAS;GAAM;IAG7B;EACE;EACA;EACA;EACA,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACT,CACF;CACD,MAAM,oBAAa,cACX,OAAO,cAAc,EAAE,GAAG,UAAU,CAAC,EAC3C,CAAC,QAAQ,SAAS,CACnB;CACD,MAAM,0BAAmB,cAAc;AACrC,MAAI,SACF;EAEF,IAAI,OAAO,KAAK,iBAAiB,KAAK,eAAe,MAAM,KAAK;EAChE,IAAI,WAAW;AACf,MAAI,OAAO,OACT,KAAI,KAAK,WAAW,OAAO,OAAO,CAChC,QAAO,OAAO,QAAQ,WAAW,KAAK,QAAQ,OAAO,QAAQ,GAAG,CAAC,IAAI;MAErE,YAAW;AAGf,SAAO;GAAE;GAAM;GAAU;IACxB;EAAC;EAAU,KAAK;EAAgB,KAAK;EAAK,OAAO;EAAQ,OAAO;EAAQ,CAAC;CAC5E,MAAM,4BAAqB,cAAc;AACvC,MAAI,YAAY,SACd,QAAO,WAAW;AAEpB,MAAI;AACF,OAAI,IAAI,GAAG;AACX,UAAO;UACD;IAGP,CAAC,IAAI,WAAW,CAAC;CACpB,MAAM,UAAU,QAAQ,kBAAkB,eAAe,QAAQ,eAAe,OAAO,QAAQ;CAC/F,MAAM,eAAe,oBAAoB,OAAO,QAAQ,uBAAuB;CAC/E,MAAM,WAAW,eAAe,EAC9B,SAAS,MAAM;AACb,MAAI,aAAc,QAAO;AACzB,MAAI,eAAe,OAMjB;OAAI,CALc,cAChB,EAAE,SAAS,UACX,KAAK,UACL,OAAO,SACR,CAEC,QAAO;SAEJ;GACL,MAAM,mBAAmB,oBACvB,EAAE,SAAS,UACX,OAAO,SACR;GACD,MAAM,gBAAgB,oBACpB,KAAK,UACL,OAAO,SACR;AAED,OAAI,EADqB,iBAAiB,WAAW,cAAc,KAAK,iBAAiB,WAAW,cAAc,UAAU,iBAAiB,cAAc,YAAY,MAErK,QAAO;;AAGX,MAAI,eAAe,iBAAiB,MAKlC;OAAI,CAJe,UAAU,EAAE,SAAS,QAAQ,KAAK,QAAQ;IAC3D,SAAS,CAAC,eAAe;IACzB,iBAAiB,CAAC,eAAe;IAClC,CAAC,CAEA,QAAO;;AAGX,MAAI,eAAe,YACjB,QAAO,EAAE,SAAS,SAAS,KAAK;AAElC,SAAO;IAEV,CAAC;CACF,MAAM,yBAAkB,kBAAkB;AACxC,SAAO,aAAa,EAAE,GAAG,UAAU,CAAC,CAAC,OAAO,QAAQ;AAClD,WAAQ,KAAK,IAAI;AACjB,WAAQ,KAAK,eAAe;IAC5B;IACD,CAAC,QAAQ,SAAS,CAAC;AAStB,yBACE,uBATsC,aACrC,UAAU;AACT,MAAI,OAAO,eACT,YAAW;IAGf,CAAC,UAAU,CACZ,EAIC,6BACA,EAAE,UAAU,CAAC,CAAC,YAAY,EAAE,YAAY,aAAa,CACtD;AACD,cAAM,gBAAgB;AACpB,MAAI,iBAAiB,QACnB;AAEF,MAAI,CAAC,YAAY,YAAY,UAAU;AACrC,cAAW;AACX,oBAAiB,UAAU;;IAE5B;EAAC;EAAU;EAAW;EAAQ,CAAC;CAClC,MAAM,eAAe,MAAM;EACzB,MAAM,gBAAgB,EAAE,cAAc;EACtC,MAAM,kBAAkB,WAAW,KAAK,IAAI,SAAS;AACrD,MAAI,CAAC,YAAY,CAAC,YAAY,EAAE,IAAI,CAAC,EAAE,qBAAqB,CAAC,mBAAmB,oBAAoB,YAAY,EAAE,WAAW,GAAG;AAC9H,KAAE,gBAAgB;AAClB,yCAAgB;AACd,uBAAmB,KAAK;KACxB;GACF,MAAM,QAAQ,OAAO,UAAU,oBAAoB;AACjD,WAAO;AACP,uBAAmB,MAAM;KACzB;AACF,UAAO,SAAS;IACd,GAAG;IACH;IACA;IACA;IACA;IACA;IACA;IACD,CAAC;;;AAGN,KAAI,aACF,QAAO;EACL,GAAG;EACH,KAAK;EACL,MAAM;EACN,GAAG,YAAY,EAAE,UAAU;EAC3B,GAAG,UAAU,EAAE,QAAQ;EACvB,GAAG,YAAY,EAAE,UAAU;EAC3B,GAAG,SAAS,EAAE,OAAO;EACrB,GAAG,aAAa,EAAE,WAAW;EAC7B,GAAG,WAAW,EAAE,SAAS;EACzB,GAAG,WAAW,EAAE,SAAS;EACzB,GAAG,gBAAgB,EAAE,cAAc;EACnC,GAAG,gBAAgB,EAAE,cAAc;EACnC,GAAG,gBAAgB,EAAE,cAAc;EACpC;CAEH,MAAM,eAAe,MAAM;AACzB,MAAI,SAAU;AACd,MAAI,QACF,YAAW;;CAGf,MAAM,mBAAmB;CACzB,MAAM,eAAe,MAAM;AACzB,MAAI,YAAY,CAAC,QAAS;AAC1B,MAAI,CAAC,aACH,YAAW;OACN;GACL,MAAM,cAAc,EAAE;AACtB,OAAI,WAAW,IAAI,YAAY,CAC7B;GAEF,MAAM,KAAK,iBAAiB;AAC1B,eAAW,OAAO,YAAY;AAC9B,eAAW;MACV,aAAa;AAChB,cAAW,IAAI,aAAa,GAAG;;;CAGnC,MAAM,eAAe,MAAM;AACzB,MAAI,YAAY,CAAC,WAAW,CAAC,aAAc;EAC3C,MAAM,cAAc,EAAE;EACtB,MAAM,KAAK,WAAW,IAAI,YAAY;AACtC,MAAI,IAAI;AACN,gBAAa,GAAG;AAChB,cAAW,OAAO,YAAY;;;CAGlC,MAAM,sBAAsB,WAAW,iBAAiB,aAAa,EAAE,CAAC,IAAI,uBAAuB;CACnG,MAAM,wBAAwB,WAAW,sBAAsB,iBAAiB,eAAe,EAAE,CAAC,IAAI;CACtG,MAAM,oBAAoB;EACxB;EACA,oBAAoB;EACpB,sBAAsB;EACvB,CAAC,OAAO,QAAQ,CAAC,KAAK,IAAI;CAC3B,MAAM,iBAAiB,SAAS,oBAAoB,SAAS,sBAAsB,UAAU;EAC3F,GAAG;EACH,GAAG,oBAAoB;EACvB,GAAG,sBAAsB;EAC1B;AACD,QAAO;EACL,GAAG;EACH,GAAG;EACH,GAAG;EACH,MAAM,YAAY;EAClB,KAAK;EACL,SAAS,gBAAgB,CAAC,SAAS,YAAY,CAAC;EAChD,SAAS,gBAAgB,CAAC,SAAS,YAAY,CAAC;EAChD,cAAc,gBAAgB,CAAC,cAAc,YAAY,CAAC;EAC1D,cAAc,gBAAgB,CAAC,cAAc,YAAY,CAAC;EAC1D,cAAc,gBAAgB,CAAC,cAAc,iBAAiB,CAAC;EAC/D,UAAU,CAAC,CAAC;EACZ;EACA,GAAG,iBAAiB,EAAE,OAAO,eAAe;EAC5C,GAAG,qBAAqB,EAAE,WAAW,mBAAmB;EACxD,GAAG,YAAY;EACf,GAAG,YAAY;EACf,GAAG,mBAAmB;EACvB;;AAEH,IAAM,sBAAsB,EAAE;AAC9B,IAAM,uBAAuB,EAAE,WAAW,UAAU;AACpD,IAAM,wBAAwB;CAAE,MAAM;CAAQ,iBAAiB;CAAM;AACrE,IAAM,sBAAsB;CAAE,eAAe;CAAU,gBAAgB;CAAQ;AAC/E,IAAM,6BAA6B,EAAE,sBAAsB,iBAAiB;AAC5E,IAAM,6BAA6B,IAAI,SAAS;AAChD,IAAM,8BAA8B,EAClC,YAAY,SACb;AACD,IAAM,mBAAmB,cAAc,MAAM;AAC3C,MAAK,MAAM,WAAW,UAAU;AAC9B,MAAI,CAAC,QAAS;AACd,MAAI,EAAE,iBAAkB;AACxB,UAAQ,EAAE;;;AAGd,SAAS,WAAW,MAAM;AACxB,qBAAa,WAAW,SAAS,YAAY,OAAO,KAAK;AACvD,SAAuB,4CAAI,MAAM;GAAE,GAAG;GAAO,UAAU;GAAM;GAAK,CAAC;GACnE;;AAEJ,IAAM,oBAAa,YAChB,OAAO,QAAQ;CACd,MAAM,EAAE,SAAU,GAAG,SAAS;CAC9B,MAAM,EACJ,MAAM,OACN,KAAK,SACL,GAAG,cACD,aAAa,MAAM,IAAI;CAC3B,MAAM,WAAW,OAAO,KAAK,aAAa,aAAa,KAAK,SAAS,EACnE,UAAU,UAAU,mBAAmB,UACxC,CAAC,GAAG,KAAK;AACV,KAAI,aAAa,KAAK,EACpB,QAAO,UAAU;AAEnB,qBAAa,cACX,WAAW,WAAW,KACtB;EACE,GAAG;EACH,KAAK;EACN,EACD,SACD;EAEJ;AACD,SAAS,YAAY,GAAG;AACtB,QAAO,CAAC,EAAE,EAAE,WAAW,EAAE,UAAU,EAAE,WAAW,EAAE;;AAEpD,IAAM,eAAe,YAAY;AAC/B,QAAO;;;;;AC7TT,SAAS,YAAY,IAAI;AACvB,QAAO,IAAI,SAAS,EAAE,IAAI,CAAC;;AAE7B,IAAM,WAAN,cAAuB,aAAa;;;;CAIlC,YAAY,EAAE,MAAM;AAClB,QAAM,EAAE,IAAI,CAAC;AACb,OAAK,YAAY,SAAS;AACxB,UAAO,SAAS;IACd,QAAQ,MAAM;IACd,MAAM,KAAK;IACX,mBAAmB,MAAM;IAC1B,CAAC;;AAEJ,OAAK,mBAAmB,SAAS;AAC/B,UAAO,SAAS;IACd,MAAM,KAAK;IACX,SAAS,MAAM,MAAM,SAAS,KAAK,OAAO,EAAE,QAAQ,GAAG,EAAE;IAC1D,CAAC;;AAEJ,OAAK,aAAa,SAAS;AACzB,UAAO,UAAU;IACf,QAAQ,MAAM;IACd,mBAAmB,MAAM;IACzB,MAAM,KAAK;IACZ,CAAC;;AAEJ,OAAK,aAAa,SAAS;AACzB,UAAO,UAAU;IACf,QAAQ,MAAM;IACd,mBAAmB,MAAM;IACzB,MAAM,KAAK;IACZ,CAAC;;AAEJ,OAAK,iBAAiB,SAAS;AAC7B,UAAO,cAAc;IAAE,GAAG;IAAM,MAAM,KAAK;IAAI,QAAQ;IAAO,CAAC;;AAEjE,OAAK,iBAAiB,SAAS;AAC7B,UAAO,cAAc;IAAE,GAAG;IAAM,MAAM,KAAK;IAAI,QAAQ;IAAO,CAAC;;AAEjE,OAAK,oBAAoB;AAEvB,UAAO,YAAY,EAAE,MADN,WAAW,CACQ,WAAW,KAAK,IAAI,UAAU,CAAC;;AAEnE,OAAK,YAAY,SAAS;AACxB,UAAO,SAAS;IAAE,SAAS,KAAK;IAAI,GAAG;IAAM,CAAC;;AAEhD,OAAK,oBAAsB,YAAY,OAAO,QAAQ;GAEpD,MAAM,WADS,WAAW,CACF,WAAW,KAAK,IAAI;AAC5C,UAAuB,4CAAI,MAAM;IAAE;IAAK,MAAM;IAAU,GAAG;IAAO,CAAC;IACnE;;;AAGN,IAAM,QAAN,cAAoB,UAAU;;;;CAI5B,YAAY,SAAS;AACnB,QAAM,QAAQ;AACd,OAAK,YAAY,SAAS;AACxB,UAAO,SAAS;IACd,QAAQ,MAAM;IACd,MAAM,KAAK;IACX,mBAAmB,MAAM;IAC1B,CAAC;;AAEJ,OAAK,mBAAmB,SAAS;AAC/B,UAAO,SAAS;IACd,GAAG;IACH,MAAM,KAAK;IACX,SAAS,MAAM,MAAM,SAAS,KAAK,OAAO,EAAE,QAAQ,GAAG,EAAE;IAC1D,CAAC;;AAEJ,OAAK,aAAa,SAAS;AACzB,UAAO,UAAU;IACf,QAAQ,MAAM;IACd,mBAAmB,MAAM;IACzB,MAAM,KAAK;IACZ,CAAC;;AAEJ,OAAK,aAAa,SAAS;AACzB,UAAO,UAAU;IACf,QAAQ,MAAM;IACd,mBAAmB,MAAM;IACzB,MAAM,KAAK;IACZ,CAAC;;AAEJ,OAAK,iBAAiB,SAAS;AAC7B,UAAO,cAAc;IAAE,GAAG;IAAM,MAAM,KAAK;IAAI,CAAC;;AAElD,OAAK,iBAAiB,SAAS;AAC7B,UAAO,cAAc;IAAE,GAAG;IAAM,MAAM,KAAK;IAAI,CAAC;;AAElD,OAAK,oBAAoB;AACvB,UAAO,YAAY,EAAE,MAAM,KAAK,UAAU,CAAC;;AAE7C,OAAK,oBAAsB,YACxB,OAAO,QAAQ;AACd,UAAuB,4CAAI,MAAM;IAAE;IAAK,MAAM,KAAK;IAAU,GAAG;IAAO,CAAC;IAE3E;AACD,OAAK,WAAW,OAAO,IAAI,aAAa;;;AAG5C,SAAS,YAAY,SAAS;AAC5B,QAAO,IAAI,MAET,QACD;;AAEH,SAAS,6BAA6B;AACpC,SAAQ,YAAY;AAClB,SAAO,gBAAgB,QAAQ;;;AAGnC,IAAM,uBAAuB;AAC7B,IAAM,YAAN,cAAwB,cAAc;;;;CAIpC,YAAY,SAAS;AACnB,QAAM,QAAQ;AACd,OAAK,YAAY,SAAS;AACxB,UAAO,SAAS;IACd,QAAQ,MAAM;IACd,MAAM,KAAK;IACX,mBAAmB,MAAM;IAC1B,CAAC;;AAEJ,OAAK,mBAAmB,SAAS;AAC/B,UAAO,SAAS;IACd,GAAG;IACH,MAAM,KAAK;IACX,SAAS,MAAM,MAAM,SAAS,KAAK,OAAO,EAAE,QAAQ,GAAG,EAAE;IAC1D,CAAC;;AAEJ,OAAK,aAAa,SAAS;AACzB,UAAO,UAAU;IACf,QAAQ,MAAM;IACd,mBAAmB,MAAM;IACzB,MAAM,KAAK;IACZ,CAAC;;AAEJ,OAAK,aAAa,SAAS;AACzB,UAAO,UAAU;IACf,QAAQ,MAAM;IACd,mBAAmB,MAAM;IACzB,MAAM,KAAK;IACZ,CAAC;;AAEJ,OAAK,iBAAiB,SAAS;AAC7B,UAAO,cAAc;IAAE,GAAG;IAAM,MAAM,KAAK;IAAI,CAAC;;AAElD,OAAK,iBAAiB,SAAS;AAC7B,UAAO,cAAc;IAAE,GAAG;IAAM,MAAM,KAAK;IAAI,CAAC;;AAElD,OAAK,oBAAoB;AACvB,UAAO,YAAY,EAAE,MAAM,KAAK,UAAU,CAAC;;AAE7C,OAAK,oBAAsB,YACxB,OAAO,QAAQ;AACd,UAAuB,4CAAI,MAAM;IAAE;IAAK,MAAM,KAAK;IAAU,GAAG;IAAO,CAAC;IAE3E;AACD,OAAK,WAAW,OAAO,IAAI,aAAa;;;AAG5C,SAAS,gBAAgB,SAAS;AAChC,QAAO,IAAI,UAAU,QAAQ;;AAE/B,SAAS,gBAAgB,MAAM;AAC7B,QAAO;;AAET,IAAM,gBAAN,cAA4B,MAAM;CAChC,YAAY,SAAS;AACnB,QAAM;GACJ,GAAG;GACH,IAAI;GACL,CAAC;;;;;;ACvLN,SAAS,gBAAgB,MAAM;AAC7B,KAAI,OAAO,SAAS,SAClB,QAAO,IAAI,UAAU,MAAM,EACzB,QAAQ,MACT,CAAC,CAAC,YAAY,KAAK;AAEtB,QAAO,IAAI,UAAU,MAAM,EACzB,QAAQ,MACT,CAAC,CAAC;;AAEL,IAAM,YAAN,MAAgB;CACd,YAAY,MAAM,OAAO;AACvB,OAAK,OAAO;AACZ,OAAK,eAAe,YAAY;AAC9B,4BACE,KAAK,QACL,kIACD;GACD,MAAM,QAAQ,YAAY,QAAQ;AAClC,SAAM,SAAS;AACf,UAAO;;AAET,OAAK,SAAS,OAAO;;;AAGzB,SAAS,gBAAgB,OAAO;AAC9B,0BACE,OACA,6MACD;AACD,SAAQ,aAAa;;AAEvB,IAAM,YAAN,MAAgB;CACd,YAAY,MAAM;AAChB,OAAK,YAAY,UAAU;AACzB,UAAO,SAAS;IACd,QAAQ,OAAO;IACf,MAAM,KAAK,QAAQ;IACnB,mBAAmB,OAAO;IAC3B,CAAC;;AAEJ,OAAK,mBAAmB,UAAU;AAChC,UAAO,SAAS;IACd,MAAM,KAAK,QAAQ;IACnB,SAAS,MAAM,OAAO,SAAS,MAAM,OAAO,EAAE,QAAQ,GAAG,EAAE;IAC5D,CAAC;;AAEJ,OAAK,aAAa,UAAU;AAC1B,UAAO,UAAU;IACf,QAAQ,OAAO;IACf,mBAAmB,OAAO;IAC1B,MAAM,KAAK,QAAQ;IACpB,CAAC;;AAEJ,OAAK,aAAa,UAAU;AAC1B,UAAO,UAAU;IACf,QAAQ,OAAO;IACf,mBAAmB,OAAO;IAC1B,MAAM,KAAK,QAAQ;IACpB,CAAC;;AAEJ,OAAK,iBAAiB,UAAU;AAC9B,UAAO,cAAc;IAAE,GAAG;IAAO,MAAM,KAAK,QAAQ;IAAI,CAAC;;AAE3D,OAAK,iBAAiB,UAAU;AAC9B,UAAO,cAAc;IAAE,GAAG;IAAO,MAAM,KAAK,QAAQ;IAAI,CAAC;;AAE3D,OAAK,oBAAoB;AAEvB,UAAO,YAAY,EAAE,MADN,WAAW,CACQ,WAAW,KAAK,QAAQ,IAAI,UAAU,CAAC;;AAE3E,OAAK,UAAU;AACf,OAAK,WAAW,OAAO,IAAI,aAAa;;;AAG5C,SAAS,gBAAgB,IAAI;AAC3B,SAAQ,SAAS;AACf,SAAO,IAAI,UAAU;GACnB;GACA,GAAG;GACJ,CAAC;;;AAGN,SAAS,oBAAoB,IAAI;AAC/B,KAAI,OAAO,OAAO,SAChB,QAAO,IAAI,UAAU,GAAG;AAE1B,SAAQ,SAAS,IAAI,UAAU;EAAE;EAAI,GAAG;EAAM,CAAC;;;;;AC9FjD,SAAS,mBAAmB,UAAU,YAAY;CAChD,IAAI;CACJ,IAAI;CACJ,IAAI;CACJ,IAAI;CACJ,MAAM,aAAa;AACjB,MAAI,CAAC,YACH,eAAc,UAAU,CAAC,MAAM,QAAQ;AACrC,iBAAc,KAAK;AACnB,UAAO,IAAI,cAAc;IACzB,CAAC,OAAO,QAAQ;AAChB,WAAQ;AACR,OAAI,sBAAsB,MAAM,EAC9B;QAAI,iBAAiB,SAAS,OAAO,WAAW,eAAe,OAAO,mBAAmB,aAAa;KACpG,MAAMC,eAAa,0BAA0B,MAAM;AACnD,SAAI,CAAC,eAAe,QAAQA,aAAW,EAAE;AACvC,qBAAe,QAAQA,cAAY,IAAI;AACvC,eAAS;;;;IAIf;AAEJ,SAAO;;CAET,MAAM,WAAW,SAAS,KAAK,OAAO;AACpC,MAAI,QAAQ;AACV,UAAO,SAAS,QAAQ;AACxB,SAAM,IAAI,cAAc,GACtB;;AAEJ,MAAI,MACF,OAAM;AAER,MAAI,CAAC,KACH,OAAM,MAAM;AAEd,sBAAa,cAAc,MAAM,MAAM;;AAEzC,UAAS,UAAU;AACnB,QAAO;;;;;ACrCT,SAAS,eAAe;CACtB,MAAM,SAAS,WAAW;CAC1B,MAAM,kCAA2B,OAAO;EAAE;EAAQ,SAAS;EAAO,CAAC;CACnE,MAAM,CAAC,iBAAiB,mCAA4B,SAAS,MAAM;CACnE,MAAM,EAAE,mBAAmB,cAAc,eAAe;EACtD,SAAS,OAAO;GACd,WAAW,EAAE;GACb,mBAAmB,EAAE,QAAQ,MAAM,MAAM,EAAE,WAAW,UAAU;GACjE;EACD,mBAAmB;EACpB,CAAC;CACF,MAAM,oBAAoB,YAAY,UAAU;CAChD,MAAM,eAAe,aAAa,mBAAmB;CACrD,MAAM,uBAAuB,YAAY,aAAa;CACtD,MAAM,gBAAgB,aAAa;CACnC,MAAM,wBAAwB,YAAY,cAAc;AACxD,QAAO,mBAAmB,OAAO;AAC/B,qBAAmB,KAAK;AACxB,eAAM,sBAAsB;AAC1B,OAAI;AACJ,sBAAmB,MAAM;IACzB;;AAEJ,cAAM,gBAAgB;EACpB,MAAM,QAAQ,OAAO,QAAQ,UAAU,OAAO,KAAK;EACnD,MAAM,eAAe,OAAO,cAAc;GACxC,IAAI,OAAO,eAAe;GAC1B,QAAQ;GACR,QAAQ;GACR,MAAM;GACN,OAAO;GACP,wBAAwB;GACzB,CAAC;AACF,MAAI,cAAc,OAAO,eAAe,KAAK,KAAK,cAAc,aAAa,KAAK,CAChF,QAAO,eAAe;GAAE,GAAG;GAAc,SAAS;GAAM,CAAC;AAE3D,eAAa;AACX,UAAO;;IAER,CAAC,QAAQ,OAAO,QAAQ,CAAC;AAC5B,uBAAsB;AACpB,MAEE,OAAO,WAAW,eAAe,OAAO,OAAO,mBAAmB,QAAQ,WAAW,UAAU,mBAAmB,QAAQ,QAE1H;AAEF,qBAAmB,UAAU;GAAE;GAAQ,SAAS;GAAM;EACtD,MAAM,UAAU,YAAY;AAC1B,OAAI;AACF,UAAM,OAAO,MAAM;YACZ,KAAK;AACZ,YAAQ,MAAM,IAAI;;;AAGtB,WAAS;IACR,CAAC,OAAO,CAAC;AACZ,uBAAsB;AACpB,MAAI,qBAAqB,CAAC,UACxB,QAAO,KAAK;GACV,MAAM;GAEN,GAAG,sBAAsB,OAAO,MAAM;GACvC,CAAC;IAEH;EAAC;EAAmB;EAAQ;EAAU,CAAC;AAC1C,uBAAsB;AACpB,MAAI,yBAAyB,CAAC,cAC5B,QAAO,KAAK;GACV,MAAM;GACN,GAAG,sBAAsB,OAAO,MAAM;GACvC,CAAC;IAEH;EAAC;EAAe;EAAuB;EAAO,CAAC;AAClD,uBAAsB;AACpB,MAAI,wBAAwB,CAAC,cAAc;AACzC,UAAO,KAAK;IACV,MAAM;IACN,GAAG,sBAAsB,OAAO,MAAM;IACvC,CAAC;AACF,UAAO,QAAQ,UAAU,OAAO;IAC9B,GAAG;IACH,QAAQ;IACR,kBAAkB,EAAE;IACrB,EAAE;AACH,oBAAiB,OAAO;;IAEzB;EAAC;EAAc;EAAsB;EAAO,CAAC;AAChD,QAAO;;;;;ACzFT,SAAS,cAAc,OAAO;CAC5B,MAAM,WAAW,eAAe,EAC9B,SAAS,MAAM,aAAa,EAAE,SAAS,SAAS,GAAG,EAAE,UACtD,CAAC;AACF,QAAuB,4CACrB,eACA;EACE,mBAAmB;EACnB,UAAU,OAAO,cAAc;AAC7B,OAAI,WAAW,MAAM,CACnB,OAAM,UAAU,OAAO,UAAU;OAEjC,OAAM;;EAGV,iBAAiB,EAAE,YAAY;AAC7B,OAAI,WAAW,MAAM,CACnB,QAAO,MAAM,WAAW,MAAM;OAE9B,OAAM;;EAGV,UAAU,MAAM;EACjB,CACF;;AAEH,SAAS,wBAAwB;AAC/B,QAAuB,4CAAI,KAAK,EAAE,UAAU,aAAa,CAAC;;;;;AC9B5D,SAAS,aAAa,OAAO;AAC3B,QAAuB,4CAAIC,6BAAU,EAAE,UAAU,MAAM,UAAU,CAAC;;;;;ACCpE,SAAS,oBAAoB,QAAQ,OAAO,MAAM;AAChD,KAAI,CAAC,MAAM,QAAQ,mBAAmB;AACpC,MAAI,OAAO,QAAQ,yBACjB,QAAuB,4CAAI,OAAO,QAAQ,0BAA0B,EAAE,MAAM,CAAC;AAG7E,2BACE,MAAM,QAAQ,mBACd,yDAAyD,MAAM,GAAG,uPACnE;AAEH,SAAuB,4CAAI,uBAAuB,EAAE,CAAC;;AAEvD,QAAuB,4CAAI,MAAM,QAAQ,mBAAmB,EAAE,MAAM,CAAC;;;;;ACdvE,SAAS,WAAW,EAAE,YAAY;CAChC,MAAM,SAAS,WAAW;AAC1B,KAAI,CAAC,OAAO,SACV,QAAO;AAET,QAAuB,4CACrB,UACA;EACE,OAAO,OAAO,QAAQ,KAAK;EAC3B,WAAW;EACX,yBAAyB,EACvB,QAAQ,CAAC,SAAS,CAAC,OAAO,QAAQ,CAAC,KAAK,KAAK,GAAG,cACjD;EACF,CACF;;;;;ACZH,SAASC,sBAAoB;CAC3B,MAAM,SAAS,WAAW;AAC1B,KAAI,CAAC,OAAO,qBAAqB,CAAC,OAAO,SACvC,QAAO;AAET,KAAI,OAAO,OAAO,QAAQ,sBAAsB,YAI9C;MAAI,CAHkB,OAAO,QAAQ,kBAAkB,EACrD,UAAU,OAAO,gBAClB,CAAC,CAEA,QAAO;;CAIX,MAAM,WADS,OAAO,QAAQ,2BAA2B,gCAClC,OAAO,eAAe;CAC7C,MAAM,cAAc,YAAY,+BAA+B,OAAO,eAAe,GAAG,UAAU,KAAK;CACvG,MAAM,uBAAuB;EAC3B;EACA,yBAAyB;EAC1B;AACD,KAAI,YACF,sBAAqB,MAAM;AAE7B,QAAuB,4CACrB,YACA,EACE,UAAU,IAAI,cAAc,UAAU,CAAC,IAAI,KAAK,UAAU,qBAAqB,CAAC,IACjF,CACF;;;;;AClBH,IAAM,qBAAc,KAAK,SAAS,UAAU,EAC1C,WACC;CACD,MAAM,SAAS,WAAW;CAC1B,MAAM,aAAa,eAAe;EAChC,SAAS,MAAM;GACb,MAAM,QAAQ,EAAE,QAAQ,MAAM,MAAM,EAAE,OAAO,QAAQ;AACrD,aACE,OACA,qCAAqC,QAAQ,0BAC9C;AACD,UAAO;IACL,SAAS,MAAM;IACf,KAAK,MAAM;IACX,iBAAiB,MAAM;IACxB;;EAEH,mBAAmB;EACpB,CAAC;CACF,MAAM,QAAQ,OAAO,WAAW,WAAW;CAC3C,MAAM,mBAAmB,MAAM,QAAQ,oBAAoB,OAAO,QAAQ;CAC1E,MAAM,iBAAiB,mBAAmC,4CAAI,kBAAkB,EAAE,CAAC,GAAG;CACtF,MAAM,sBAAsB,MAAM,QAAQ,kBAAkB,OAAO,QAAQ;CAC3E,MAAM,eAAe,MAAM,QAAQ,WAAW,OAAO,QAAQ;CAC7D,MAAM,yBAAyB,MAAM,SAEnC,MAAM,QAAQ,qBAAqB,OAAO,QAAQ,eAAe,QAAQ,YACvE,MAAM,QAAQ;CAClB,MAAM,gBAAgB,WAAW,QAAQ,SAAS,WAAW,QAAQ;CACrE,MAAM,4BAEH,CAAC,MAAM,UAAU,MAAM,QAAQ,kBAAkB,mBAAmB,MAAM,QAAQ,kBAAkB,qBAAqB,MAAM,QAAQ,gBAAgB,WAAW,+BAAwB,WAAW;CAExM,MAAM,wBAAwB,sBAAsB,gBAAgB;CACpE,MAAM,2BAA2B,yBAAyB,gBAAgB;CAC1E,MAAM,WAAW,eAAe,EAC9B,SAAS,MAAM,EAAE,UAClB,CAAC;CACF,MAAM,gBAAgB,eAAe,EACnC,SAAS,MAAM;EACb,MAAM,QAAQ,EAAE,QAAQ,WAAW,MAAM,EAAE,OAAO,QAAQ;AAC1D,SAAO,EAAE,QAAQ,QAAQ,IAAI;IAEhC,CAAC;AAEF,QAAuB,6CADA,MAAM,SAAS,MAAM,QAAQ,kBAAkB,eAAe,cACzC,EAAE,UAAU,CACtC,4CAAI,aAAa,UAAU;EAAE,OAAO;EAAS,UAA0B,4CAAI,0BAA0B;GAAE,UAAU;GAAgB,UAA0B,4CACzK,uBACA;IACE,mBAAmB;IACnB,gBAAgB,uBAAuB;IACvC,UAAU,OAAO,cAAc;AAC7B,SAAI,WAAW,MAAM,CAAE,OAAM;AAC7B,8BAAQ,OAAO,yBAAyB,UAAU;AAClD,oBAAe,OAAO,UAAU;;IAElC,UAA0B,4CACxB,0BACA;KACE,WAAW,UAAU;AACnB,UAAI,CAAC,0BAA0B,MAAM,WAAW,MAAM,YAAY,WAAW,WAAW,CAAC,MAAM,WAAW,CAAC,MAAM,OAC/G,OAAM;AACR,0BAAa,cAAc,wBAAwB,MAAM;;KAE3D,UAAU,iBAAiB,WAAW,kBAAkC,4CAAI,YAAY;MAAE,UAAU;MAAgB,UAA0B,4CAAI,YAAY,EAAE,SAAS,CAAC;MAAE,CAAC,GAAmB,4CAAI,YAAY,EAAE,SAAS,CAAC;KAC7N,CACF;IACF,CACF;GAAE,CAAC;EAAE,CAAC,EACP,kBAAkB,eAAe,OAAO,QAAQ,oBAAoC,6CAAKC,6BAAU,EAAE,UAAU,CAC7F,4CAAI,YAAY,EAAE,CAAC,EACnB,4CAAIC,qBAAmB,EAAE,CAAC,CAC3C,EAAE,CAAC,GAAG,KACR,EAAE,CAAC;EACJ;AACF,SAAS,aAAa;CACpB,MAAM,SAAS,WAAW;CAC1B,MAAM,+BAAwB,OAC5B,KAAK,EACN;AACD,QAAuB,4CACrB,UACA;EACE,0BAA0B;EAC1B,MAAM,OAAO;AACX,OAAI,OAAO,gBAAgB,YAAY,KAAK,KAAK,gBAAgB,QAAQ,SAAS,OAAO,eAAe,OAAO;AAC7G,WAAO,KAAK;KACV,MAAM;KACN,GAAG,sBAAsB,OAAO,MAAM;KACvC,CAAC;AACF,oBAAgB,UAAU,OAAO;;;EAGtC,EACD,OAAO,eAAe,MAAM,UAC7B;;AAEH,IAAM,0BAAmB,KAAK,SAAS,eAAe,EACpD,WACC;CACD,MAAM,SAAS,WAAW;CAC1B,MAAM,EAAE,OAAO,KAAK,YAAY,eAAe;EAC7C,SAAS,MAAM;GACb,MAAM,SAAS,EAAE,QAAQ,MAAM,MAAM,EAAE,OAAO,QAAQ;GACtD,MAAM,WAAW,OAAO;GAExB,MAAM,eADY,OAAO,WAAW,UAAU,QAAQ,eAAe,OAAO,QAAQ,sBACpD;IAC9B,SAAS;IACT,YAAY,OAAO;IACnB,QAAQ,OAAO;IACf,QAAQ,OAAO;IAChB,CAAC;AAEF,UAAO;IACL,KAFW,cAAc,KAAK,UAAU,YAAY,GAAG,KAAK;IAG5D,SAAS;IACT,OAAO;KACL,IAAI,OAAO;KACX,QAAQ,OAAO;KACf,OAAO,OAAO;KACd,eAAe,OAAO;KACtB,iBAAiB,OAAO;KACzB;IACF;;EAEH,mBAAmB;EACpB,CAAC;CACF,MAAM,QAAQ,OAAO,WAAW;CAChC,MAAM,mBAAY,cAAc;EAC9B,MAAM,OAAO,MAAM,QAAQ,aAAa,OAAO,QAAQ;AACvD,MAAI,KACF,QAAuB,4CAAI,MAAM,EAAE,EAAE,IAAI;AAE3C,SAAuB,4CAAI,QAAQ,EAAE,CAAC;IACrC;EAAC;EAAK,MAAM,QAAQ;EAAW,OAAO,QAAQ;EAAiB,CAAC;AACnE,KAAI,MAAM,gBACR,OAAM,OAAO,SAAS,MAAM,GAAG,EAAE,aAAa;AAEhD,KAAI,MAAM,cACR,OAAM,OAAO,SAAS,MAAM,GAAG,EAAE,aAAa;AAEhD,KAAI,MAAM,WAAW,WAAW;EAC9B,MAAM,eAAe,MAAM,QAAQ,gBAAgB,OAAO,QAAQ;AAClE,MAAI,cAAc;GAChB,MAAM,cAAc,OAAO,SAAS,MAAM,GAAG;AAC7C,OAAI,eAAe,CAAC,YAAY,aAAa,mBAC3C;QAAI,CAAC,OAAO,UAAU;KACpB,MAAM,oBAAoB,yBAAyB;AACnD,iBAAY,aAAa,oBAAoB;AAC7C,sBAAiB;AACf,wBAAkB,SAAS;AAC3B,kBAAY,aAAa,oBAAoB,KAAK;QACjD,aAAa;;;;AAItB,QAAM,OAAO,SAAS,MAAM,GAAG,EAAE,aAAa;;AAEhD,KAAI,MAAM,WAAW,YAAY;AAC/B,YAAU,WAAW,MAAM,MAAM,EAAE,4BAA4B;AAC/D,SAAO,oBAAoB,QAAQ,OAAO,MAAM,MAAM;;AAExD,KAAI,MAAM,WAAW,cAAc;AACjC,YAAU,WAAW,MAAM,MAAM,EAAE,4BAA4B;AAC/D,QAAM,OAAO,SAAS,MAAM,GAAG,EAAE,aAAa;;AAEhD,KAAI,MAAM,WAAW,SAAS;AAC5B,MAAI,OAAO,SAET,QAAuB,6CADM,MAAM,QAAQ,kBAAkB,OAAO,QAAQ,0BAA0B,gBAGpG;GACE,OAAO,MAAM;GACb,OAAO,KAAK;GACZ,MAAM,EACJ,gBAAgB,IACjB;GACF,CACF;AAEH,QAAM,MAAM;;AAEd,QAAO;EACP;AACF,IAAM,sBAAe,KAAK,SAAS,aAAa;CAC9C,MAAM,SAAS,WAAW;CAC1B,MAAM,uBAAgB,WAAW,aAAa;CAC9C,MAAM,UAAU,eAAe,EAC7B,SAAS,MAAM,EAAE,QAAQ,MAAM,MAAM,EAAE,OAAO,QAAQ,EAAE,SACzD,CAAC;CACF,MAAM,QAAQ,OAAO,WAAW;CAChC,MAAM,uBAAuB,eAAe,EAC1C,SAAS,MAAM;EAEb,MAAM,cADU,EAAE,QACU,MAAM,MAAM,EAAE,OAAO,QAAQ;AACzD,YACE,aACA,4CAA4C,QAAQ,GACrD;AACD,SAAO,YAAY;IAEtB,CAAC;CACF,MAAM,eAAe,eAAe,EAClC,SAAS,MAAM;EACb,MAAM,UAAU,EAAE;AAElB,SAAO,QADO,QAAQ,WAAW,MAAM,EAAE,OAAO,QAAQ,GACjC,IAAI;IAE9B,CAAC;CACF,MAAM,iBAAiB,OAAO,QAAQ,0BAA0C,4CAAI,OAAO,QAAQ,yBAAyB,EAAE,CAAC,GAAG;AAClI,KAAI,qBACF,QAAO,oBAAoB,QAAQ,OAAO,KAAK,EAAE;AAEnD,KAAI,CAAC,aACH,QAAO;CAET,MAAM,YAA4B,4CAAI,OAAO,EAAE,SAAS,cAAc,CAAC;AACvE,KAAI,YAAY,YACd,QAAuB,yDAAU,UAAU;EAAE,UAAU;EAAgB,UAAU;EAAW,CAAC;AAE/F,QAAO;EACP;;;;AChOF,SAAS,UAAU;CACjB,MAAM,SAAS,WAAW;CAE1B,MAAM,mBADY,OAAO,WAAW,aACD,QAAQ,oBAAoB,OAAO,QAAQ;CAC9E,MAAM,iBAAiB,mBAAmC,4CAAI,kBAAkB,EAAE,CAAC,GAAG;CAEtF,MAAM,QAAwB,6CADL,OAAO,YAAY,OAAO,aAAa,eAAe,OAAO,MAAM,4BAAqB,UAC5D;EAAE,UAAU;EAAgB,UAAU,CACzF,CAAC,OAAO,YAA4B,4CAAI,cAAc,EAAE,CAAC,EACzC,4CAAI,cAAc,EAAE,CAAC,CACtC;EAAE,CAAC;AACJ,QAAO,OAAO,QAAQ,YAA4B,4CAAI,OAAO,QAAQ,WAAW,EAAE,UAAU,OAAO,CAAC,GAAG;;AAEzG,SAAS,eAAe;CACtB,MAAM,SAAS,WAAW;CAC1B,MAAM,UAAU,eAAe,EAC7B,SAAS,MAAM;AACb,SAAO,EAAE,QAAQ,IAAI;IAExB,CAAC;CACF,MAAM,WAAW,eAAe,EAC9B,SAAS,MAAM,EAAE,UAClB,CAAC;CACF,MAAM,iBAAiB,UAA0B,4CAAI,OAAO,EAAE,SAAS,CAAC,GAAG;AAC3E,QAAuB,4CAAI,aAAa,UAAU;EAAE,OAAO;EAAS,UAAU,OAAO,QAAQ,6BAA6B,iBAAiC,4CACzJ,eACA;GACE,mBAAmB;GACnB,gBAAgB;GAChB,UAAU,UAAU;AAClB,6BACE,OACA,6HACD;AACD,6BAAQ,OAAO,MAAM,WAAW,MAAM,UAAU,CAAC;;GAEnD,UAAU;GACX,CACF;EAAE,CAAC;;AAEN,SAAS,gBAAgB;CACvB,MAAM,SAAS,WAAW;AAC1B,gBAAe;EACb,SAAS,MAAM;GAAC,EAAE,SAAS;GAAM,EAAE,kBAAkB;GAAM,EAAE;GAAO;EACpE,mBAAmB;EACpB,CAAC;AACF,qBAAa,aACV,SAAS;EACR,MAAM,EAAE,SAAS,eAAe,OAAO,cAAe,GAAG,SAAS;AAClE,SAAO,OAAO,WAAW,MAAM;GAC7B;GACA;GACA;GACA;GACD,CAAC;IAEJ,CAAC,OAAO,CACT;;AAEH,SAAS,WAAW,OAAO;CAEzB,MAAM,SADa,eAAe,CACR,MAAM;AAChC,KAAI,OAAO,MAAM,aAAa,WAC5B,QAAO,MAAM,SAAS,OAAO;AAE/B,QAAO,SAAS,MAAM,WAAW;;AAEnC,SAAS,WAAW,MAAM;AACxB,QAAO,eAAe;EACpB,SAAS,UAAU;GACjB,MAAM,UAAU,MAAM;AACtB,UAAO,MAAM,SAAS,KAAK,OAAO,QAAQ,GAAG;;EAE/C,mBAAmB,MAAM;EAC1B,CAAC;;AAEJ,SAAS,iBAAiB,MAAM;CAC9B,MAAM,8BAAuB,WAAW,aAAa;AACrD,QAAO,WAAW;EAChB,SAAS,YAAY;AACnB,aAAU,QAAQ,MAChB,GACA,QAAQ,WAAW,MAAM,EAAE,OAAO,eAAe,CAClD;AACD,UAAO,MAAM,SAAS,KAAK,OAAO,QAAQ,GAAG;;EAE/C,mBAAmB,MAAM;EAC1B,CAAC;;AAEJ,SAAS,gBAAgB,MAAM;CAC7B,MAAM,8BAAuB,WAAW,aAAa;AACrD,QAAO,WAAW;EAChB,SAAS,YAAY;AACnB,aAAU,QAAQ,MAChB,QAAQ,WAAW,MAAM,EAAE,OAAO,eAAe,GAAG,EACrD;AACD,UAAO,MAAM,SAAS,KAAK,OAAO,QAAQ,GAAG;;EAE/C,mBAAmB,MAAM;EAC1B,CAAC;;;;;AC3GJ,IAAM,gBAAgB,YAAY;AAChC,QAAO,IAAI,OAAO,QAAQ;;AAE5B,IAAM,SAAN,cAAqB,WAAW;CAC9B,YAAY,SAAS;AACnB,QAAM,QAAQ;;;AAGlB,IAAI,OAAO,eAAe,aAAa;AACrC,YAAW,kBAAkB;AAC7B,YAAW,sBAAsB;WACxB,OAAO,WAAW,aAAa;AACxC,QAAO,kBAAkB;AACzB,QAAO,sBAAsB;;;;;ACZ/B,SAAS,sBAAsB,EAC7B,QACA,SACA,GAAG,QACF;AACD,KAAI,OAAO,KAAK,KAAK,CAAC,SAAS,EAC7B,QAAO,OAAO;EACZ,GAAG,OAAO;EACV,GAAG;EACH,SAAS;GACP,GAAG,OAAO,QAAQ;GAClB,GAAG,KAAK;GACT;EACF,CAAC;CAGJ,MAAM,WAA2B,4CADX,kBAAkB,CACW,UAAU;EAAE,OAAO;EAAQ;EAAU,CAAC;AACzF,KAAI,OAAO,QAAQ,KACjB,QAAuB,4CAAI,OAAO,QAAQ,MAAM,EAAE,UAAU,UAAU,CAAC;AAEzE,QAAO;;AAET,SAAS,eAAe,EAAE,OAAQ,GAAG,QAAQ;AAC3C,QAAuB,4CAAI,uBAAuB;EAAE;EAAQ,GAAG;EAAM,UAA0B,4CAAI,SAAS,EAAE,CAAC;EAAE,CAAC;;;;;ACxBpH,SAAS,uBAAuB;AAE9B,wBADe,WAAW,EACK,KAAK;;AAEtC,SAAS,kBAAkB,QAAQ;AACjC,uBAAsB;AAEpB,SAAQ,KACN,wGACD;AAEH,QAAO;;AAET,SAAS,4BAA4B,SAAS;AAC5C,uBAAsB;CACtB,MAAM,SAAS,WAAW;CAC1B,MAAM,SAAS,QAAQ,UAAU;CACjC,IAAI,kBAAkB;AACtB,KAAI,QAAQ,GACV,mBAAkB,gCAAgC,QAAQ,GAAG;MACxD;EACL,MAAM,UAAU,QAAQ,cAAc;AACtC,MAAI,CAAC,QACH;AAEF,oBAAkB,mBAAmB,SAAS,WAAW,eAAe,QAAQ;;CAElF,MAAM,aAAa,OAAO,OAAO,eAAe;AAEhD,SADc,wBAAwB,MAAM,eAC7B;;;;;AC7BjB,SAAS,oBAAoB,MAAM,WAAW;AAC5C,KAAI,SAAS,KAAK,EAChB,QAAO;EACL,qBAAqB;EACrB,cAAc;EACf;AAEH,KAAI,mBAAmB,KACrB,QAAO;AAET,KAAI,OAAO,SAAS,YAAY;EAC9B,MAAM,eAAe,QAAQ,aAAa,KAAK;EAC/C,MAAM,oBAAoB,YAAY;AACpC,OAAI,aAAc,QAAO,MAAM,MAAM;AACrC,UAAO;;AAET,SAAO;GACL,eAAe;GACf,oBAAoB;GACpB,cAAc;GACf;;CAEH,MAAM,cAAc,QAAQ,KAAK,aAAa,KAAK;CACnD,MAAM,KAAK,KAAK;CAChB,MAAM,mBAAmB,YAAY;AACnC,MAAI,eAAe,OAAO,KAAK,EAC7B,QAAO,MAAM,IAAI;AAEnB,SAAO;;AAET,QAAO;EACL,eAAe;EACf,oBAAoB;EACpB,cAAc,OAAO,KAAK;EAC3B;;AAEH,SAAS,WAAW,MAAM,WAAW;CACnC,MAAM,EACJ,eACA,qBAAqB,MACrB,WAAW,OACX,eAAe,UACb,oBAAoB,MAAM,UAAU;CACxC,MAAM,SAAS,WAAW;CAC1B,MAAM,EAAE,YAAY;CACpB,MAAM,CAAC,UAAU,4BAAqB,SAAS;EAC7C,QAAQ;EACR,SAAS,KAAK;EACd,MAAM,KAAK;EACX,QAAQ,KAAK;EACb,SAAS,KAAK;EACd,OAAO,KAAK;EACb,CAAC;AACF,cAAM,gBAAgB;EACpB,MAAM,oBAAoB,OAAO,kBAAkB;GACjD,SAAS,YAAY,UAAU;IAC7B,MAAM,iBAAiB,OAAO,cAAc,SAAS;IACrD,MAAM,gBAAgB,OAAO,iBAC3B,eAAe,UACf,KAAK,EACN;AACD,QAAI,cAAc,eAAe,KAAK,EACpC,OAAM,IAAI,MAAM,+BAA+B,SAAS,OAAO;AAEjE,WAAO;KACL,SAAS,cAAc,WAAW;KAClC,UAAU,cAAc,WAAW;KACnC,UAAU,eAAe;KACzB,QAAQ,cAAc;KACtB,QAAQ,eAAe;KACxB;;GAEH,MAAM,UAAU,YAAY,cAAc,gBAAgB;GAC1D,MAAM,OAAO,YAAY,cAAc,aAAa;GACpD,MAAM,cAAc,MAAM,cAAc;IACtC,QAAQ,cAAc;IACtB;IACA;IACD,CAAC;AACF,OAAI,CAAC,aACH,QAAO;AAET,OAAI,CAAC,YACH,QAAO;GAYT,MAAM,mBAAmB,MAVT,IAAI,SAAS,YAAY;AACvC,gBAAY;KACV,QAAQ;KACR;KACA;KACA,QAAQ,cAAc;KACtB,eAAe,QAAQ,MAAM;KAC7B,aAAa,QAAQ,KAAK;KAC3B,CAAC;KACF;AAEF,eAAY;IACV,QAAQ;IACR,SAAS,KAAK;IACd,MAAM,KAAK;IACX,QAAQ,KAAK;IACb,SAAS,KAAK;IACd,OAAO,KAAK;IACb,CAAC;AACF,UAAO;;AAET,SAAO,WAAW,KAAK,IAAI,QAAQ,MAAM;GAAE,WAAW;GAAmB;GAAoB,CAAC;IAC7F;EACD;EACA;EACA;EACA;EACA;EACA;EACD,CAAC;AACF,QAAO;;AAET,IAAM,6BAA6B,UAAU;AAC3C,KAAI,mBAAmB,MACrB,QAAO,EAAE,GAAG,OAAO;CAErB,MAAM,cAAc,QAAQ,MAAM,aAAa,KAAK;CACpD,MAAM,KAAK,MAAM;CACjB,MAAM,mBAAmB,YAAY;AACnC,MAAI,eAAe,OAAO,KAAK,EAC7B,QAAO,MAAM,IAAI;AAEnB,SAAO;;AAET,QAAO;EACL,eAAe;EACf,oBAAoB;EACpB,cAAc,OAAO,KAAK;EAC3B;;AAEH,SAAS,MAAM,MAAM;CACnB,MAAM,EAAE,SAAU,GAAG,SAAS;CAE9B,MAAM,WAAW,WADJ,0BAA0B,KAAK,CACX;AACjC,QAAO,WAAW,OAAO,aAAa,aAAa,SAAS,SAAS,GAAG,WAAW;;;;;AC5IrF,SAAS,gBAAgB,MAAM;AAC7B,QAAO,SAAS;EACd,GAAG;EACH,SAAS,UAAU,KAAK,SAAS,KAAK,OAAO,MAAM,QAAQ,GAAG,MAAM;EACrE,CAAC;;;;;ACJJ,SAAS,YAAY,MAAM;AACzB,QAAO,eAAe,EACpB,SAAS,UAAU,MAAM,SAAS,KAAK,OAAO,MAAM,SAAS,GAAG,MAAM,UACvE,CAAC;;;;;ACHJ,SAAS,eAAe;AACtB,QAAO,eAAe,EAAE,SAAS,MAAM,EAAE,SAAS,MAAM,gBAAgB,GAAG,CAAC;;;;;ACC9E,SAAS,MAAM,EACb,KACA,OACA,UACA,SACC;AACD,SAAQ,KAAR;EACE,KAAK,QACH,QAAuB,4CAAI,SAAS;GAAE,GAAG;GAAO,0BAA0B;GAAM;GAAU,CAAC;EAC7F,KAAK,OACH,QAAuB,4CAAI,QAAQ;GAAE,GAAG;GAAO,0BAA0B;GAAM,CAAC;EAClF,KAAK,OACH,QAAuB,4CAAI,QAAQ;GAAE,GAAG;GAAO;GAAO,0BAA0B;GAAM,CAAC;EACzF,KAAK,QACH,QAAuB,4CACrB,SACA;GACE,GAAG;GACH,yBAAyB,EAAE,QAAQ,UAAU;GAC7C;GACD,CACF;EACH,KAAK,SACH,QAAuB,4CAAI,QAAQ;GAAE;GAAO;GAAU,CAAC;EACzD,QACE,QAAO;;;AAGb,SAAS,OAAO,EACd,OACA,YACC;CACD,MAAM,SAAS,WAAW;AAC1B,cAAM,gBAAgB;AACpB,MAAI,OAAO,KAAK;GACd,MAAM,iBAAiB;AACrB,QAAI;KACF,MAAM,OAAO,SAAS,WAAW,OAAO,SAAS;AACjD,YAAO,IAAI,IAAI,MAAM,KAAK,KAAK,CAAC;YAC1B;AACN,YAAO,MAAM;;OAEb;AAIJ,OAHuB,MAAM,KAC3B,SAAS,iBAAiB,cAAc,CACzC,CAAC,MAAM,OAAO,GAAG,QAAQ,QAAQ,CAEhC;GAEF,MAAM,SAAS,SAAS,cAAc,SAAS;AAC/C,QAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,MAAM,CAC9C,KAAI,QAAQ,8BAA8B,UAAU,KAAK,KAAK,UAAU,MACtE,QAAO,aACL,KACA,OAAO,UAAU,YAAY,KAAK,OAAO,MAAM,CAChD;AAGL,YAAS,KAAK,YAAY,OAAO;AACjC,gBAAa;AACX,QAAI,OAAO,WACT,QAAO,WAAW,YAAY,OAAO;;;AAI3C,MAAI,OAAO,aAAa,UAAU;GAChC,MAAM,WAAW,OAAO,OAAO,SAAS,WAAW,MAAM,OAAO;GAChE,MAAM,YAAY,OAAO,OAAO,UAAU,WAAW,MAAM,QAAQ,KAAK;AASxE,OARuB,MAAM,KAC3B,SAAS,iBAAiB,oBAAoB,CAC/C,CAAC,MAAM,OAAO;AACb,QAAI,EAAE,cAAc,mBAAoB,QAAO;IAC/C,MAAM,QAAQ,GAAG,aAAa,OAAO,IAAI;IACzC,MAAM,SAAS,GAAG,aAAa,QAAQ,IAAI,KAAK;AAChD,WAAO,GAAG,gBAAgB,YAAY,UAAU,YAAY,WAAW;KACvE,CAEA;GAEF,MAAM,SAAS,SAAS,cAAc,SAAS;AAC/C,UAAO,cAAc;AACrB,OAAI,OACF;SAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,MAAM,CAC9C,KAAI,QAAQ,8BAA8B,UAAU,KAAK,KAAK,UAAU,MACtE,QAAO,aACL,KACA,OAAO,UAAU,YAAY,KAAK,OAAO,MAAM,CAChD;;AAIP,YAAS,KAAK,YAAY,OAAO;AACjC,gBAAa;AACX,QAAI,OAAO,WACT,QAAO,WAAW,YAAY,OAAO;;;IAK1C,CAAC,OAAO,SAAS,CAAC;AACrB,KAAI,CAAC,OAAO,SACV,QAAO;AAET,KAAI,OAAO,OAAO,OAAO,MAAM,QAAQ,SACrC,QAAuB,4CAAI,UAAU;EAAE,GAAG;EAAO,0BAA0B;EAAM,CAAC;AAEpF,KAAI,OAAO,aAAa,SACtB,QAAuB,4CACrB,UACA;EACE,GAAG;EACH,yBAAyB,EAAE,QAAQ,UAAU;EAC7C,0BAA0B;EAC3B,CACF;AAEH,QAAO;;;;;AClHT,IAAM,gBAAgB;CACpB,MAAM,SAAS,WAAW;CAC1B,MAAM,QAAQ,OAAO,QAAQ,KAAK;CAClC,MAAM,YAAY,eAAe,EAC/B,SAAS,UAAU;AACjB,SAAO,MAAM,QAAQ,KAAK,UAAU,MAAM,KAAK,CAAC,OAAO,QAAQ;IAElE,CAAC;CACF,MAAM,oBAAa,cAAc;EAC/B,MAAM,aAAa,EAAE;EACrB,MAAM,kBAAkB,EAAE;EAC1B,IAAI;AACJ,OAAK,IAAI,IAAI,UAAU,SAAS,GAAG,KAAK,GAAG,KAAK;GAC9C,MAAM,QAAQ,UAAU;AACxB,QAAK,IAAI,IAAI,MAAM,SAAS,GAAG,KAAK,GAAG,KAAK;IAC1C,MAAM,IAAI,MAAM;AAChB,QAAI,CAAC,EAAG;AACR,QAAI,EAAE,OACJ;SAAI,CAAC,MACH,SAAQ;MACN,KAAK;MACL,UAAU,EAAE;MACb;WAEE;KACL,MAAM,YAAY,EAAE,QAAQ,EAAE;AAC9B,SAAI,UACF,KAAI,gBAAgB,WAClB;SAEA,iBAAgB,aAAa;AAGjC,gBAAW,KAAK;MACd,KAAK;MACL,OAAO;OACL,GAAG;OACH;OACD;MACF,CAAC;;;;AAIR,MAAI,MACF,YAAW,KAAK,MAAM;AAExB,MAAI,MACF,YAAW,KAAK;GACd,KAAK;GACL,OAAO;IACL,UAAU;IACV,SAAS;IACV;GACF,CAAC;AAEJ,aAAW,SAAS;AACpB,SAAO;IACN,CAAC,WAAW,MAAM,CAAC;CACtB,MAAM,QAAQ,eAAe;EAC3B,SAAS,UAAU;GACjB,MAAM,cAAc,MAAM,QAAQ,KAAK,UAAU,MAAM,MAAM,CAAC,OAAO,QAAQ,CAAC,KAAK,EAAE,CAAC,KAAK,UAAU;IACnG,KAAK;IACL,OAAO;KACL,GAAG;KACH;KACD;IACF,EAAE;GACH,MAAM,WAAW,OAAO,KAAK;GAC7B,MAAM,SAAS,MAAM,QAAQ,KAAK,UAAU,UAAU,OAAO,MAAM,UAAU,UAAU,EAAE,CAAC,CAAC,OAAO,QAAQ,CAAC,KAAK,EAAE,CAAC,QAAQ,UAAU,MAAM,QAAQ,OAAO,CAAC,KACxJ,WAAW;IACV,KAAK;IACL,OAAO;KACL,GAAG,MAAM;KACT,0BAA0B;KAC1B;KACD;IACF,EACF;AACD,UAAO,CAAC,GAAG,aAAa,GAAG,OAAO;;EAEpC,mBAAmB;EACpB,CAAC;CACF,MAAM,cAAc,eAAe;EACjC,SAAS,UAAU;GACjB,MAAM,eAAe,EAAE;AACvB,SAAM,QAAQ,KAAK,UAAU,OAAO,gBAAgB,MAAM,SAAS,CAAC,SACjE,UAAU,OAAO,KAAK,UAAU,OAAO,MAAM,KAAK,UAAU,OAAO,QAAQ,CAAC,SAAS,YAAY;AAChG,iBAAa,KAAK;KAChB,KAAK;KACL,OAAO;MACL,KAAK;MACL,MAAM;MACN;MACD;KACF,CAAC;KACF,CACH;AACD,UAAO;;EAET,mBAAmB;EACpB,CAAC;CACF,MAAM,SAAS,eAAe;EAC5B,SAAS,UAAU,MAAM,QAAQ,KAAK,UAAU,MAAM,OAAO,CAAC,KAAK,EAAE,CAAC,OAAO,QAAQ,CAAC,KAAK,EAAE,SAAU,GAAG,aAAa;GACrH,KAAK;GACL;GACA;GACA;GACD,EAAE;EACH,mBAAmB;EACpB,CAAC;CACF,MAAM,cAAc,eAAe;EACjC,SAAS,UAAU,MAAM,QAAQ,KAAK,UAAU,MAAM,YAAY,CAAC,KAAK,EAAE,CAAC,OAAO,QAAQ,CAAC,KAAK,EAAE,SAAU,GAAG,cAAc;GAC3H,KAAK;GACL,OAAO;IACL,GAAG;IACH;IACD;GACD;GACD,EAAE;EACH,mBAAmB;EACpB,CAAC;AACF,QAAO,OACL;EACE,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;EACH,GAAG;EACJ,GACA,MAAM;AACL,SAAO,KAAK,UAAU,EAAE;GAE3B;;AAEH,SAAS,cAAc;CACrB,MAAM,OAAO,SAAS;CAEtB,MAAM,QADS,WAAW,CACL,QAAQ,KAAK;AAClC,QAAO,KAAK,KAAK,QAAwB,gDAAc,OAAO;EAAE,GAAG;EAAK,KAAK,YAAY,KAAK,UAAU,IAAI;EAAI;EAAO,CAAC,CAAC;;AAE3H,SAAS,OAAO,KAAK,IAAI;CACvB,MAAM,uBAAuB,IAAI,KAAK;AACtC,QAAO,IAAI,QAAQ,SAAS;EAC1B,MAAM,MAAM,GAAG,KAAK;AACpB,MAAI,KAAK,IAAI,IAAI,CACf,QAAO;AAET,OAAK,IAAI,IAAI;AACb,SAAO;GACP;;;;;ACrJJ,IAAM,gBAAgB;CACpB,MAAM,SAAS,WAAW;CAC1B,MAAM,QAAQ,OAAO,QAAQ,KAAK;CAClC,MAAM,eAAe,eAAe;EAClC,SAAS,UAAU;GACjB,MAAM,gBAAgB,EAAE;GACxB,MAAM,WAAW,OAAO,KAAK;AAC7B,OAAI,CAAC,SACH,QAAO,EAAE;AAEX,SAAM,QAAQ,KAAK,UAAU,OAAO,gBAAgB,MAAM,SAAS,CAAC,SACjE,UAAU,SAAS,OAAO,MAAM,KAAK,QAAQ,QAAQ,MAAM,EAAE,QAAQ,SAAS,CAAC,SAAS,UAAU;AACjG,kBAAc,KAAK;KACjB,KAAK;KACL,OAAO;MAAE,GAAG,MAAM;MAAO;MAAO;KAChC,UAAU,MAAM;KACjB,CAAC;KACF,CACH;AACD,UAAO;;EAET,mBAAmB;EACpB,CAAC;CACF,MAAM,EAAE,YAAY,eAAe;EACjC,SAAS,WAAW,EAClB,SAAS,MAAM,QAAQ,KAAK,UAAU,MAAM,QAAQ,CAAC,KAAK,EAAE,CAAC,OAAO,QAAQ,CAAC,KAAK,EAAE,SAAU,GAAG,cAAc;GAC7G,KAAK;GACL,OAAO;IACL,GAAG;IACH,0BAA0B;IAC1B;IACD;GACD;GACD,EAAE,EACJ;EACD,mBAAmB;EACpB,CAAC;AAEF,QAAuB,4CAAIC,6BAAU,EAAE,UADpB,CAAC,GAAG,SAAS,GAAG,aAAa,CACY,KAAK,OAAO,MAAsB,gDAAc,OAAO;EAAE,GAAG;EAAO,KAAK,eAAe,MAAM,IAAI,GAAG;EAAK,CAAC,CAAC,EAAE,CAAC"}